{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useGraphStates } from './Graphs';\nexport const useNodeFunctions = () => {\n  _s();\n  const {\n    nodes,\n    setNodes,\n    nodeCount,\n    setNodeCount,\n    adjList,\n    setAdjList,\n    setText\n  } = useGraphStates();\n\n  // Function to add a new node to the graph\n  const addNode = () => {\n    if (algorithmRunning) {\n      return;\n    }\n    if (nodes.length >= 20) {\n      alert(\"too many nodes\");\n      return;\n    }\n    setText(startingText);\n    const newNode = {\n      id: nodeCount,\n      x: Math.random() * 480,\n      y: Math.random() * 480\n    };\n    setNodes([...nodes, newNode]);\n    setAdjList(prevAdjList => ({\n      ...prevAdjList,\n      [newNode.id]: []\n    }));\n    setNodeCount(nodeCount + 1);\n  };\n\n  // Function to generate a random graph\n  const generateGraph = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    var numNodes = 0;\n    var numEdges = -1;\n    do {\n      const response = prompt(\"Enter the number of nodes for the graph:\", \"\");\n      if (response === null) {\n        return;\n      }\n      if (isNaN(response)) {\n        alert(\"Invalid input. Please enter numbers only\");\n        continue;\n      }\n      if (response <= 0 || response > 20) {\n        alert(\"Invalid input. Number of nodes must be between 1 and 20\");\n        continue;\n      }\n      numNodes = response;\n    } while (numNodes === 0);\n    do {\n      const response = prompt(\"Enter the number of edges for the graph:\", \"\");\n      if (response === null) {\n        return;\n      }\n      if (isNaN(response)) {\n        alert(\"Invalid input. Please enter numbers only\");\n        continue;\n      }\n      if (!isDirected) {\n        if (response > numNodes * (numNodes - 1) / 2) {\n          alert(\"Invalid input. Too many edges for the undirected graph\");\n          continue;\n        }\n      } else {\n        if (response > numNodes * (numNodes - 1)) {\n          alert(\"Invalid input. Too many edges for the directed graph\");\n          continue;\n        }\n      }\n      if (response < 0) {\n        alert(\"Invalid input. Not enough edges\");\n        continue;\n      }\n      numEdges = response;\n    } while (numEdges === -1);\n    setNodes([]);\n    setEdges([]);\n    setAdjList({});\n    setNodeCount(0);\n    setVisitedNodes([]);\n    setVisitedEdges([]);\n    setSelectedNode(null);\n    setText(startingText);\n    const newNodes = [];\n    const newEdges = [];\n    const newAdjList = {};\n    const gridSize = Math.ceil(Math.sqrt(numNodes));\n    const areaWidth = 500;\n    const areaHeight = 500;\n    const margin = 10;\n    const gridSpacingX = (areaWidth - 2 * margin) / gridSize;\n    const gridSpacingY = (areaHeight - 2 * margin) / gridSize;\n    for (let i = 0; i < numNodes; i++) {\n      const row = Math.floor(i / gridSize);\n      const col = i % gridSize;\n      const x = margin + col * gridSpacingX + Math.random() * gridSpacingX * 0.9;\n      const y = margin + row * gridSpacingY + Math.random() * gridSpacingY * 0.9;\n      const newNode = {\n        id: i,\n        x: x,\n        y: y\n      };\n      newNodes.push(newNode);\n      newAdjList[i] = [];\n    }\n    while (newEdges.length < numEdges) {\n      const from = newNodes[Math.floor(Math.random() * numNodes)];\n      const to = newNodes[Math.floor(Math.random() * numNodes)];\n      if (from.id !== to.id) {\n        const edgeExists = newEdges.some(edge => edge.from.id === from.id && edge.to.id === to.id || !isDirected && edge.from.id === to.id && edge.to.id === from.id);\n        if (!edgeExists) {\n          const newEdge = {\n            from,\n            to,\n            color: defaultEdgeColor\n          };\n          newEdges.push(newEdge);\n          newAdjList[from.id].push(to.id);\n          if (!isDirected) {\n            newAdjList[to.id].push(from.id);\n          }\n        }\n      }\n    }\n    setNodes(newNodes);\n    setEdges(newEdges);\n    setAdjList(newAdjList);\n    setNodeCount(newNodes.length);\n  };\n\n  // Function to reset the graph\n  const resetGraph = () => {\n    if (algorithmRunning) {\n      return;\n    }\n    setNodes([]);\n    setEdges([]);\n    setClickedMST(false);\n    setClickedTraveral(false);\n    setIsRemovingEdge(false);\n    setText(startingText);\n  };\n\n  // Function to remove a selected node form the graph\n  const removeNode = () => {\n    if (selectedNode == null) return;\n    setNodes(nodes.filter(node => node.id !== selectedNode.id));\n    setEdges(edges.filter(edge => edge.from.id !== selectedNode.id && edge.to.id !== selectedNode.id));\n    setAdjList(prevAdjList => {\n      const newAdjList = {\n        ...prevAdjList\n      };\n      delete newAdjList[selectedNode.id];\n      for (const key in newAdjList) {\n        newAdjList[key] = newAdjList[key].filter(id => id !== selectedNode.id);\n      }\n      return newAdjList;\n    });\n    setSelectedNode(null);\n  };\n\n  // Function to handle clicking on a node\n  const handleNodeClick = node => {\n    if (dragging) {\n      return;\n    }\n    if (isAddingEdge) {\n      if (selectedNode && selectedNode.id !== node.id) {\n        const edgeExists = edges.some(edge => edge.from.id === selectedNode.id && edge.to.id === node.id || !isDirected && edge.from.id === node.id && edge.to.id === selectedNode.id);\n        if (!edgeExists) {\n          const newEdge = {\n            from: selectedNode,\n            to: node,\n            color: defaultEdgeColor\n          };\n          setEdges(prevEdges => [...prevEdges, newEdge]);\n          setAdjList(prevAdjList => {\n            const newAdjList = {\n              ...prevAdjList\n            };\n            if (!newAdjList[selectedNode.id]) newAdjList[selectedNode.id] = [];\n            if (!newAdjList[node.id]) newAdjList[node.id] = [];\n            newAdjList[selectedNode.id].push(node.id);\n            if (!isDirected) {\n              newAdjList[node.id].push(selectedNode.id);\n            }\n            return newAdjList;\n          });\n        }\n        setIsAddingEdge(false);\n        setSelectedNode(null);\n      } else if (selectedNode && selectedNode.id === node.id) {\n        setSelectedNode(null);\n        setIsAddingEdge(false);\n      }\n      setText(startingText);\n    } else if (isDFS) {\n      setVisitedNodes([]);\n      setVisitedEdges([]);\n      dfs(node);\n      setIsDFS(false);\n    } else if (isBFS) {\n      setVisitedNodes([]);\n      setVisitedEdges([]);\n      bfs(node);\n      setIsBFS(false);\n    } else if (isPrim) {\n      setIsPrim(false);\n      animatePrimsAlgorithm(node);\n    } else if (isShortestPath) {\n      if (!startNode) {\n        setStartNode(node);\n        setText(\"Select End Node for Shortest Path\");\n      } else if (!endNode) {\n        setEndNode(node);\n        setText(\"Finding Shortest Path...\");\n        findShortestPath(startNode, node);\n        setIsShortestPath(false);\n      }\n    } else if (isTSP) {\n      setVisitedNodes([]);\n      setVisitedEdges([]);\n      tsp(node);\n      setIsTSP(false);\n    } else {\n      if (selectedNode && selectedNode.id === node.id) {\n        setSelectedNode(null);\n        setText(startingText);\n      } else {\n        if (!algorithmRunning) {\n          setSelectedNode(node);\n        }\n      }\n    }\n  };\n\n  // Function to handle mouse down event for dragging\n  const handleMouseDown = () => {\n    setDragging(false);\n  };\n\n  // Function to handle slider change\n  const handleSliderChange = event => {\n    const newValue = event.target.value;\n    setSliderValue(newValue);\n    sliderValueRef.current = newValue;\n  };\n\n  // Function to start removing an edge\n  const startRemovingEdge = () => {\n    if (algorithmRunning) {\n      return;\n    }\n    if (isRemovingEdge) {\n      setIsRemovingEdge(false);\n      setText(\"\");\n      return;\n    }\n    if (edges.length < 1) {\n      alert(\"must be at least one edge\");\n      return;\n    }\n    setText(\"Click on an edge to remove it\");\n    setIsRemovingEdge(true);\n  };\n\n  // Function to initiate adding an edge\n  const handleAddEdge = () => {\n    if (selectedNode === null) return;\n    if (!isDirected) {\n      if (nodes.length * (nodes.length - 1) / 2 === edges.length) {\n        alert(\"cannot add another edge\");\n        return;\n      }\n    } else {\n      if (nodes.length * (nodes.length - 1) === edges.length) {\n        alert(\"cannot add another edge\");\n        return;\n      }\n    }\n    if (nodes.length < 2) {\n      alert(\"You need at least two nodes to add an edge.\");\n      return;\n    }\n    setIsAddingEdge(true);\n    setText(\"Click another node to add edge\");\n  };\n\n  // Function to handle clicking on an edge\n  const handleEdgeClick = edge => {\n    if (isRemovingEdge) {\n      setEdges(edges.filter(e => e !== edge));\n      setIsRemovingEdge(false);\n      setAdjList(prevAdjList => {\n        const newAdjList = {\n          ...prevAdjList\n        };\n        newAdjList[edge.from.id] = newAdjList[edge.from.id].filter(id => id !== edge.to.id);\n        newAdjList[edge.to.id] = newAdjList[edge.to.id].filter(id => id !== edge.from.id);\n        return newAdjList;\n      });\n      setText(startingText);\n    }\n  };\n\n  // Function to handle dragging a node\n  const handleDrag = (e, data, node) => {\n    setDragging(true);\n    node.x = data.x;\n    node.y = data.y;\n    setNodes([...nodes]);\n  };\n\n  // Function to handle stopping the drag of a node\n  const handleDragStop = () => {\n    setTimeout(() => {\n      setDragging(false);\n    }, 0);\n  };\n};\n_s(useNodeFunctions, \"IDMYxI1GeknzEPWo6W6dqUclOeg=\", false, function () {\n  return [useGraphStates];\n});","map":{"version":3,"names":["useGraphStates","useNodeFunctions","_s","nodes","setNodes","nodeCount","setNodeCount","adjList","setAdjList","setText","addNode","algorithmRunning","length","alert","startingText","newNode","id","x","Math","random","y","prevAdjList","generateGraph","isRemovingEdge","numNodes","numEdges","response","prompt","isNaN","isDirected","setEdges","setVisitedNodes","setVisitedEdges","setSelectedNode","newNodes","newEdges","newAdjList","gridSize","ceil","sqrt","areaWidth","areaHeight","margin","gridSpacingX","gridSpacingY","i","row","floor","col","push","from","to","edgeExists","some","edge","newEdge","color","defaultEdgeColor","resetGraph","setClickedMST","setClickedTraveral","setIsRemovingEdge","removeNode","selectedNode","filter","node","edges","key","handleNodeClick","dragging","isAddingEdge","prevEdges","setIsAddingEdge","isDFS","dfs","setIsDFS","isBFS","bfs","setIsBFS","isPrim","setIsPrim","animatePrimsAlgorithm","isShortestPath","startNode","setStartNode","endNode","setEndNode","findShortestPath","setIsShortestPath","isTSP","tsp","setIsTSP","handleMouseDown","setDragging","handleSliderChange","event","newValue","target","value","setSliderValue","sliderValueRef","current","startRemovingEdge","handleAddEdge","handleEdgeClick","e","handleDrag","data","handleDragStop","setTimeout"],"sources":["/Users/tani/Desktop/visualizer/Visusalizer Project/src/Components/NodeFunctions.js"],"sourcesContent":["import { useGraphStates } from './Graphs';\n\nexport const useNodeFunctions = () => {\n\n    const { nodes, setNodes, nodeCount, setNodeCount, adjList, setAdjList, setText } = useGraphStates();\n\n    // Function to add a new node to the graph\n    const addNode = () => {\n        if(algorithmRunning){\n            return;\n        }\n\n        if(nodes.length >= 20){\n            alert(\"too many nodes\");\n            return;\n        }\n\n        setText(startingText);\n        const newNode = {\n            id: nodeCount,\n            x: Math.random() * 480,\n            y: Math.random() * 480,\n        };\n        setNodes([...nodes, newNode]);\n        setAdjList(prevAdjList => ({ ...prevAdjList, [newNode.id]: [] }));\n        setNodeCount(nodeCount + 1);\n    };\n\n    // Function to generate a random graph\n    const generateGraph = () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n\n        var numNodes = 0;\n        var numEdges = -1;\n\n        do{\n            const response = prompt(\"Enter the number of nodes for the graph:\", \"\");\n            if(response === null){\n                return;\n            }\n            if(isNaN(response)){\n                alert(\"Invalid input. Please enter numbers only\");\n                continue;\n            }\n\n            if(response <= 0 || response > 20){\n                alert(\"Invalid input. Number of nodes must be between 1 and 20\");\n                continue;\n            }\n\n            numNodes = response;\n\n        }while(numNodes === 0);\n\n        do{\n            const response = prompt(\"Enter the number of edges for the graph:\", \"\");\n            if(response === null){\n                return;\n            }\n\n            if(isNaN(response)){\n                alert(\"Invalid input. Please enter numbers only\");\n                continue;\n            }\n\n            if(!isDirected){\n                if(response > ((numNodes * (numNodes - 1)) / 2)){\n                    alert(\"Invalid input. Too many edges for the undirected graph\");\n                    continue;\n                }\n            }else{\n                if(response > ((numNodes * (numNodes - 1)))){\n                    alert(\"Invalid input. Too many edges for the directed graph\");\n                    continue;\n                }\n            }\n            \n            if(response < 0){\n                alert(\"Invalid input. Not enough edges\");\n                continue;\n            }\n\n            numEdges = response;\n\n        }while(numEdges === -1);\n\n        setNodes([]);\n        setEdges([]);\n        setAdjList({});\n        setNodeCount(0);\n        setVisitedNodes([]);\n        setVisitedEdges([]);\n        setSelectedNode(null);\n        setText(startingText);\n\n        const newNodes = [];\n        const newEdges = [];\n        const newAdjList = {};\n\n\n        const gridSize = Math.ceil(Math.sqrt(numNodes));\n        const areaWidth = 500; \n        const areaHeight = 500; \n        const margin = 10;\n        const gridSpacingX = (areaWidth - 2 * margin) / gridSize;\n        const gridSpacingY = (areaHeight - 2 * margin) / gridSize;\n\n        for (let i = 0; i < numNodes; i++) {\n            const row = Math.floor(i / gridSize);\n            const col = i % gridSize;\n            const x = margin + col * gridSpacingX + Math.random() * gridSpacingX * 0.9;\n            const y = margin + row * gridSpacingY + Math.random() * gridSpacingY * 0.9;\n\n            const newNode = {\n                id: i,\n                x: x,\n                y: y,\n            };\n            newNodes.push(newNode);\n            newAdjList[i] = [];\n        }\n\n        while (newEdges.length < numEdges) {\n            const from = newNodes[Math.floor(Math.random() * numNodes)];\n            const to = newNodes[Math.floor(Math.random() * numNodes)];\n            if (from.id !== to.id) {\n                const edgeExists = newEdges.some(edge => \n                    (edge.from.id === from.id && edge.to.id === to.id) ||\n                    (!isDirected && edge.from.id === to.id && edge.to.id === from.id)\n                );\n                if (!edgeExists) {\n                    const newEdge = { from, to, color: defaultEdgeColor };\n                    newEdges.push(newEdge);\n                    newAdjList[from.id].push(to.id);\n                    if(!isDirected){\n                        newAdjList[to.id].push(from.id);\n                    }\n                }\n            }\n        }\n\n        setNodes(newNodes);\n        setEdges(newEdges);\n        setAdjList(newAdjList);\n        setNodeCount(newNodes.length);\n    };\n\n    // Function to reset the graph\n    const resetGraph = () => {\n        if(algorithmRunning){\n            return;\n        }\n        setNodes([]);\n        setEdges([]);\n        setClickedMST(false);\n        setClickedTraveral(false);\n        setIsRemovingEdge(false);\n        setText(startingText);\n    };\n\n    // Function to remove a selected node form the graph\n    const removeNode = () => {\n        if (selectedNode == null) return;\n\n        setNodes(nodes.filter(node => node.id !== selectedNode.id));\n        setEdges(edges.filter(edge => edge.from.id !== selectedNode.id && edge.to.id !== selectedNode.id));\n        setAdjList(prevAdjList => {\n            const newAdjList = { ...prevAdjList };\n            delete newAdjList[selectedNode.id];\n            for (const key in newAdjList) {\n                newAdjList[key] = newAdjList[key].filter(id => id !== selectedNode.id);\n            }\n            return newAdjList;\n        });\n        setSelectedNode(null);\n    };\n\n    // Function to handle clicking on a node\n    const handleNodeClick = (node) => {\n        if (dragging) {\n            return;\n        }\n\n        if (isAddingEdge) {\n            if (selectedNode && selectedNode.id !== node.id) {\n                const edgeExists = edges.some(edge =>\n                    (edge.from.id === selectedNode.id && edge.to.id === node.id) ||\n                    (!isDirected && edge.from.id === node.id && edge.to.id === selectedNode.id)\n                );\n\n                if(!edgeExists){\n                    const newEdge = { from: selectedNode, to: node, color: defaultEdgeColor };\n                    setEdges(prevEdges => [...prevEdges, newEdge]);\n\n                    setAdjList(prevAdjList => {\n                        const newAdjList = { ...prevAdjList };\n                        if (!newAdjList[selectedNode.id]) newAdjList[selectedNode.id] = [];\n                        if (!newAdjList[node.id]) newAdjList[node.id] = [];\n                        newAdjList[selectedNode.id].push(node.id);\n                        if (!isDirected) {\n                            newAdjList[node.id].push(selectedNode.id);\n                        }\n                        return newAdjList;\n                    })\n                }\n                \n                setIsAddingEdge(false);\n                setSelectedNode(null);\n            } else if (selectedNode && selectedNode.id === node.id) {\n                setSelectedNode(null);\n                setIsAddingEdge(false);\n            }\n            setText(startingText);\n        } else if(isDFS){\n            setVisitedNodes([]);\n            setVisitedEdges([]);\n            dfs(node);\n            setIsDFS(false);\n        } else if(isBFS){\n            setVisitedNodes([]);\n            setVisitedEdges([]);\n            bfs(node);\n            setIsBFS(false);\n        }else if(isPrim){\n            setIsPrim(false);\n            animatePrimsAlgorithm(node);\n        }else if(isShortestPath){\n            if(!startNode){\n                setStartNode(node);\n                setText(\"Select End Node for Shortest Path\");\n            }else if(!endNode){\n                setEndNode(node);\n                setText(\"Finding Shortest Path...\");\n                findShortestPath(startNode, node);\n                setIsShortestPath(false);\n            }\n        }else if(isTSP){\n            setVisitedNodes([]);\n            setVisitedEdges([]);\n            tsp(node);\n            setIsTSP(false);\n        }else{\n            if (selectedNode && selectedNode.id === node.id) {\n                setSelectedNode(null); \n                setText(startingText);\n            } else {\n                if(!algorithmRunning){\n                    setSelectedNode(node);\n                }\n                \n            }\n        }\n    }\n\n    // Function to handle mouse down event for dragging\n    const handleMouseDown = () => {\n        setDragging(false);\n    };\n\n    // Function to handle slider change\n    const handleSliderChange = (event) => {\n        const newValue = event.target.value;\n        setSliderValue(newValue);\n        sliderValueRef.current = newValue;\n    }\n\n    // Function to start removing an edge\n    const startRemovingEdge = () => {\n        if(algorithmRunning){\n            return;\n        }\n\n        if(isRemovingEdge){\n            setIsRemovingEdge(false);\n            setText(\"\");\n            return;\n        }\n\n        if(edges.length < 1){\n            alert(\"must be at least one edge\");\n            return;\n        }\n        setText(\"Click on an edge to remove it\");\n        setIsRemovingEdge(true);\n    }\n\n    // Function to initiate adding an edge\n    const handleAddEdge = () => {\n        if (selectedNode === null) return;\n\n        if(!isDirected){\n            if(((nodes.length * (nodes.length - 1)) / 2) === edges.length){\n                alert(\"cannot add another edge\");\n                return;\n            }\n        }else{\n            if(((nodes.length * (nodes.length - 1))) === edges.length){\n                alert(\"cannot add another edge\");\n                return;\n            }\n        }\n        \n\n        if (nodes.length < 2) {\n            alert(\"You need at least two nodes to add an edge.\");\n            return;\n        }\n        setIsAddingEdge(true);\n        setText(\"Click another node to add edge\");\n    };\n\n    // Function to handle clicking on an edge\n    const handleEdgeClick = (edge) => {\n        if (isRemovingEdge) {\n            setEdges(edges.filter(e => e !== edge));\n            setIsRemovingEdge(false);\n\n            setAdjList(prevAdjList => {\n                const newAdjList = { ...prevAdjList };\n                newAdjList[edge.from.id] = newAdjList[edge.from.id].filter(id => id !== edge.to.id);\n                newAdjList[edge.to.id] = newAdjList[edge.to.id].filter(id => id !== edge.from.id);\n                return newAdjList;\n            });\n            setText(startingText);\n        }\n    }\n\n    // Function to handle dragging a node\n    const handleDrag = (e, data, node) => {\n        setDragging(true);\n        node.x = data.x;\n        node.y = data.y;\n        setNodes([...nodes]);\n    };\n\n    // Function to handle stopping the drag of a node\n    const handleDragStop = () => {\n        setTimeout(() => {\n            setDragging(false);\n        }, 0);\n    };\n\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}