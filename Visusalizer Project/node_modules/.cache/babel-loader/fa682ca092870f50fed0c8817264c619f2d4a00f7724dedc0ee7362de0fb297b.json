{"ast":null,"code":"import { sleep } from './GraphUtilities';\n\n// Function to start DFS\nexport const startDFS = () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setRunningAlgorithm(\"DFS\");\n  setIsDFS(true);\n  setAlgorithmRunning(true);\n  setText(\"Select Node to begin DFS\");\n};\n\n// DFS implementatoin\nexport const dfs = async startNode => {\n  setAlgorithmStarted(true);\n  setText(\"DFS in progress...\");\n  const visitedNodeSet = new Set();\n  const visitedEdgeSet = new Set();\n  let stepIndex = 0;\n  const dfsRecursive = async currentNode => {\n    if (visitedNodeSet.has(currentNode.id)) {\n      return;\n    }\n    visitedNodeSet.add(currentNode.id);\n    setVisitedNodes(prev => {\n      const updatedNodes = [...prev, {\n        id: currentNode.id,\n        color: treeEdgeColor\n      }];\n      return updatedNodes;\n    });\n    for (let neighborId of adjList[currentNode.id]) {\n      setCurrentNode(currentNode);\n      const neighborNode = nodes.find(node => node.id === neighborId);\n      const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n      if (!edge) {\n        continue;\n      }\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n      if (!visitedEdgeSet.has(edge)) {\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      }\n      if (!visitedNodeSet.has(neighborId)) {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: treeEdgeColor\n        }]);\n        visitedEdgeSet.add(edge);\n        await dfsRecursive(neighborNode);\n      } else {\n        setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n      }\n    }\n  };\n  await dfsRecursive(startNode);\n  setCurrentNode(null);\n  setAlgorithmStarted(false);\n  setText(\"DFS Done!\");\n  setTimeout(resetEdges, 1000);\n};\n\n// Function to start BFS\nexport const startBFS = () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setRunningAlgorithm(\"BFS\");\n  setIsBFS(true);\n  setAlgorithmRunning(true);\n  setText(\"Select Node to begin BFS\");\n};\n\n// BFS implementation\nexport const bfs = async startNode => {\n  setAlgorithmStarted(true);\n  setText(\"BFS in progress...\");\n  const visitedNodeSet = new Set();\n  const visitedEdgeSet = new Set();\n  let stepIndex = 0;\n  const queue = [startNode];\n  visitedNodeSet.add(startNode.id);\n  setVisitedNodes([{\n    id: startNode.id,\n    color: treeEdgeColor\n  }]);\n  while (queue.length > 0) {\n    const currentNode = queue.shift();\n    setCurrentNode(currentNode);\n    for (let neighborId of adjList[currentNode.id]) {\n      const neighborNode = nodes.find(node => node.id === neighborId);\n      const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n      if (!edge) {\n        continue;\n      }\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n      if (!visitedEdgeSet.has(edge)) {\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      }\n      if (!visitedNodeSet.has(neighborId)) {\n        visitedNodeSet.add(neighborId);\n        queue.push(neighborNode);\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: treeEdgeColor\n        }]);\n        setVisitedNodes(prev => [...prev, {\n          id: neighborId,\n          color: treeEdgeColor\n        }]);\n      } else {\n        setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n      }\n    }\n  }\n  setCurrentNode(null);\n  setAlgorithmStarted(false);\n  setText(\"BFS Done!\");\n  setTimeout(resetEdges, 1000);\n};\n\n// Function to start Prim's algorithm\nexport const startPrim = () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setRunningAlgorithm(\"Prim\");\n  setIsPrim(true);\n  setAlgorithmRunning(true);\n  setText(\"Select Node to begin Prim's Algorithm\");\n};\n\n// Function to animate Prim's algorithm\nexport const animatePrimsAlgorithm = async startNode => {\n  setAlgorithmStarted(true);\n  setIsDirected(false);\n  setText(\"Prim's Algorithm in progress...\");\n  const visitedNodeSet = new Set();\n  const edgeQueue = [];\n  let stepIndex = 0;\n  const addEdges = node => {\n    visitedNodeSet.add(node.id);\n    setVisitedNodes(prev => [...prev, {\n      id: node.id,\n      color: treeEdgeColor\n    }]);\n    (adjList[node.id] || []).forEach(neighborId => {\n      if (!visitedNodeSet.has(neighborId)) {\n        const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === node.id);\n        if (edge) {\n          edgeQueue.push({\n            ...edge,\n            length: calculateEdgeLength(edge)\n          });\n        }\n      }\n    });\n    edgeQueue.sort((a, b) => a.length - b.length);\n  };\n  const animateStep = async () => {\n    if (visitedNodeSet.size === nodes.length || edgeQueue.length === 0) {\n      setAlgorithmStarted(false);\n      setText(\"Prim's Algorithm Done!\");\n      setTimeout(resetEdges, 1000);\n      return;\n    }\n    const edgesToHighlight = edgeQueue.slice(0, 1);\n    edgesToHighlight.forEach(edge => {\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n    });\n    stepIndex++;\n    if (isPausedRef.current) {\n      await new Promise(resolve => {\n        const checkStep = () => {\n          if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n            resolve();\n          } else {\n            setTimeout(checkStep, 50);\n          }\n        };\n        checkStep();\n      });\n      if (isStepModeRef.current) {\n        setIsPaused(true);\n        isPausedRef.current = true;\n      }\n    } else {\n      await sleep(totalSliderCount - sliderValueRef.current);\n    }\n    if (isStepModeRef.current) {\n      setIsPaused(true);\n      isPausedRef.current = true;\n    }\n    const edge = edgeQueue.shift();\n    const {\n      from,\n      to\n    } = edge;\n    const fromInMST = visitedNodeSet.has(from.id);\n    const toInMST = visitedNodeSet.has(to.id);\n    if (fromInMST && !toInMST || !fromInMST && toInMST) {\n      setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n        ...edge,\n        color: treeEdgeColor\n      }]);\n      if (fromInMST && !toInMST) {\n        addEdges(to);\n      } else if (!fromInMST && toInMST) {\n        addEdges(from);\n      }\n    } else {\n      setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n        ...edge,\n        color: defaultEdgeColor\n      }]);\n    }\n    animateStep();\n  };\n  addEdges(startNode);\n  animateStep();\n};\n\n// Function to animate Kruskall's algorithm\nexport const animateKruskalsAlgorithm = () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setIsDirected(false);\n  setRunningAlgorithm(\"Kruskall\");\n  setDisablePause(true);\n  setAlgorithmRunning(true);\n  setText(\"Kruskall's Algorithm in progress...\");\n  const sortedEdges = [...edges].sort((a, b) => calculateEdgeLength(a) - calculateEdgeLength(b));\n  let componentIndex = 0;\n  let currentComponentEdges = [];\n  let currentComponentNodes = [];\n  let uf;\n  const visitedNodeSet = new Set();\n  const foundComponents = [];\n  const dfsComponent = (currentNode, component) => {\n    if (visitedNodeSet.has(currentNode.id)) {\n      return;\n    }\n    visitedNodeSet.add(currentNode.id);\n    component.push(currentNode);\n    adjList[currentNode.id].forEach(neighborId => {\n      const neighborNode = nodes.find(node => node.id === neighborId);\n      if (!visitedNodeSet.has(neighborId)) {\n        dfsComponent(neighborNode, component);\n      }\n    });\n  };\n  nodes.forEach(node => {\n    if (!visitedNodeSet.has(node.id)) {\n      const component = [];\n      dfsComponent(node, component);\n      foundComponents.push(component);\n    }\n  });\n  setComponents(foundComponents);\n  const animateComponentMST = component => {\n    uf = new UnionFind(nodeCount);\n    currentComponentEdges = [];\n    currentComponentNodes = component.map(node => node.id);\n    let edgeIndex = 0;\n    const color = componentColors[componentIndex % componentColors.length];\n    const highlightNodesAndEdges = index => {\n      if (index < currentComponentEdges.length) {\n        const {\n          from,\n          to\n        } = currentComponentEdges[index];\n        setVisitedNodes(prev => [...prev, {\n          id: from.id,\n          color\n        }, {\n          id: to.id,\n          color\n        }]);\n        setVisitedEdges(prev => [...prev, currentComponentEdges[index]]);\n        setTimeout(() => highlightNodesAndEdges(index + 1), totalSliderCount - sliderValueRef.current);\n      } else {\n        componentIndex++;\n        if (componentIndex < foundComponents.length) {\n          setTimeout(() => animateComponentMST(foundComponents[componentIndex]), 0);\n        } else {\n          setTimeout(resetEdges, 1000);\n          setText(\"Kruskall's Algorithm Done!\");\n        }\n      }\n    };\n    const animateStep = () => {\n      if (currentComponentEdges.length === component.length - 1 || edgeIndex >= sortedEdges.length) {\n        highlightNodesAndEdges(0);\n        return;\n      }\n      const edge = sortedEdges[edgeIndex];\n      edgeIndex++;\n      if (currentComponentNodes.includes(edge.from.id) && currentComponentNodes.includes(edge.to.id) && uf.find(edge.from.id) !== uf.find(edge.to.id)) {\n        uf.union(edge.from.id, edge.to.id);\n        currentComponentEdges.push({\n          ...edge,\n          color\n        });\n      }\n      animateStep();\n    };\n    animateStep();\n  };\n  if (foundComponents.length > 0) {\n    animateComponentMST(foundComponents[0]);\n  } else {\n    console.log(\"No components found.\");\n    setAlgorithmRunning(false);\n  }\n};\n\n// Function to start shortest path algorithm\nexport const startShortestPath = () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setRunningAlgorithm(\"SP\");\n  setIsShortestPath(true);\n  setAlgorithmRunning(true);\n  setText(\"Select Start Node for Shortest Path\");\n};\n\n// Function to find the shortest path between two nodes\nexport const findShortestPath = async (startNode, targetNode) => {\n  setAlgorithmStarted(true);\n  setText(\"Shortest Path Algorithm in progress...\");\n  const dist = {};\n  const prev = {};\n  const visitedEdgeSet = new Set();\n  const visitedNodeSet = new Set();\n  const priorityQueue = new Set(nodes.map(node => node.id));\n  let stepIndex = 0;\n  nodes.forEach(node => {\n    dist[node.id] = Infinity;\n    prev[node.id] = null;\n  });\n  dist[startNode.id] = 0;\n  const getMinDistNode = () => {\n    let minNode = null;\n    priorityQueue.forEach(nodeId => {\n      if (minNode === null || dist[nodeId] < dist[minNode]) {\n        minNode = nodeId;\n      }\n    });\n    return minNode;\n  };\n  while (priorityQueue.size > 0) {\n    const currentNodeId = getMinDistNode();\n    const currentNode = nodes.find(node => node.id === currentNodeId);\n    if (dist[currentNodeId] === Infinity) break;\n    priorityQueue.delete(currentNodeId);\n    if (currentNodeId === targetNode.id) {\n      break;\n    }\n    for (let neighborId of adjList[currentNode.id]) {\n      const neighborNode = nodes.find(node => node.id === neighborId);\n      const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n      if (!edge) {\n        continue;\n      }\n      setCurrentNode(currentNode);\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n      if (!visitedEdgeSet.has(edge)) {\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n        visitedEdgeSet.add(edge);\n      }\n      const alt = dist[currentNode.id] + calculateEdgeLength(edge);\n      if (alt < dist[neighborId]) {\n        dist[neighborId] = alt;\n        prev[neighborId] = currentNode.id;\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: treeEdgeColor\n        }]);\n        visitedEdgeSet.add(edge);\n      } else {\n        setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color === currentEdgeColor)));\n      }\n    }\n    visitedNodeSet.add(currentNode.id);\n    setVisitedNodes(prev => {\n      const updatedNodes = [...prev, {\n        id: currentNode.id,\n        color: treeEdgeColor\n      }];\n      return updatedNodes;\n    });\n  }\n  setStartNode(null);\n  setEndNode(null);\n  setAlgorithmStarted(false);\n  setCurrentNode(null);\n  setText(\"Shortest Path Done!\");\n  const path = [];\n  let currentNodeId = targetNode.id;\n  while (currentNodeId !== null) {\n    path.unshift(currentNodeId);\n    currentNodeId = prev[currentNodeId];\n  }\n  if (path.length === 1) {\n    setText(\"No path Found!\");\n    setTimeout(resetEdges, 1000);\n    return;\n  }\n  setVisitedEdges(prev => {\n    return prev.map(e => {\n      if (path.includes(e.from.id) && path.includes(e.to.id)) {\n        return {\n          ...e,\n          color: treeEdgeColor\n        };\n      } else {\n        return {\n          ...e,\n          color: defaultEdgeColor\n        };\n      }\n    });\n  });\n  setVisitedNodes(prev => {\n    return nodes.map(node => {\n      if (path.includes(node.id)) {\n        return {\n          id: node.id,\n          color: treeEdgeColor\n        };\n      } else {\n        return {\n          id: node.id,\n          color: \"black\"\n        };\n      }\n    });\n  });\n  setTimeout(resetEdges, 1000);\n};\n\n// Function to start TSP\nexport const startTSP = async () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setRunningAlgorithm(\"TSP\");\n  setIsTSP(true);\n  setAlgorithmRunning(true);\n  setText(\"Select Node to begin TSP\");\n};\n\n// Function to animate TSP\nexport const tsp = async node => {\n  setAlgorithmStarted(true);\n  setText(\"TSP in progress...\");\n  const startNode = node;\n  const unvisited = new Set(nodes.map(node => node.id));\n  const visited = [];\n  const stack = [];\n  let currentNode = startNode;\n  let stepIndex = 0;\n  unvisited.delete(currentNode.id);\n  visited.push(currentNode);\n  setVisitedNodes([{\n    id: currentNode.id,\n    color: treeEdgeColor\n  }]);\n  while (unvisited.size > 0) {\n    let nearestNode = null;\n    let shortestDistance = Infinity;\n    let currentEdge = null;\n    for (let neighborId of unvisited) {\n      setCurrentNode(currentNode);\n      const neighborNode = nodes.find(node => node.id === neighborId);\n      // eslint-disable-next-line\n      const edge = edges.find(e => isDirected && e && e.from && e.to && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && e && e.from && e.to && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n      if (!edge) {\n        continue;\n      }\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n      stepIndex++;\n      if (isPausedRef.current) {\n        await new Promise(resolve => {\n          const checkStep = () => {\n            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n              resolve();\n            } else {\n              setTimeout(checkStep, 50);\n            }\n          };\n          checkStep();\n        });\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      } else {\n        await sleep(totalSliderCount - sliderValueRef.current);\n      }\n      if (isStepModeRef.current) {\n        setIsPaused(true);\n        isPausedRef.current = true;\n      }\n      const distance = calculateEdgeLength({\n        from: currentNode,\n        to: neighborNode\n      });\n      setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)));\n      if (distance < shortestDistance) {\n        shortestDistance = distance;\n        nearestNode = neighborNode;\n        currentEdge = edge;\n      }\n    }\n    if (nearestNode && currentEdge) {\n      stack.push({\n        currentNode,\n        nearestNode,\n        shortestDistance\n      });\n      setVisitedEdges(prev => [...prev, {\n        ...currentEdge,\n        color: treeEdgeColor\n      }]);\n      setVisitedNodes(prev => [...prev, {\n        id: nearestNode.id,\n        color: treeEdgeColor\n      }]);\n      stepIndex++;\n      if (isPausedRef.current) {\n        await new Promise(resolve => {\n          const checkStep = () => {\n            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n              resolve();\n            } else {\n              setTimeout(checkStep, 50);\n            }\n          };\n          checkStep();\n        });\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      } else {\n        await sleep(totalSliderCount - sliderValueRef.current);\n      }\n      if (isStepModeRef.current) {\n        setIsPaused(true);\n        isPausedRef.current = true;\n      }\n      currentNode = nearestNode;\n      unvisited.delete(currentNode.id);\n      visited.push(currentNode);\n    } else {\n      const previousState = stack.pop();\n      if (previousState) {\n        currentNode = previousState.currentNode;\n      } else {\n        break;\n      }\n    }\n  }\n  setCurrentNode(null);\n  setAlgorithmStarted(false);\n  setText(\"TSP Done!\");\n  setTimeout(resetEdges, 1000);\n};\n\n// Function to color graph\nexport const graphColoring = async () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setRunningAlgorithm(\"Color\");\n  setDisablePause(true);\n  setAlgorithmRunning(true);\n  setText(\"Graph Coloring in progress...\");\n  const availableColors = componentColors;\n  const colors = {};\n  const colorGraph = node => {\n    const neighborColors = adjList[node.id].map(neighborId => colors[neighborId]);\n    for (let color of availableColors) {\n      if (!neighborColors.includes(color)) {\n        colors[node.id] = color;\n        break;\n      }\n    }\n  };\n  for (let node of nodes) {\n    colorGraph(node);\n    setVisitedNodes(prev => [...prev, {\n      id: node.id,\n      color: colors[node.id]\n    }]);\n    await new Promise(resolve => setTimeout(resolve, totalSliderCount - sliderValueRef.current));\n  }\n  setText(\"Graph Coloring Done!\");\n  setTimeout(resetEdges, 1000);\n};\n\n// Function to find connected components in a graph\nexport const findConnectedComponents = async () => {\n  setRunningAlgorithm(\"Connected\");\n  setAlgorithmStarted(true);\n  setText(\"Connected Components in progress...\");\n  setAlgorithmRunning(true);\n  const visitedNodeSet = new Set();\n  const visitedEdgeSet = new Set();\n  let componentIndex = 0;\n  let stepIndex = 0;\n  const dfsRecursive = async (currentNode, componentColor) => {\n    if (visitedNodeSet.has(currentNode.id)) {\n      return;\n    }\n    visitedNodeSet.add(currentNode.id);\n    setVisitedNodes(prev => {\n      const updatedNodes = [...prev, {\n        id: currentNode.id,\n        color: componentColor\n      }];\n      return updatedNodes;\n    });\n    for (let neighborId of adjList[currentNode.id]) {\n      setCurrentNode(currentNode);\n      const neighborNode = nodes.find(node => node.id === neighborId);\n      const edge = edges.find(e => e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id);\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n      if (!visitedEdgeSet.has(edge)) {\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      }\n      if (!visitedNodeSet.has(neighborId)) {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: componentColor\n        }]);\n        visitedEdgeSet.add(edge);\n        await dfsRecursive(neighborNode, componentColor);\n      } else {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: componentColor\n        }]);\n      }\n    }\n  };\n  for (let node of nodes) {\n    if (!visitedNodeSet.has(node.id)) {\n      const componentColor = componentColors[componentIndex % componentColors.length];\n      componentIndex++;\n      await dfsRecursive(node, componentColor);\n    }\n  }\n  setCurrentNode(null);\n  setAlgorithmStarted(false);\n  setText(\"Connected Components Done!\");\n  setTimeout(resetEdges, 1000);\n};\n\n// Function to find strong components\nexport const findStrongComponents = async () => {\n  setRunningAlgorithm(\"Connected\");\n  setAlgorithmStarted(true);\n  setText(\"Strong Components in progress...\");\n  setAlgorithmRunning(true);\n  const stack = [];\n  const visitedNodeSet = new Set();\n  const visitedEdgeSet = new Set();\n  const reverseAdjList = {};\n  let stepIndex = 0;\n  const dfs1 = async node => {\n    if (visitedNodeSet.has(node.id)) {\n      return;\n    }\n    visitedNodeSet.add(node.id);\n    for (let neighborId of adjList[node.id]) {\n      if (!visitedNodeSet.has(neighborId)) {\n        const neighborNode = nodes.find(n => n.id === neighborId);\n        await dfs1(neighborNode);\n      }\n    }\n    stack.push(node);\n  };\n  const reverseGraph = () => {\n    nodes.forEach(node => {\n      reverseAdjList[node.id] = [];\n    });\n    edges.forEach(edge => {\n      reverseAdjList[edge.to.id].push(edge.from.id);\n    });\n  };\n  const dfs2 = async (node, componentColor) => {\n    if (visitedNodeSet.has(node.id)) {\n      return;\n    }\n    visitedNodeSet.add(node.id);\n    setVisitedNodes(prev => {\n      const updatedNodes = [...prev, {\n        id: node.id,\n        color: componentColor\n      }];\n      return updatedNodes;\n    });\n    for (let neighborId of reverseAdjList[node.id]) {\n      setCurrentNode(node);\n      const neighborNode = nodes.find(n => n.id === neighborId);\n      const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId);\n      if (!edge) {\n        continue;\n      }\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n      if (!visitedEdgeSet.has(edge)) {\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      }\n      if (!visitedNodeSet.has(neighborId)) {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: componentColor\n        }]);\n        visitedEdgeSet.add(edge);\n        await dfs2(neighborNode, componentColor);\n      } else {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: componentColor\n        }]);\n      }\n    }\n  };\n  reverseGraph();\n  for (let node of nodes) {\n    if (!visitedNodeSet.has(node.id)) {\n      await dfs1(node);\n    }\n  }\n  visitedNodeSet.clear();\n  visitedEdgeSet.clear();\n  let componentIndex = 0;\n  while (stack.length > 0) {\n    const node = stack.pop();\n    if (!visitedNodeSet.has(node.id)) {\n      const componentColor = componentColors[componentIndex % componentColors.length];\n      componentIndex++;\n      await dfs2(node, componentColor);\n    }\n  }\n  setCurrentNode(null);\n  setAlgorithmStarted(false);\n  setText(\"Strong Components Done!\");\n  setTimeout(resetEdges, 1000);\n};","map":{"version":3,"names":["sleep","startDFS","algorithmRunning","isRemovingEdge","setRunningAlgorithm","setIsDFS","setAlgorithmRunning","setText","dfs","startNode","setAlgorithmStarted","visitedNodeSet","Set","visitedEdgeSet","stepIndex","dfsRecursive","currentNode","has","id","add","setVisitedNodes","prev","updatedNodes","color","treeEdgeColor","neighborId","adjList","setCurrentNode","neighborNode","nodes","find","node","edge","edges","e","isDirected","from","to","setVisitedEdges","currentEdgeColor","isPausedRef","current","Promise","resolve","checkStep","currentStepRef","setTimeout","isStepModeRef","setIsPaused","totalSliderCount","sliderValueRef","filter","resetEdges","startBFS","setIsBFS","bfs","queue","length","shift","push","startPrim","setIsPrim","animatePrimsAlgorithm","setIsDirected","edgeQueue","addEdges","forEach","calculateEdgeLength","sort","a","b","animateStep","size","edgesToHighlight","slice","fromInMST","toInMST","defaultEdgeColor","animateKruskalsAlgorithm","setDisablePause","sortedEdges","componentIndex","currentComponentEdges","currentComponentNodes","uf","foundComponents","dfsComponent","component","setComponents","animateComponentMST","UnionFind","nodeCount","map","edgeIndex","componentColors","highlightNodesAndEdges","index","includes","union","console","log","startShortestPath","setIsShortestPath","findShortestPath","targetNode","dist","priorityQueue","Infinity","getMinDistNode","minNode","nodeId","currentNodeId","delete","alt","setStartNode","setEndNode","path","unshift","startTSP","setIsTSP","tsp","unvisited","visited","stack","nearestNode","shortestDistance","currentEdge","distance","previousState","pop","graphColoring","availableColors","colors","colorGraph","neighborColors","findConnectedComponents","componentColor","findStrongComponents","reverseAdjList","dfs1","n","reverseGraph","dfs2","clear"],"sources":["/Users/tani/Desktop/visualizer/Visusalizer Project/src/Components/Algorithms.js"],"sourcesContent":["import {sleep} from './GraphUtilities';\n\n// Function to start DFS\nexport const startDFS = () => {\n    if(algorithmRunning|| isRemovingEdge){\n        return;\n    }\n    setRunningAlgorithm(\"DFS\");\n    setIsDFS(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin DFS\");\n}\n\n// DFS implementatoin\nexport const dfs = async (startNode) => {\n    setAlgorithmStarted(true);\n    setText(\"DFS in progress...\");\n\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let stepIndex = 0;\n\n    const dfsRecursive = async (currentNode) => {\n        if (visitedNodeSet.has(currentNode.id)) {\n            return;\n        }\n\n        visitedNodeSet.add(currentNode.id);\n        setVisitedNodes(prev => { \n            const updatedNodes = [...prev, { id: currentNode.id, color: treeEdgeColor }];\n            return updatedNodes;\n        });\n\n        for (let neighborId of adjList[currentNode.id]) {\n            setCurrentNode(currentNode);     \n            const neighborNode = nodes.find(node => node.id === neighborId); \n            const edge = edges.find(e =>                                     \n                (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (e.from.id === neighborId && e.to.id === currentNode.id)))\n            );\n\n            if(!edge){\n                continue;\n            }\n\n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n           \n            if (!visitedEdgeSet.has(edge)) {\n                stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n            }\n\n            if (!visitedNodeSet.has(neighborId)) { \n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: treeEdgeColor }\n                ]);\n                visitedEdgeSet.add(edge);\n\n                await dfsRecursive(neighborNode);\n            } else {\n                setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n            }\n        }\n\n    };\n\n    await dfsRecursive(startNode);\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"DFS Done!\");\n    setTimeout(resetEdges, 1000); \n};\n\n// Function to start BFS\nexport const startBFS = () => {\n    if(algorithmRunning || isRemovingEdge){\n        return;\n    }\n    setRunningAlgorithm(\"BFS\");\n    setIsBFS(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin BFS\");\n}\n\n// BFS implementation\nexport const bfs = async (startNode) => {\n    setAlgorithmStarted(true);\n    setText(\"BFS in progress...\");\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let stepIndex = 0;\n\n\n    const queue = [startNode];\n    visitedNodeSet.add(startNode.id);\n    setVisitedNodes([{ id: startNode.id, color: treeEdgeColor }]);\n\n    while (queue.length > 0) {\n        const currentNode = queue.shift();\n        setCurrentNode(currentNode);\n        \n        for (let neighborId of adjList[currentNode.id]) {\n            const neighborNode = nodes.find(node => node.id === neighborId);\n            const edge = edges.find(e =>                                     \n                (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (e.from.id === neighborId && e.to.id === currentNode.id)))\n            );\n\n            if(!edge){\n                continue;\n            }\n\n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n            if(!visitedEdgeSet.has(edge)){\n                stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n            }\n\n            if (!visitedNodeSet.has(neighborId)) {\n                visitedNodeSet.add(neighborId);\n                queue.push(neighborNode);\n\n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: treeEdgeColor }\n                ]);\n                setVisitedNodes(prev => [...prev, { id: neighborId, color: treeEdgeColor }]);\n\n            } else{\n                setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n            }\n            \n        }\n    }\n\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"BFS Done!\");\n    setTimeout(resetEdges, 1000); \n};\n\n// Function to start Prim's algorithm\nexport const startPrim = () => {\n    if(algorithmRunning || isRemovingEdge){\n        return;\n    }\n    setRunningAlgorithm(\"Prim\");\n    setIsPrim(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin Prim's Algorithm\");\n}\n\n// Function to animate Prim's algorithm\nexport const animatePrimsAlgorithm = async (startNode) => {\n    setAlgorithmStarted(true);\n    setIsDirected(false);\n    setText(\"Prim's Algorithm in progress...\");\n    const visitedNodeSet = new Set();\n    const edgeQueue = [];\n    let stepIndex = 0;\n\n    const addEdges = (node) => {\n        visitedNodeSet.add(node.id);\n        setVisitedNodes(prev => [...prev, { id: node.id, color: treeEdgeColor }]);\n        (adjList[node.id] || []).forEach(neighborId => {\n            if (!visitedNodeSet.has(neighborId)) {\n                const edge = edges.find(e => \n                    (e.from.id === node.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === node.id)\n                );\n                if (edge) {\n                    edgeQueue.push({ ...edge, length: calculateEdgeLength(edge) });\n                }\n            }\n        });\n        edgeQueue.sort((a, b) => a.length - b.length); \n    };\n\n    const animateStep = async () => {\n        if (visitedNodeSet.size === nodes.length || edgeQueue.length === 0) {\n            setAlgorithmStarted(false);\n            setText(\"Prim's Algorithm Done!\");\n            setTimeout(resetEdges, 1000);\n            return;\n        }\n\n        const edgesToHighlight = edgeQueue.slice(0, 1); \n        edgesToHighlight.forEach(edge => {\n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n        });\n\n        stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n\n        const edge = edgeQueue.shift();\n        const { from, to } = edge;\n        const fromInMST = visitedNodeSet.has(from.id);\n        const toInMST = visitedNodeSet.has(to.id);\n\n        if ((fromInMST && !toInMST) || (!fromInMST && toInMST)) {\n            setVisitedEdges(prev => [\n                ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                { ...edge, color: treeEdgeColor }\n            ]);\n\n            if (fromInMST && !toInMST) {\n                addEdges(to);\n            } else if (!fromInMST && toInMST) {\n                addEdges(from);\n            }\n        } else {\n            setVisitedEdges(prev => [\n                ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                { ...edge, color: defaultEdgeColor }\n            ]);\n        }\n\n        animateStep();\n    };\n\n    addEdges(startNode);\n    animateStep();\n};\n\n// Function to animate Kruskall's algorithm\nexport const animateKruskalsAlgorithm = () => {\n    if (algorithmRunning || isRemovingEdge) {\n        return;\n    }\n    setIsDirected(false);\n    setRunningAlgorithm(\"Kruskall\");\n    setDisablePause(true);\n    setAlgorithmRunning(true);\n    setText(\"Kruskall's Algorithm in progress...\");\n\n    const sortedEdges = [...edges].sort((a, b) => calculateEdgeLength(a) - calculateEdgeLength(b));\n    let componentIndex = 0;\n    let currentComponentEdges = [];\n    let currentComponentNodes = [];\n    let uf;\n\n    const visitedNodeSet = new Set();\n    const foundComponents = [];\n\n    const dfsComponent = (currentNode, component) => {\n        if (visitedNodeSet.has(currentNode.id)) {\n            return;\n        }\n        visitedNodeSet.add(currentNode.id);\n        component.push(currentNode);\n        adjList[currentNode.id].forEach(neighborId => {\n            const neighborNode = nodes.find(node => node.id === neighborId);\n            if (!visitedNodeSet.has(neighborId)) {\n                dfsComponent(neighborNode, component);\n            }\n        });\n    };\n\n    nodes.forEach(node => {\n        if (!visitedNodeSet.has(node.id)) {\n            const component = [];\n            dfsComponent(node, component);\n            foundComponents.push(component);\n        }\n    });\n\n    setComponents(foundComponents);\n\n    const animateComponentMST = (component) => {\n        uf = new UnionFind(nodeCount); \n        currentComponentEdges = [];\n        currentComponentNodes = component.map(node => node.id);\n        let edgeIndex = 0;\n        const color = componentColors[componentIndex % componentColors.length];\n\n        const highlightNodesAndEdges = (index) => {\n            if (index < currentComponentEdges.length) {\n                const { from, to } = currentComponentEdges[index];\n                setVisitedNodes(prev => [...prev, { id: from.id, color }, { id: to.id, color }]);\n                setVisitedEdges(prev => [...prev, currentComponentEdges[index]]);\n                setTimeout(() => highlightNodesAndEdges(index + 1), totalSliderCount - sliderValueRef.current); \n            } else {\n                componentIndex++;\n                if (componentIndex < foundComponents.length) {\n                    setTimeout(() => animateComponentMST(foundComponents[componentIndex]), 0); \n                } else {\n                    setTimeout(resetEdges, 1000);\n                    setText(\"Kruskall's Algorithm Done!\");\n                }\n            }\n        };\n\n        const animateStep = () => {\n            if (currentComponentEdges.length === component.length - 1 || edgeIndex >= sortedEdges.length) {\n                highlightNodesAndEdges(0);\n                return;\n            }\n\n            const edge = sortedEdges[edgeIndex];\n            edgeIndex++;\n\n            if (currentComponentNodes.includes(edge.from.id) && currentComponentNodes.includes(edge.to.id) &&\n                uf.find(edge.from.id) !== uf.find(edge.to.id)) {\n                uf.union(edge.from.id, edge.to.id);\n                currentComponentEdges.push({ ...edge, color });\n            }\n\n            animateStep();\n        };\n\n        animateStep();\n    };\n\n    if (foundComponents.length > 0) {\n        animateComponentMST(foundComponents[0]);\n    } else {\n        console.log(\"No components found.\");\n        setAlgorithmRunning(false);\n    }\n};\n\n// Function to start shortest path algorithm\nexport const startShortestPath = () => {\n    if(algorithmRunning || isRemovingEdge){\n        return;\n    }\n    setRunningAlgorithm(\"SP\");\n\n    setIsShortestPath(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Start Node for Shortest Path\");\n}\n\n// Function to find the shortest path between two nodes\nexport const findShortestPath = async (startNode, targetNode) => {\n    setAlgorithmStarted(true);\n    setText(\"Shortest Path Algorithm in progress...\");\n    const dist = {};\n    const prev = {};\n    const visitedEdgeSet = new Set();\n    const visitedNodeSet = new Set();\n    const priorityQueue = new Set(nodes.map(node => node.id)); \n    let stepIndex = 0;\n\n    nodes.forEach(node => {\n        dist[node.id] = Infinity;\n        prev[node.id] = null;\n    });\n    dist[startNode.id] = 0;\n\n    const getMinDistNode = () => {\n        let minNode = null;\n        priorityQueue.forEach(nodeId => {\n            if (minNode === null || dist[nodeId] < dist[minNode]) {\n                minNode = nodeId;\n            }\n        });\n        return minNode;\n    };\n\n    while (priorityQueue.size > 0) {\n        const currentNodeId = getMinDistNode();\n        const currentNode = nodes.find(node => node.id === currentNodeId);\n\n        if (dist[currentNodeId] === Infinity) break;\n\n        priorityQueue.delete(currentNodeId);\n\n        if (currentNodeId === targetNode.id) {\n            break;\n        }\n\n        for (let neighborId of adjList[currentNode.id]) {\n            const neighborNode = nodes.find(node => node.id === neighborId);\n            const edge = edges.find(e => \n                (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (e.from.id === neighborId && e.to.id === currentNode.id)))\n            );\n\n            if(!edge){\n                continue;\n            }\n\n            setCurrentNode(currentNode);\n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n            if (!visitedEdgeSet.has(edge)) {\n                stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n                visitedEdgeSet.add(edge);\n            }\n\n            const alt = dist[currentNode.id] + calculateEdgeLength(edge);\n\n            if (alt < dist[neighborId]) {\n                dist[neighborId] = alt;\n                prev[neighborId] = currentNode.id;\n\n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: treeEdgeColor }\n                ]);\n\n                visitedEdgeSet.add(edge);\n            } else {\n                setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color === currentEdgeColor)));\n            }\n        }\n\n        visitedNodeSet.add(currentNode.id);\n        setVisitedNodes(prev => {\n            const updatedNodes = [...prev, { id: currentNode.id, color: treeEdgeColor }];\n            return updatedNodes;\n        });\n    }\n\n    setStartNode(null);\n    setEndNode(null);\n    setAlgorithmStarted(false);\n    setCurrentNode(null);\n    setText(\"Shortest Path Done!\");\n\n    const path = [];\n\n    let currentNodeId = targetNode.id;\n    while (currentNodeId !== null) {\n        path.unshift(currentNodeId);\n        currentNodeId = prev[currentNodeId];\n    }\n\n    if(path.length === 1){\n        setText(\"No path Found!\");\n        setTimeout(resetEdges, 1000);\n        return;\n    }\n\n    setVisitedEdges(prev => {\n        return prev.map(e => {\n            if (path.includes(e.from.id) && path.includes(e.to.id)) {\n                return { ...e, color: treeEdgeColor };\n            } else {\n                return { ...e, color: defaultEdgeColor };\n            }\n        });\n    });\n\n    setVisitedNodes(prev => {\n        return nodes.map(node => {\n            if (path.includes(node.id)) {\n                return { id: node.id, color: treeEdgeColor };\n            } else {\n                return { id: node.id, color: \"black\" };\n            }\n        });\n    });\n\n    setTimeout(resetEdges, 1000);\n};\n\n// Function to start TSP\nexport const startTSP = async () => {\n    if(algorithmRunning || isRemovingEdge){\n        return;\n    }\n    setRunningAlgorithm(\"TSP\");\n    setIsTSP(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin TSP\");\n}\n\n// Function to animate TSP\nexport const tsp = async (node) => {\n    setAlgorithmStarted(true);\n    setText(\"TSP in progress...\");\n    const startNode = node;\n    const unvisited = new Set(nodes.map(node => node.id));\n    const visited = [];\n    const stack = [];\n    let currentNode = startNode;\n    let stepIndex = 0;\n\n    unvisited.delete(currentNode.id);\n    visited.push(currentNode);\n    setVisitedNodes([{ id: currentNode.id, color: treeEdgeColor }]);\n\n    while (unvisited.size > 0) {\n        let nearestNode = null;\n        let shortestDistance = Infinity;\n        let currentEdge = null;\n\n        for (let neighborId of unvisited) {\n            setCurrentNode(currentNode);\n            const neighborNode = nodes.find(node => node.id === neighborId);\n            // eslint-disable-next-line\n            const edge = edges.find(e => \n                (isDirected && e && e.from && e.to && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (!isDirected && e && e.from && e.to && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (e.from.id === neighborId && e.to.id === currentNode.id)))\n            );\n\n            if (!edge) {\n                continue;\n            }\n            \n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n            stepIndex++;\n            if (isPausedRef.current) {\n                await new Promise(resolve => {\n                    const checkStep = () => {\n                        if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                            resolve();\n                        } else {\n                            setTimeout(checkStep, 50);\n                        }\n                    };\n                    checkStep();\n                });\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n            } else {\n                await sleep(totalSliderCount - sliderValueRef.current);\n            }\n\n            if(isStepModeRef.current){\n                setIsPaused(true);\n                isPausedRef.current = true;\n            }\n            const distance = calculateEdgeLength({ from: currentNode, to: neighborNode });\n            setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)));\n            if (distance < shortestDistance) {\n                shortestDistance = distance;\n                nearestNode = neighborNode;\n                currentEdge = edge;\n            }\n            \n        }\n\n        if (nearestNode && currentEdge) {\n            stack.push({ currentNode, nearestNode, shortestDistance });\n\n            setVisitedEdges(prev => [...prev, { ...currentEdge, color: treeEdgeColor }]);\n            setVisitedNodes(prev => [...prev, { id: nearestNode.id, color: treeEdgeColor }]);\n\n            stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n\n            currentNode = nearestNode;\n            unvisited.delete(currentNode.id);\n            visited.push(currentNode);\n        } else {\n            const previousState = stack.pop();\n            if (previousState) {\n                currentNode = previousState.currentNode;\n            } else {\n                break;\n            }\n        }\n    }\n\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"TSP Done!\");\n    setTimeout(resetEdges, 1000);\n};\n\n// Function to color graph\nexport const graphColoring = async () => {\n    if(algorithmRunning || isRemovingEdge){\n        return;\n    }\n    setRunningAlgorithm(\"Color\");\n    setDisablePause(true);\n    setAlgorithmRunning(true);\n    setText(\"Graph Coloring in progress...\");\n\n    const availableColors = componentColors;\n    const colors = {};\n\n    const colorGraph = (node) => {\n        const neighborColors = adjList[node.id].map(neighborId => colors[neighborId]);\n        for(let color of availableColors){\n            if(!neighborColors.includes(color)){\n                colors[node.id] = color;\n                break;\n            }\n        }\n    }\n\n    for(let node of nodes){\n        colorGraph(node);\n        setVisitedNodes(prev => [...prev, {id: node.id, color: colors[node.id]}]);\n        await new Promise(resolve => setTimeout(resolve, totalSliderCount - sliderValueRef.current));\n    }\n\n    setText(\"Graph Coloring Done!\");\n    setTimeout(resetEdges, 1000);\n}\n\n// Function to find connected components in a graph\nexport const findConnectedComponents = async () => {\n    setRunningAlgorithm(\"Connected\");\n    setAlgorithmStarted(true);\n    setText(\"Connected Components in progress...\");\n    setAlgorithmRunning(true);\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let componentIndex = 0;\n    let stepIndex = 0;\n\n    const dfsRecursive = async (currentNode, componentColor) => {\n        if (visitedNodeSet.has(currentNode.id)) {\n            return;\n        }\n\n        visitedNodeSet.add(currentNode.id);\n        setVisitedNodes(prev => { \n            const updatedNodes = [...prev, { id: currentNode.id, color: componentColor }];\n            return updatedNodes;\n        });\n\n        for (let neighborId of adjList[currentNode.id]) {\n            setCurrentNode(currentNode);     \n            const neighborNode = nodes.find(node => node.id === neighborId); \n            const edge = edges.find(e =>                                     \n                (e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (e.from.id === neighborId && e.to.id === currentNode.id)\n            );\n\n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n            if (!visitedEdgeSet.has(edge)) {\n                stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n            }\n\n            if (!visitedNodeSet.has(neighborId)) { \n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: componentColor }\n                ]);\n                visitedEdgeSet.add(edge);\n\n                await dfsRecursive(neighborNode, componentColor);\n            } else {\n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: componentColor }\n                ]);\n            }\n        }\n    };\n\n    for (let node of nodes) {\n        if (!visitedNodeSet.has(node.id)) {\n            const componentColor = componentColors[componentIndex % componentColors.length];\n            componentIndex++;\n            await dfsRecursive(node, componentColor);\n        }\n    }\n\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"Connected Components Done!\");\n    setTimeout(resetEdges, 1000); \n};\n\n// Function to find strong components\nexport const findStrongComponents = async () => {\n    setRunningAlgorithm(\"Connected\");\n    setAlgorithmStarted(true);\n    setText(\"Strong Components in progress...\");\n    setAlgorithmRunning(true);\n\n    const stack = [];\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    const reverseAdjList = {};\n    let stepIndex = 0;\n\n    const dfs1 = async (node) => {\n        if (visitedNodeSet.has(node.id)) {\n            return;\n        }\n\n        visitedNodeSet.add(node.id);\n        \n        for (let neighborId of adjList[node.id]) {\n            if (!visitedNodeSet.has(neighborId)) {\n                const neighborNode = nodes.find(n => n.id === neighborId);\n                await dfs1(neighborNode);\n            }\n        }\n        \n        stack.push(node);\n    };\n\n    const reverseGraph = () => {\n        nodes.forEach(node => {\n            reverseAdjList[node.id] = [];\n        });\n        edges.forEach(edge => {\n            reverseAdjList[edge.to.id].push(edge.from.id);\n        });\n    };\n\n    const dfs2 = async (node, componentColor) => {\n        if (visitedNodeSet.has(node.id)) {\n            return;\n        }\n        \n        visitedNodeSet.add(node.id);\n        setVisitedNodes(prev => { \n            const updatedNodes = [...prev, { id: node.id, color: componentColor }];\n            return updatedNodes;\n        });\n    \n        for (let neighborId of reverseAdjList[node.id]) {\n            setCurrentNode(node);\n            const neighborNode = nodes.find(n => n.id === neighborId);\n            const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId);\n            \n            if (!edge) {\n                continue;\n            }\n    \n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n    \n            if (!visitedEdgeSet.has(edge)) {\n                stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if (isStepModeRef.current) {\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n    \n                if (isStepModeRef.current) {\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n            }\n            \n            if (!visitedNodeSet.has(neighborId)) { \n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: componentColor }\n                ]);\n                visitedEdgeSet.add(edge);\n\n                await dfs2(neighborNode, componentColor);\n            } else {\n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: componentColor }\n                ]);\n            }\n        }\n    };\n\n    reverseGraph();\n\n    for (let node of nodes) {\n        if (!visitedNodeSet.has(node.id)) {\n            await dfs1(node);\n        }\n    }\n\n    visitedNodeSet.clear();\n    visitedEdgeSet.clear();\n\n    let componentIndex = 0;\n    while (stack.length > 0) {\n        const node = stack.pop();\n        if (!visitedNodeSet.has(node.id)) {\n            const componentColor = componentColors[componentIndex % componentColors.length];\n            componentIndex++;\n            await dfs2(node, componentColor);\n        }\n    }\n\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"Strong Components Done!\");\n    setTimeout(resetEdges, 1000);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}