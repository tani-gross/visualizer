{"ast":null,"code":"var _s = $RefreshSig$();\nimport { sleep, calculateEdgeLength } from './GraphUtilities';\nimport UnionFind from './UnionFind';\nimport { useGraphStates } from './Graphs';\nexport const useAlgorithms = () => {\n  _s();\n  const {\n    nodes,\n    edges,\n    adjList,\n    setVisitedNodes,\n    setVisitedEdges,\n    setAlgorithmStarted,\n    setText,\n    resetEdges,\n    setCurrentNode,\n    isPausedRef,\n    currentStepRef,\n    isStepModeRef,\n    sliderValueRef,\n    totalSliderCount,\n    componentColors,\n    setComponents,\n    algorithmRunning,\n    isRemovingEdge,\n    setRunningAlgorithm,\n    setIsDFS,\n    setAlgorithmRunning,\n    treeEdgeColor,\n    isDirected,\n    currentEdgeColor,\n    setIsPaused,\n    startNode,\n    setIsBFS,\n    setIsPrim,\n    setIsDirected\n  } = useGraphStates();\n\n  // Function to start DFS\n  const startDFS = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"DFS\");\n    setIsDFS(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin DFS\");\n  };\n\n  // DFS implementatoin\n  const dfs = async () => {\n    setAlgorithmStarted(true);\n    setText(\"DFS in progress...\");\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let stepIndex = 0;\n    const dfsRecursive = async currentNode => {\n      if (visitedNodeSet.has(currentNode.id)) {\n        return;\n      }\n      visitedNodeSet.add(currentNode.id);\n      setVisitedNodes(prev => {\n        const updatedNodes = [...prev, {\n          id: currentNode.id,\n          color: treeEdgeColor\n        }];\n        return updatedNodes;\n      });\n      for (let neighborId of adjList[currentNode.id]) {\n        setCurrentNode(currentNode);\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n        if (!edge) {\n          continue;\n        }\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        if (!visitedEdgeSet.has(edge)) {\n          stepIndex++;\n          if (isPausedRef.current) {\n            await new Promise(resolve => {\n              const checkStep = () => {\n                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                  resolve();\n                } else {\n                  setTimeout(checkStep, 50);\n                }\n              };\n              checkStep();\n            });\n            if (isStepModeRef.current) {\n              setIsPaused(true);\n              isPausedRef.current = true;\n            }\n          } else {\n            await sleep(totalSliderCount - sliderValueRef.current);\n          }\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        }\n        if (!visitedNodeSet.has(neighborId)) {\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: treeEdgeColor\n          }]);\n          visitedEdgeSet.add(edge);\n          await dfsRecursive(neighborNode);\n        } else {\n          setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n        }\n      }\n    };\n    await dfsRecursive(startNode);\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"DFS Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to start BFS\n  const startBFS = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"BFS\");\n    setIsBFS(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin BFS\");\n  };\n\n  // BFS implementation\n  const bfs = async startNode => {\n    setAlgorithmStarted(true);\n    setText(\"BFS in progress...\");\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let stepIndex = 0;\n    const queue = [startNode];\n    visitedNodeSet.add(startNode.id);\n    setVisitedNodes([{\n      id: startNode.id,\n      color: treeEdgeColor\n    }]);\n    while (queue.length > 0) {\n      const currentNode = queue.shift();\n      setCurrentNode(currentNode);\n      for (let neighborId of adjList[currentNode.id]) {\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n        if (!edge) {\n          continue;\n        }\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        if (!visitedEdgeSet.has(edge)) {\n          stepIndex++;\n          if (isPausedRef.current) {\n            await new Promise(resolve => {\n              const checkStep = () => {\n                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                  resolve();\n                } else {\n                  setTimeout(checkStep, 50);\n                }\n              };\n              checkStep();\n            });\n            if (isStepModeRef.current) {\n              setIsPaused(true);\n              isPausedRef.current = true;\n            }\n          } else {\n            await sleep(totalSliderCount - sliderValueRef.current);\n          }\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        }\n        if (!visitedNodeSet.has(neighborId)) {\n          visitedNodeSet.add(neighborId);\n          queue.push(neighborNode);\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: treeEdgeColor\n          }]);\n          setVisitedNodes(prev => [...prev, {\n            id: neighborId,\n            color: treeEdgeColor\n          }]);\n        } else {\n          setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n        }\n      }\n    }\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"BFS Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to start Prim's algorithm\n  const startPrim = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"Prim\");\n    setIsPrim(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin Prim's Algorithm\");\n  };\n\n  // Function to animate Prim's algorithm\n  const animatePrimsAlgorithm = async startNode => {\n    setAlgorithmStarted(true);\n    setIsDirected(false);\n    setText(\"Prim's Algorithm in progress...\");\n    const visitedNodeSet = new Set();\n    const edgeQueue = [];\n    let stepIndex = 0;\n    const addEdges = node => {\n      visitedNodeSet.add(node.id);\n      setVisitedNodes(prev => [...prev, {\n        id: node.id,\n        color: treeEdgeColor\n      }]);\n      (adjList[node.id] || []).forEach(neighborId => {\n        if (!visitedNodeSet.has(neighborId)) {\n          const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === node.id);\n          if (edge) {\n            edgeQueue.push({\n              ...edge,\n              length: calculateEdgeLength(edge)\n            });\n          }\n        }\n      });\n      edgeQueue.sort((a, b) => a.length - b.length);\n    };\n    const animateStep = async () => {\n      if (visitedNodeSet.size === nodes.length || edgeQueue.length === 0) {\n        setAlgorithmStarted(false);\n        setText(\"Prim's Algorithm Done!\");\n        setTimeout(resetEdges, 1000);\n        return;\n      }\n      const edgesToHighlight = edgeQueue.slice(0, 1);\n      edgesToHighlight.forEach(edge => {\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n      });\n      stepIndex++;\n      if (isPausedRef.current) {\n        await new Promise(resolve => {\n          const checkStep = () => {\n            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n              resolve();\n            } else {\n              setTimeout(checkStep, 50);\n            }\n          };\n          checkStep();\n        });\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      } else {\n        await sleep(totalSliderCount - sliderValueRef.current);\n      }\n      if (isStepModeRef.current) {\n        setIsPaused(true);\n        isPausedRef.current = true;\n      }\n      const edge = edgeQueue.shift();\n      const {\n        from,\n        to\n      } = edge;\n      const fromInMST = visitedNodeSet.has(from.id);\n      const toInMST = visitedNodeSet.has(to.id);\n      if (fromInMST && !toInMST || !fromInMST && toInMST) {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: treeEdgeColor\n        }]);\n        if (fromInMST && !toInMST) {\n          addEdges(to);\n        } else if (!fromInMST && toInMST) {\n          addEdges(from);\n        }\n      } else {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: defaultEdgeColor\n        }]);\n      }\n      animateStep();\n    };\n    addEdges(startNode);\n    animateStep();\n  };\n\n  // Function to animate Kruskall's algorithm\n  const animateKruskalsAlgorithm = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setIsDirected(false);\n    setRunningAlgorithm(\"Kruskall\");\n    setDisablePause(true);\n    setAlgorithmRunning(true);\n    setText(\"Kruskall's Algorithm in progress...\");\n    const sortedEdges = [...edges].sort((a, b) => calculateEdgeLength(a) - calculateEdgeLength(b));\n    let componentIndex = 0;\n    let currentComponentEdges = [];\n    let currentComponentNodes = [];\n    let uf;\n    const visitedNodeSet = new Set();\n    const foundComponents = [];\n    const dfsComponent = (currentNode, component) => {\n      if (visitedNodeSet.has(currentNode.id)) {\n        return;\n      }\n      visitedNodeSet.add(currentNode.id);\n      component.push(currentNode);\n      adjList[currentNode.id].forEach(neighborId => {\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        if (!visitedNodeSet.has(neighborId)) {\n          dfsComponent(neighborNode, component);\n        }\n      });\n    };\n    nodes.forEach(node => {\n      if (!visitedNodeSet.has(node.id)) {\n        const component = [];\n        dfsComponent(node, component);\n        foundComponents.push(component);\n      }\n    });\n    setComponents(foundComponents);\n    const animateComponentMST = component => {\n      uf = new UnionFind(nodeCount);\n      currentComponentEdges = [];\n      currentComponentNodes = component.map(node => node.id);\n      let edgeIndex = 0;\n      const color = componentColors[componentIndex % componentColors.length];\n      const highlightNodesAndEdges = index => {\n        if (index < currentComponentEdges.length) {\n          const {\n            from,\n            to\n          } = currentComponentEdges[index];\n          setVisitedNodes(prev => [...prev, {\n            id: from.id,\n            color\n          }, {\n            id: to.id,\n            color\n          }]);\n          setVisitedEdges(prev => [...prev, currentComponentEdges[index]]);\n          setTimeout(() => highlightNodesAndEdges(index + 1), totalSliderCount - sliderValueRef.current);\n        } else {\n          componentIndex++;\n          if (componentIndex < foundComponents.length) {\n            setTimeout(() => animateComponentMST(foundComponents[componentIndex]), 0);\n          } else {\n            setTimeout(resetEdges, 1000);\n            setText(\"Kruskall's Algorithm Done!\");\n          }\n        }\n      };\n      const animateStep = () => {\n        if (currentComponentEdges.length === component.length - 1 || edgeIndex >= sortedEdges.length) {\n          highlightNodesAndEdges(0);\n          return;\n        }\n        const edge = sortedEdges[edgeIndex];\n        edgeIndex++;\n        if (currentComponentNodes.includes(edge.from.id) && currentComponentNodes.includes(edge.to.id) && uf.find(edge.from.id) !== uf.find(edge.to.id)) {\n          uf.union(edge.from.id, edge.to.id);\n          currentComponentEdges.push({\n            ...edge,\n            color\n          });\n        }\n        animateStep();\n      };\n      animateStep();\n    };\n    if (foundComponents.length > 0) {\n      animateComponentMST(foundComponents[0]);\n    } else {\n      console.log(\"No components found.\");\n      setAlgorithmRunning(false);\n    }\n  };\n\n  // Function to start shortest path algorithm\n  const startShortestPath = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"SP\");\n    setIsShortestPath(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Start Node for Shortest Path\");\n  };\n\n  // Function to find the shortest path between two nodes\n  const findShortestPath = async (startNode, targetNode) => {\n    setAlgorithmStarted(true);\n    setText(\"Shortest Path Algorithm in progress...\");\n    const dist = {};\n    const prev = {};\n    const visitedEdgeSet = new Set();\n    const visitedNodeSet = new Set();\n    const priorityQueue = new Set(nodes.map(node => node.id));\n    let stepIndex = 0;\n    nodes.forEach(node => {\n      dist[node.id] = Infinity;\n      prev[node.id] = null;\n    });\n    dist[startNode.id] = 0;\n    const getMinDistNode = () => {\n      let minNode = null;\n      priorityQueue.forEach(nodeId => {\n        if (minNode === null || dist[nodeId] < dist[minNode]) {\n          minNode = nodeId;\n        }\n      });\n      return minNode;\n    };\n    while (priorityQueue.size > 0) {\n      const currentNodeId = getMinDistNode();\n      const currentNode = nodes.find(node => node.id === currentNodeId);\n      if (dist[currentNodeId] === Infinity) break;\n      priorityQueue.delete(currentNodeId);\n      if (currentNodeId === targetNode.id) {\n        break;\n      }\n      for (let neighborId of adjList[currentNode.id]) {\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n        if (!edge) {\n          continue;\n        }\n        setCurrentNode(currentNode);\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        if (!visitedEdgeSet.has(edge)) {\n          stepIndex++;\n          if (isPausedRef.current) {\n            await new Promise(resolve => {\n              const checkStep = () => {\n                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                  resolve();\n                } else {\n                  setTimeout(checkStep, 50);\n                }\n              };\n              checkStep();\n            });\n            if (isStepModeRef.current) {\n              setIsPaused(true);\n              isPausedRef.current = true;\n            }\n          } else {\n            await sleep(totalSliderCount - sliderValueRef.current);\n          }\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n          visitedEdgeSet.add(edge);\n        }\n        const alt = dist[currentNode.id] + calculateEdgeLength(edge);\n        if (alt < dist[neighborId]) {\n          dist[neighborId] = alt;\n          prev[neighborId] = currentNode.id;\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: treeEdgeColor\n          }]);\n          visitedEdgeSet.add(edge);\n        } else {\n          setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color === currentEdgeColor)));\n        }\n      }\n      visitedNodeSet.add(currentNode.id);\n      setVisitedNodes(prev => {\n        const updatedNodes = [...prev, {\n          id: currentNode.id,\n          color: treeEdgeColor\n        }];\n        return updatedNodes;\n      });\n    }\n    setStartNode(null);\n    setEndNode(null);\n    setAlgorithmStarted(false);\n    setCurrentNode(null);\n    setText(\"Shortest Path Done!\");\n    const path = [];\n    let currentNodeId = targetNode.id;\n    while (currentNodeId !== null) {\n      path.unshift(currentNodeId);\n      currentNodeId = prev[currentNodeId];\n    }\n    if (path.length === 1) {\n      setText(\"No path Found!\");\n      setTimeout(resetEdges, 1000);\n      return;\n    }\n    setVisitedEdges(prev => {\n      return prev.map(e => {\n        if (path.includes(e.from.id) && path.includes(e.to.id)) {\n          return {\n            ...e,\n            color: treeEdgeColor\n          };\n        } else {\n          return {\n            ...e,\n            color: defaultEdgeColor\n          };\n        }\n      });\n    });\n    setVisitedNodes(prev => {\n      return nodes.map(node => {\n        if (path.includes(node.id)) {\n          return {\n            id: node.id,\n            color: treeEdgeColor\n          };\n        } else {\n          return {\n            id: node.id,\n            color: \"black\"\n          };\n        }\n      });\n    });\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to start TSP\n  const startTSP = async () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"TSP\");\n    setIsTSP(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin TSP\");\n  };\n\n  // Function to animate TSP\n  const tsp = async node => {\n    setAlgorithmStarted(true);\n    setText(\"TSP in progress...\");\n    const startNode = node;\n    const unvisited = new Set(nodes.map(node => node.id));\n    const visited = [];\n    const stack = [];\n    let currentNode = startNode;\n    let stepIndex = 0;\n    unvisited.delete(currentNode.id);\n    visited.push(currentNode);\n    setVisitedNodes([{\n      id: currentNode.id,\n      color: treeEdgeColor\n    }]);\n    while (unvisited.size > 0) {\n      let nearestNode = null;\n      let shortestDistance = Infinity;\n      let currentEdge = null;\n      for (let neighborId of unvisited) {\n        setCurrentNode(currentNode);\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        // eslint-disable-next-line\n        const edge = edges.find(e => isDirected && e && e.from && e.to && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && e && e.from && e.to && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n        if (!edge) {\n          continue;\n        }\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n        const distance = calculateEdgeLength({\n          from: currentNode,\n          to: neighborNode\n        });\n        setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)));\n        if (distance < shortestDistance) {\n          shortestDistance = distance;\n          nearestNode = neighborNode;\n          currentEdge = edge;\n        }\n      }\n      if (nearestNode && currentEdge) {\n        stack.push({\n          currentNode,\n          nearestNode,\n          shortestDistance\n        });\n        setVisitedEdges(prev => [...prev, {\n          ...currentEdge,\n          color: treeEdgeColor\n        }]);\n        setVisitedNodes(prev => [...prev, {\n          id: nearestNode.id,\n          color: treeEdgeColor\n        }]);\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n        currentNode = nearestNode;\n        unvisited.delete(currentNode.id);\n        visited.push(currentNode);\n      } else {\n        const previousState = stack.pop();\n        if (previousState) {\n          currentNode = previousState.currentNode;\n        } else {\n          break;\n        }\n      }\n    }\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"TSP Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to color graph\n  const graphColoring = async () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"Color\");\n    setDisablePause(true);\n    setAlgorithmRunning(true);\n    setText(\"Graph Coloring in progress...\");\n    const availableColors = componentColors;\n    const colors = {};\n    const colorGraph = node => {\n      const neighborColors = adjList[node.id].map(neighborId => colors[neighborId]);\n      for (let color of availableColors) {\n        if (!neighborColors.includes(color)) {\n          colors[node.id] = color;\n          break;\n        }\n      }\n    };\n    for (let node of nodes) {\n      colorGraph(node);\n      setVisitedNodes(prev => [...prev, {\n        id: node.id,\n        color: colors[node.id]\n      }]);\n      await new Promise(resolve => setTimeout(resolve, totalSliderCount - sliderValueRef.current));\n    }\n    setText(\"Graph Coloring Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to find connected components in a graph\n  const findConnectedComponents = async () => {\n    setRunningAlgorithm(\"Connected\");\n    setAlgorithmStarted(true);\n    setText(\"Connected Components in progress...\");\n    setAlgorithmRunning(true);\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let componentIndex = 0;\n    let stepIndex = 0;\n    const dfsRecursive = async (currentNode, componentColor) => {\n      if (visitedNodeSet.has(currentNode.id)) {\n        return;\n      }\n      visitedNodeSet.add(currentNode.id);\n      setVisitedNodes(prev => {\n        const updatedNodes = [...prev, {\n          id: currentNode.id,\n          color: componentColor\n        }];\n        return updatedNodes;\n      });\n      for (let neighborId of adjList[currentNode.id]) {\n        setCurrentNode(currentNode);\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        const edge = edges.find(e => e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id);\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        if (!visitedEdgeSet.has(edge)) {\n          stepIndex++;\n          if (isPausedRef.current) {\n            await new Promise(resolve => {\n              const checkStep = () => {\n                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                  resolve();\n                } else {\n                  setTimeout(checkStep, 50);\n                }\n              };\n              checkStep();\n            });\n            if (isStepModeRef.current) {\n              setIsPaused(true);\n              isPausedRef.current = true;\n            }\n          } else {\n            await sleep(totalSliderCount - sliderValueRef.current);\n          }\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        }\n        if (!visitedNodeSet.has(neighborId)) {\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: componentColor\n          }]);\n          visitedEdgeSet.add(edge);\n          await dfsRecursive(neighborNode, componentColor);\n        } else {\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: componentColor\n          }]);\n        }\n      }\n    };\n    for (let node of nodes) {\n      if (!visitedNodeSet.has(node.id)) {\n        const componentColor = componentColors[componentIndex % componentColors.length];\n        componentIndex++;\n        await dfsRecursive(node, componentColor);\n      }\n    }\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"Connected Components Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to find strong components\n  const findStrongComponents = async () => {\n    setRunningAlgorithm(\"Connected\");\n    setAlgorithmStarted(true);\n    setText(\"Strong Components in progress...\");\n    setAlgorithmRunning(true);\n    const stack = [];\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    const reverseAdjList = {};\n    let stepIndex = 0;\n    const dfs1 = async node => {\n      if (visitedNodeSet.has(node.id)) {\n        return;\n      }\n      visitedNodeSet.add(node.id);\n      for (let neighborId of adjList[node.id]) {\n        if (!visitedNodeSet.has(neighborId)) {\n          const neighborNode = nodes.find(n => n.id === neighborId);\n          await dfs1(neighborNode);\n        }\n      }\n      stack.push(node);\n    };\n    const reverseGraph = () => {\n      nodes.forEach(node => {\n        reverseAdjList[node.id] = [];\n      });\n      edges.forEach(edge => {\n        reverseAdjList[edge.to.id].push(edge.from.id);\n      });\n    };\n    const dfs2 = async (node, componentColor) => {\n      if (visitedNodeSet.has(node.id)) {\n        return;\n      }\n      visitedNodeSet.add(node.id);\n      setVisitedNodes(prev => {\n        const updatedNodes = [...prev, {\n          id: node.id,\n          color: componentColor\n        }];\n        return updatedNodes;\n      });\n      for (let neighborId of reverseAdjList[node.id]) {\n        setCurrentNode(node);\n        const neighborNode = nodes.find(n => n.id === neighborId);\n        const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId);\n        if (!edge) {\n          continue;\n        }\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        if (!visitedEdgeSet.has(edge)) {\n          stepIndex++;\n          if (isPausedRef.current) {\n            await new Promise(resolve => {\n              const checkStep = () => {\n                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                  resolve();\n                } else {\n                  setTimeout(checkStep, 50);\n                }\n              };\n              checkStep();\n            });\n            if (isStepModeRef.current) {\n              setIsPaused(true);\n              isPausedRef.current = true;\n            }\n          } else {\n            await sleep(totalSliderCount - sliderValueRef.current);\n          }\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        }\n        if (!visitedNodeSet.has(neighborId)) {\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: componentColor\n          }]);\n          visitedEdgeSet.add(edge);\n          await dfs2(neighborNode, componentColor);\n        } else {\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: componentColor\n          }]);\n        }\n      }\n    };\n    reverseGraph();\n    for (let node of nodes) {\n      if (!visitedNodeSet.has(node.id)) {\n        await dfs1(node);\n      }\n    }\n    visitedNodeSet.clear();\n    visitedEdgeSet.clear();\n    let componentIndex = 0;\n    while (stack.length > 0) {\n      const node = stack.pop();\n      if (!visitedNodeSet.has(node.id)) {\n        const componentColor = componentColors[componentIndex % componentColors.length];\n        componentIndex++;\n        await dfs2(node, componentColor);\n      }\n    }\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"Strong Components Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n  return {\n    startDFS,\n    dfs,\n    startBFS,\n    bfs,\n    startPrim,\n    animatePrimsAlgorithm,\n    animateKruskalsAlgorithm,\n    startShortestPath,\n    findShortestPath,\n    startTSP,\n    tsp,\n    graphColoring,\n    findConnectedComponents,\n    findStrongComponents\n  };\n};\n_s(useAlgorithms, \"LdXDCEb3OC5KAoHLOE0P8CZyPNw=\", false, function () {\n  return [useGraphStates];\n});","map":{"version":3,"names":["sleep","calculateEdgeLength","UnionFind","useGraphStates","useAlgorithms","_s","nodes","edges","adjList","setVisitedNodes","setVisitedEdges","setAlgorithmStarted","setText","resetEdges","setCurrentNode","isPausedRef","currentStepRef","isStepModeRef","sliderValueRef","totalSliderCount","componentColors","setComponents","algorithmRunning","isRemovingEdge","setRunningAlgorithm","setIsDFS","setAlgorithmRunning","treeEdgeColor","isDirected","currentEdgeColor","setIsPaused","startNode","setIsBFS","setIsPrim","setIsDirected","startDFS","dfs","visitedNodeSet","Set","visitedEdgeSet","stepIndex","dfsRecursive","currentNode","has","id","add","prev","updatedNodes","color","neighborId","neighborNode","find","node","edge","e","from","to","current","Promise","resolve","checkStep","setTimeout","filter","startBFS","bfs","queue","length","shift","push","startPrim","animatePrimsAlgorithm","edgeQueue","addEdges","forEach","sort","a","b","animateStep","size","edgesToHighlight","slice","fromInMST","toInMST","defaultEdgeColor","animateKruskalsAlgorithm","setDisablePause","sortedEdges","componentIndex","currentComponentEdges","currentComponentNodes","uf","foundComponents","dfsComponent","component","animateComponentMST","nodeCount","map","edgeIndex","highlightNodesAndEdges","index","includes","union","console","log","startShortestPath","setIsShortestPath","findShortestPath","targetNode","dist","priorityQueue","Infinity","getMinDistNode","minNode","nodeId","currentNodeId","delete","alt","setStartNode","setEndNode","path","unshift","startTSP","setIsTSP","tsp","unvisited","visited","stack","nearestNode","shortestDistance","currentEdge","distance","previousState","pop","graphColoring","availableColors","colors","colorGraph","neighborColors","findConnectedComponents","componentColor","findStrongComponents","reverseAdjList","dfs1","n","reverseGraph","dfs2","clear"],"sources":["/Users/tani/Desktop/visualizer/Visusalizer Project/src/Components/Algorithms.js"],"sourcesContent":["import {sleep, calculateEdgeLength} from './GraphUtilities';\nimport UnionFind from './UnionFind';\nimport { useGraphStates } from './Graphs';\n\nexport const useAlgorithms = () => {\n    const {\n        nodes, edges, adjList, setVisitedNodes, setVisitedEdges, setAlgorithmStarted, setText, resetEdges,\n        setCurrentNode, isPausedRef, currentStepRef, isStepModeRef, sliderValueRef, totalSliderCount, \n        componentColors, setComponents, algorithmRunning, isRemovingEdge, setRunningAlgorithm, setIsDFS, setAlgorithmRunning,\n        treeEdgeColor, isDirected, currentEdgeColor, setIsPaused, startNode, setIsBFS, setIsPrim, setIsDirected\n    } = useGraphStates();\n\n    // Function to start DFS\n    const startDFS = () => {\n        \n        if(algorithmRunning|| isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"DFS\");\n        setIsDFS(true);\n        setAlgorithmRunning(true);\n        setText(\"Select Node to begin DFS\");\n    }\n\n    // DFS implementatoin\n    const dfs = async () => {\n        setAlgorithmStarted(true);\n        setText(\"DFS in progress...\");\n\n        const visitedNodeSet = new Set();\n        const visitedEdgeSet = new Set();\n        let stepIndex = 0;\n\n        const dfsRecursive = async (currentNode) => {\n            if (visitedNodeSet.has(currentNode.id)) {\n                return;\n            }\n\n            visitedNodeSet.add(currentNode.id);\n            setVisitedNodes(prev => { \n                const updatedNodes = [...prev, { id: currentNode.id, color: treeEdgeColor }];\n                return updatedNodes;\n            });\n\n            for (let neighborId of adjList[currentNode.id]) {\n                setCurrentNode(currentNode);     \n                const neighborNode = nodes.find(node => node.id === neighborId); \n                const edge = edges.find(e =>                                     \n                    (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === currentNode.id)))\n                );\n\n                if(!edge){\n                    continue;\n                }\n\n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n            \n                if (!visitedEdgeSet.has(edge)) {\n                    stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                }\n\n                if (!visitedNodeSet.has(neighborId)) { \n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: treeEdgeColor }\n                    ]);\n                    visitedEdgeSet.add(edge);\n\n                    await dfsRecursive(neighborNode);\n                } else {\n                    setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n                }\n            }\n\n        };\n\n        await dfsRecursive(startNode);\n        setCurrentNode(null);\n        setAlgorithmStarted(false);\n        setText(\"DFS Done!\");\n        setTimeout(resetEdges, 1000); \n    };\n\n    // Function to start BFS\n    const startBFS = () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"BFS\");\n        setIsBFS(true);\n        setAlgorithmRunning(true);\n        setText(\"Select Node to begin BFS\");\n    }\n\n    // BFS implementation\n    const bfs = async (startNode) => {\n        setAlgorithmStarted(true);\n        setText(\"BFS in progress...\");\n        const visitedNodeSet = new Set();\n        const visitedEdgeSet = new Set();\n        let stepIndex = 0;\n\n\n        const queue = [startNode];\n        visitedNodeSet.add(startNode.id);\n        setVisitedNodes([{ id: startNode.id, color: treeEdgeColor }]);\n\n        while (queue.length > 0) {\n            const currentNode = queue.shift();\n            setCurrentNode(currentNode);\n            \n            for (let neighborId of adjList[currentNode.id]) {\n                const neighborNode = nodes.find(node => node.id === neighborId);\n                const edge = edges.find(e =>                                     \n                    (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === currentNode.id)))\n                );\n\n                if(!edge){\n                    continue;\n                }\n\n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n                if(!visitedEdgeSet.has(edge)){\n                    stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                }\n\n                if (!visitedNodeSet.has(neighborId)) {\n                    visitedNodeSet.add(neighborId);\n                    queue.push(neighborNode);\n\n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: treeEdgeColor }\n                    ]);\n                    setVisitedNodes(prev => [...prev, { id: neighborId, color: treeEdgeColor }]);\n\n                } else{\n                    setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n                }\n                \n            }\n        }\n\n        setCurrentNode(null);\n        setAlgorithmStarted(false);\n        setText(\"BFS Done!\");\n        setTimeout(resetEdges, 1000); \n    };\n\n    // Function to start Prim's algorithm\n    const startPrim = () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"Prim\");\n        setIsPrim(true);\n        setAlgorithmRunning(true);\n        setText(\"Select Node to begin Prim's Algorithm\");\n    }\n\n    // Function to animate Prim's algorithm\n    const animatePrimsAlgorithm = async (startNode) => {\n        setAlgorithmStarted(true);\n        setIsDirected(false);\n        setText(\"Prim's Algorithm in progress...\");\n        const visitedNodeSet = new Set();\n        const edgeQueue = [];\n        let stepIndex = 0;\n\n        const addEdges = (node) => {\n            visitedNodeSet.add(node.id);\n            setVisitedNodes(prev => [...prev, { id: node.id, color: treeEdgeColor }]);\n            (adjList[node.id] || []).forEach(neighborId => {\n                if (!visitedNodeSet.has(neighborId)) {\n                    const edge = edges.find(e => \n                        (e.from.id === node.id && e.to.id === neighborId) ||\n                        (e.from.id === neighborId && e.to.id === node.id)\n                    );\n                    if (edge) {\n                        edgeQueue.push({ ...edge, length: calculateEdgeLength(edge) });\n                    }\n                }\n            });\n            edgeQueue.sort((a, b) => a.length - b.length); \n        };\n\n        const animateStep = async () => {\n            if (visitedNodeSet.size === nodes.length || edgeQueue.length === 0) {\n                setAlgorithmStarted(false);\n                setText(\"Prim's Algorithm Done!\");\n                setTimeout(resetEdges, 1000);\n                return;\n            }\n\n            const edgesToHighlight = edgeQueue.slice(0, 1); \n            edgesToHighlight.forEach(edge => {\n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n            });\n\n            stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n\n            const edge = edgeQueue.shift();\n            const { from, to } = edge;\n            const fromInMST = visitedNodeSet.has(from.id);\n            const toInMST = visitedNodeSet.has(to.id);\n\n            if ((fromInMST && !toInMST) || (!fromInMST && toInMST)) {\n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: treeEdgeColor }\n                ]);\n\n                if (fromInMST && !toInMST) {\n                    addEdges(to);\n                } else if (!fromInMST && toInMST) {\n                    addEdges(from);\n                }\n            } else {\n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: defaultEdgeColor }\n                ]);\n            }\n\n            animateStep();\n        };\n\n        addEdges(startNode);\n        animateStep();\n    };\n\n    // Function to animate Kruskall's algorithm\n    const animateKruskalsAlgorithm = () => {\n        if (algorithmRunning || isRemovingEdge) {\n            return;\n        }\n        setIsDirected(false);\n        setRunningAlgorithm(\"Kruskall\");\n        setDisablePause(true);\n        setAlgorithmRunning(true);\n        setText(\"Kruskall's Algorithm in progress...\");\n\n        const sortedEdges = [...edges].sort((a, b) => calculateEdgeLength(a) - calculateEdgeLength(b));\n        let componentIndex = 0;\n        let currentComponentEdges = [];\n        let currentComponentNodes = [];\n        let uf;\n\n        const visitedNodeSet = new Set();\n        const foundComponents = [];\n\n        const dfsComponent = (currentNode, component) => {\n            if (visitedNodeSet.has(currentNode.id)) {\n                return;\n            }\n            visitedNodeSet.add(currentNode.id);\n            component.push(currentNode);\n            adjList[currentNode.id].forEach(neighborId => {\n                const neighborNode = nodes.find(node => node.id === neighborId);\n                if (!visitedNodeSet.has(neighborId)) {\n                    dfsComponent(neighborNode, component);\n                }\n            });\n        };\n\n        nodes.forEach(node => {\n            if (!visitedNodeSet.has(node.id)) {\n                const component = [];\n                dfsComponent(node, component);\n                foundComponents.push(component);\n            }\n        });\n\n        setComponents(foundComponents);\n\n        const animateComponentMST = (component) => {\n            uf = new UnionFind(nodeCount); \n            currentComponentEdges = [];\n            currentComponentNodes = component.map(node => node.id);\n            let edgeIndex = 0;\n            const color = componentColors[componentIndex % componentColors.length];\n\n            const highlightNodesAndEdges = (index) => {\n                if (index < currentComponentEdges.length) {\n                    const { from, to } = currentComponentEdges[index];\n                    setVisitedNodes(prev => [...prev, { id: from.id, color }, { id: to.id, color }]);\n                    setVisitedEdges(prev => [...prev, currentComponentEdges[index]]);\n                    setTimeout(() => highlightNodesAndEdges(index + 1), totalSliderCount - sliderValueRef.current); \n                } else {\n                    componentIndex++;\n                    if (componentIndex < foundComponents.length) {\n                        setTimeout(() => animateComponentMST(foundComponents[componentIndex]), 0); \n                    } else {\n                        setTimeout(resetEdges, 1000);\n                        setText(\"Kruskall's Algorithm Done!\");\n                    }\n                }\n            };\n\n            const animateStep = () => {\n                if (currentComponentEdges.length === component.length - 1 || edgeIndex >= sortedEdges.length) {\n                    highlightNodesAndEdges(0);\n                    return;\n                }\n\n                const edge = sortedEdges[edgeIndex];\n                edgeIndex++;\n\n                if (currentComponentNodes.includes(edge.from.id) && currentComponentNodes.includes(edge.to.id) &&\n                    uf.find(edge.from.id) !== uf.find(edge.to.id)) {\n                    uf.union(edge.from.id, edge.to.id);\n                    currentComponentEdges.push({ ...edge, color });\n                }\n\n                animateStep();\n            };\n\n            animateStep();\n        };\n\n        if (foundComponents.length > 0) {\n            animateComponentMST(foundComponents[0]);\n        } else {\n            console.log(\"No components found.\");\n            setAlgorithmRunning(false);\n        }\n    };\n\n    // Function to start shortest path algorithm\n    const startShortestPath = () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"SP\");\n\n        setIsShortestPath(true);\n        setAlgorithmRunning(true);\n        setText(\"Select Start Node for Shortest Path\");\n    }\n\n    // Function to find the shortest path between two nodes\n    const findShortestPath = async (startNode, targetNode) => {\n        setAlgorithmStarted(true);\n        setText(\"Shortest Path Algorithm in progress...\");\n        const dist = {};\n        const prev = {};\n        const visitedEdgeSet = new Set();\n        const visitedNodeSet = new Set();\n        const priorityQueue = new Set(nodes.map(node => node.id)); \n        let stepIndex = 0;\n\n        nodes.forEach(node => {\n            dist[node.id] = Infinity;\n            prev[node.id] = null;\n        });\n        dist[startNode.id] = 0;\n\n        const getMinDistNode = () => {\n            let minNode = null;\n            priorityQueue.forEach(nodeId => {\n                if (minNode === null || dist[nodeId] < dist[minNode]) {\n                    minNode = nodeId;\n                }\n            });\n            return minNode;\n        };\n\n        while (priorityQueue.size > 0) {\n            const currentNodeId = getMinDistNode();\n            const currentNode = nodes.find(node => node.id === currentNodeId);\n\n            if (dist[currentNodeId] === Infinity) break;\n\n            priorityQueue.delete(currentNodeId);\n\n            if (currentNodeId === targetNode.id) {\n                break;\n            }\n\n            for (let neighborId of adjList[currentNode.id]) {\n                const neighborNode = nodes.find(node => node.id === neighborId);\n                const edge = edges.find(e => \n                    (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === currentNode.id)))\n                );\n\n                if(!edge){\n                    continue;\n                }\n\n                setCurrentNode(currentNode);\n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n                if (!visitedEdgeSet.has(edge)) {\n                    stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                    visitedEdgeSet.add(edge);\n                }\n\n                const alt = dist[currentNode.id] + calculateEdgeLength(edge);\n\n                if (alt < dist[neighborId]) {\n                    dist[neighborId] = alt;\n                    prev[neighborId] = currentNode.id;\n\n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: treeEdgeColor }\n                    ]);\n\n                    visitedEdgeSet.add(edge);\n                } else {\n                    setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color === currentEdgeColor)));\n                }\n            }\n\n            visitedNodeSet.add(currentNode.id);\n            setVisitedNodes(prev => {\n                const updatedNodes = [...prev, { id: currentNode.id, color: treeEdgeColor }];\n                return updatedNodes;\n            });\n        }\n\n        setStartNode(null);\n        setEndNode(null);\n        setAlgorithmStarted(false);\n        setCurrentNode(null);\n        setText(\"Shortest Path Done!\");\n\n        const path = [];\n\n        let currentNodeId = targetNode.id;\n        while (currentNodeId !== null) {\n            path.unshift(currentNodeId);\n            currentNodeId = prev[currentNodeId];\n        }\n\n        if(path.length === 1){\n            setText(\"No path Found!\");\n            setTimeout(resetEdges, 1000);\n            return;\n        }\n\n        setVisitedEdges(prev => {\n            return prev.map(e => {\n                if (path.includes(e.from.id) && path.includes(e.to.id)) {\n                    return { ...e, color: treeEdgeColor };\n                } else {\n                    return { ...e, color: defaultEdgeColor };\n                }\n            });\n        });\n\n        setVisitedNodes(prev => {\n            return nodes.map(node => {\n                if (path.includes(node.id)) {\n                    return { id: node.id, color: treeEdgeColor };\n                } else {\n                    return { id: node.id, color: \"black\" };\n                }\n            });\n        });\n\n        setTimeout(resetEdges, 1000);\n    };\n\n    // Function to start TSP\n    const startTSP = async () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"TSP\");\n        setIsTSP(true);\n        setAlgorithmRunning(true);\n        setText(\"Select Node to begin TSP\");\n    }\n\n    // Function to animate TSP\n    const tsp = async (node) => {\n        setAlgorithmStarted(true);\n        setText(\"TSP in progress...\");\n        const startNode = node;\n        const unvisited = new Set(nodes.map(node => node.id));\n        const visited = [];\n        const stack = [];\n        let currentNode = startNode;\n        let stepIndex = 0;\n\n        unvisited.delete(currentNode.id);\n        visited.push(currentNode);\n        setVisitedNodes([{ id: currentNode.id, color: treeEdgeColor }]);\n\n        while (unvisited.size > 0) {\n            let nearestNode = null;\n            let shortestDistance = Infinity;\n            let currentEdge = null;\n\n            for (let neighborId of unvisited) {\n                setCurrentNode(currentNode);\n                const neighborNode = nodes.find(node => node.id === neighborId);\n                // eslint-disable-next-line\n                const edge = edges.find(e => \n                    (isDirected && e && e.from && e.to && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (!isDirected && e && e.from && e.to && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === currentNode.id)))\n                );\n\n                if (!edge) {\n                    continue;\n                }\n                \n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n                stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n                const distance = calculateEdgeLength({ from: currentNode, to: neighborNode });\n                setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)));\n                if (distance < shortestDistance) {\n                    shortestDistance = distance;\n                    nearestNode = neighborNode;\n                    currentEdge = edge;\n                }\n                \n            }\n\n            if (nearestNode && currentEdge) {\n                stack.push({ currentNode, nearestNode, shortestDistance });\n\n                setVisitedEdges(prev => [...prev, { ...currentEdge, color: treeEdgeColor }]);\n                setVisitedNodes(prev => [...prev, { id: nearestNode.id, color: treeEdgeColor }]);\n\n                stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n\n                currentNode = nearestNode;\n                unvisited.delete(currentNode.id);\n                visited.push(currentNode);\n            } else {\n                const previousState = stack.pop();\n                if (previousState) {\n                    currentNode = previousState.currentNode;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        setCurrentNode(null);\n        setAlgorithmStarted(false);\n        setText(\"TSP Done!\");\n        setTimeout(resetEdges, 1000);\n    };\n\n    // Function to color graph\n    const graphColoring = async () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"Color\");\n        setDisablePause(true);\n        setAlgorithmRunning(true);\n        setText(\"Graph Coloring in progress...\");\n\n        const availableColors = componentColors;\n        const colors = {};\n\n        const colorGraph = (node) => {\n            const neighborColors = adjList[node.id].map(neighborId => colors[neighborId]);\n            for(let color of availableColors){\n                if(!neighborColors.includes(color)){\n                    colors[node.id] = color;\n                    break;\n                }\n            }\n        }\n\n        for(let node of nodes){\n            colorGraph(node);\n            setVisitedNodes(prev => [...prev, {id: node.id, color: colors[node.id]}]);\n            await new Promise(resolve => setTimeout(resolve, totalSliderCount - sliderValueRef.current));\n        }\n\n        setText(\"Graph Coloring Done!\");\n        setTimeout(resetEdges, 1000);\n    }\n\n    // Function to find connected components in a graph\n    const findConnectedComponents = async () => {\n        setRunningAlgorithm(\"Connected\");\n        setAlgorithmStarted(true);\n        setText(\"Connected Components in progress...\");\n        setAlgorithmRunning(true);\n        const visitedNodeSet = new Set();\n        const visitedEdgeSet = new Set();\n        let componentIndex = 0;\n        let stepIndex = 0;\n\n        const dfsRecursive = async (currentNode, componentColor) => {\n            if (visitedNodeSet.has(currentNode.id)) {\n                return;\n            }\n\n            visitedNodeSet.add(currentNode.id);\n            setVisitedNodes(prev => { \n                const updatedNodes = [...prev, { id: currentNode.id, color: componentColor }];\n                return updatedNodes;\n            });\n\n            for (let neighborId of adjList[currentNode.id]) {\n                setCurrentNode(currentNode);     \n                const neighborNode = nodes.find(node => node.id === neighborId); \n                const edge = edges.find(e =>                                     \n                    (e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === currentNode.id)\n                );\n\n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n                if (!visitedEdgeSet.has(edge)) {\n                    stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                }\n\n                if (!visitedNodeSet.has(neighborId)) { \n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: componentColor }\n                    ]);\n                    visitedEdgeSet.add(edge);\n\n                    await dfsRecursive(neighborNode, componentColor);\n                } else {\n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: componentColor }\n                    ]);\n                }\n            }\n        };\n\n        for (let node of nodes) {\n            if (!visitedNodeSet.has(node.id)) {\n                const componentColor = componentColors[componentIndex % componentColors.length];\n                componentIndex++;\n                await dfsRecursive(node, componentColor);\n            }\n        }\n\n        setCurrentNode(null);\n        setAlgorithmStarted(false);\n        setText(\"Connected Components Done!\");\n        setTimeout(resetEdges, 1000); \n    };\n\n    // Function to find strong components\n    const findStrongComponents = async () => {\n        setRunningAlgorithm(\"Connected\");\n        setAlgorithmStarted(true);\n        setText(\"Strong Components in progress...\");\n        setAlgorithmRunning(true);\n\n        const stack = [];\n        const visitedNodeSet = new Set();\n        const visitedEdgeSet = new Set();\n        const reverseAdjList = {};\n        let stepIndex = 0;\n\n        const dfs1 = async (node) => {\n            if (visitedNodeSet.has(node.id)) {\n                return;\n            }\n\n            visitedNodeSet.add(node.id);\n            \n            for (let neighborId of adjList[node.id]) {\n                if (!visitedNodeSet.has(neighborId)) {\n                    const neighborNode = nodes.find(n => n.id === neighborId);\n                    await dfs1(neighborNode);\n                }\n            }\n            \n            stack.push(node);\n        };\n\n        const reverseGraph = () => {\n            nodes.forEach(node => {\n                reverseAdjList[node.id] = [];\n            });\n            edges.forEach(edge => {\n                reverseAdjList[edge.to.id].push(edge.from.id);\n            });\n        };\n\n        const dfs2 = async (node, componentColor) => {\n            if (visitedNodeSet.has(node.id)) {\n                return;\n            }\n            \n            visitedNodeSet.add(node.id);\n            setVisitedNodes(prev => { \n                const updatedNodes = [...prev, { id: node.id, color: componentColor }];\n                return updatedNodes;\n            });\n        \n            for (let neighborId of reverseAdjList[node.id]) {\n                setCurrentNode(node);\n                const neighborNode = nodes.find(n => n.id === neighborId);\n                const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId);\n                \n                if (!edge) {\n                    continue;\n                }\n        \n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n        \n                if (!visitedEdgeSet.has(edge)) {\n                    stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if (isStepModeRef.current) {\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n        \n                    if (isStepModeRef.current) {\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                }\n                \n                if (!visitedNodeSet.has(neighborId)) { \n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: componentColor }\n                    ]);\n                    visitedEdgeSet.add(edge);\n\n                    await dfs2(neighborNode, componentColor);\n                } else {\n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: componentColor }\n                    ]);\n                }\n            }\n        };\n\n        reverseGraph();\n\n        for (let node of nodes) {\n            if (!visitedNodeSet.has(node.id)) {\n                await dfs1(node);\n            }\n        }\n\n        visitedNodeSet.clear();\n        visitedEdgeSet.clear();\n\n        let componentIndex = 0;\n        while (stack.length > 0) {\n            const node = stack.pop();\n            if (!visitedNodeSet.has(node.id)) {\n                const componentColor = componentColors[componentIndex % componentColors.length];\n                componentIndex++;\n                await dfs2(node, componentColor);\n            }\n        }\n\n        setCurrentNode(null);\n        setAlgorithmStarted(false);\n        setText(\"Strong Components Done!\");\n        setTimeout(resetEdges, 1000);\n    };\n\n    return {startDFS, dfs, startBFS, bfs, startPrim, animatePrimsAlgorithm, animateKruskalsAlgorithm, startShortestPath, findShortestPath, startTSP, tsp, graphColoring, findConnectedComponents, findStrongComponents};\n\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}