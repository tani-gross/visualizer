{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useAlgorithms } from './Algorithms';\nimport { useGraphStates } from './GraphsContext';\nexport const useNodeFunctions = () => {\n  _s();\n  const {\n    nodes,\n    edges,\n    nodeCount,\n    setClickedTraversal,\n    setClickedMST,\n    setText,\n    setNodes,\n    setNodeCount,\n    setVisitedNodes,\n    setVisitedEdges,\n    defaultEdgeColor,\n    setIsRemovingEdge,\n    setSelectedNode,\n    dragging,\n    setEdges,\n    algorithmRunning,\n    isRemovingEdge,\n    setAdjList,\n    isAddingEdge,\n    setIsAddingEdge,\n    selectedNode,\n    isDirected,\n    startNode,\n    setIsDFS,\n    setIsBFS,\n    setIsPrim,\n    endNode,\n    setEndNode,\n    tsp,\n    setIsTSP,\n    setStartNode,\n    findShortestPath,\n    setIsShortestPath,\n    setDragging,\n    isTSP,\n    isBFS,\n    isDFS,\n    isPrim,\n    isShortestPath,\n    setSliderValue,\n    sliderValueRef\n  } = useGraphStates();\n  const {\n    dfs,\n    bfs,\n    animatePrimsAlgorithm\n  } = useAlgorithms();\n  const startingText = \"Move Node, Select Node, or Press Button to Continue\";\n\n  // Function to add a new node to the graph\n  const addNode = () => {\n    if (algorithmRunning) {\n      return;\n    }\n    if (nodes.length >= 20) {\n      alert(\"too many nodes\");\n      return;\n    }\n    setText(startingText);\n    const newNode = {\n      id: nodeCount,\n      x: Math.random() * 480,\n      y: Math.random() * 480\n    };\n    setNodes([...nodes, newNode]);\n    setAdjList(prevAdjList => ({\n      ...prevAdjList,\n      [newNode.id]: []\n    }));\n    setNodeCount(nodeCount + 1);\n  };\n\n  // Function to generate a random graph\n  const generateGraph = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    var numNodes = 0;\n    var numEdges = -1;\n    do {\n      const response = prompt(\"Enter the number of nodes for the graph:\", \"\");\n      if (response === null) {\n        return;\n      }\n      if (isNaN(response)) {\n        alert(\"Invalid input. Please enter numbers only\");\n        continue;\n      }\n      if (response <= 0 || response > 20) {\n        alert(\"Invalid input. Number of nodes must be between 1 and 20\");\n        continue;\n      }\n      numNodes = response;\n    } while (numNodes === 0);\n    do {\n      const response = prompt(\"Enter the number of edges for the graph:\", \"\");\n      if (response === null) {\n        return;\n      }\n      if (isNaN(response)) {\n        alert(\"Invalid input. Please enter numbers only\");\n        continue;\n      }\n      if (!isDirected) {\n        if (response > numNodes * (numNodes - 1) / 2) {\n          alert(\"Invalid input. Too many edges for the undirected graph\");\n          continue;\n        }\n      } else {\n        if (response > numNodes * (numNodes - 1)) {\n          alert(\"Invalid input. Too many edges for the directed graph\");\n          continue;\n        }\n      }\n      if (response < 0) {\n        alert(\"Invalid input. Not enough edges\");\n        continue;\n      }\n      numEdges = response;\n    } while (numEdges === -1);\n    setNodes([]);\n    setEdges([]);\n    setAdjList({});\n    setNodeCount(0);\n    setVisitedNodes([]);\n    setVisitedEdges([]);\n    setSelectedNode(null);\n    setText(startingText);\n    const newNodes = [];\n    const newEdges = [];\n    const newAdjList = {};\n    const gridSize = Math.ceil(Math.sqrt(numNodes));\n    const areaWidth = 500;\n    const areaHeight = 500;\n    const margin = 10;\n    const gridSpacingX = (areaWidth - 2 * margin) / gridSize;\n    const gridSpacingY = (areaHeight - 2 * margin) / gridSize;\n    for (let i = 0; i < numNodes; i++) {\n      const row = Math.floor(i / gridSize);\n      const col = i % gridSize;\n      const x = margin + col * gridSpacingX + Math.random() * gridSpacingX * 0.9;\n      const y = margin + row * gridSpacingY + Math.random() * gridSpacingY * 0.9;\n      const newNode = {\n        id: i,\n        x: x,\n        y: y\n      };\n      newNodes.push(newNode);\n      newAdjList[i] = [];\n    }\n    while (newEdges.length < numEdges) {\n      const from = newNodes[Math.floor(Math.random() * numNodes)];\n      const to = newNodes[Math.floor(Math.random() * numNodes)];\n      if (from.id !== to.id) {\n        const edgeExists = newEdges.some(edge => edge.from.id === from.id && edge.to.id === to.id || !isDirected && edge.from.id === to.id && edge.to.id === from.id);\n        if (!edgeExists) {\n          const newEdge = {\n            from,\n            to,\n            color: defaultEdgeColor\n          };\n          newEdges.push(newEdge);\n          newAdjList[from.id].push(to.id);\n          if (!isDirected) {\n            newAdjList[to.id].push(from.id);\n          }\n        }\n      }\n    }\n    setNodes(newNodes);\n    setEdges(newEdges);\n    setAdjList(newAdjList);\n    setNodeCount(newNodes.length);\n  };\n\n  // Function to reset the graph\n  const resetGraph = () => {\n    if (algorithmRunning) {\n      return;\n    }\n    setNodes([]);\n    setEdges([]);\n    setClickedMST(false);\n    setClickedTraversal(false);\n    setIsRemovingEdge(false);\n    setText(startingText);\n  };\n\n  // Function to remove a selected node form the graph\n  const removeNode = () => {\n    if (selectedNode == null) return;\n    setNodes(nodes.filter(node => node.id !== selectedNode.id));\n    setEdges(edges.filter(edge => edge.from.id !== selectedNode.id && edge.to.id !== selectedNode.id));\n    setAdjList(prevAdjList => {\n      const newAdjList = {\n        ...prevAdjList\n      };\n      delete newAdjList[selectedNode.id];\n      for (const key in newAdjList) {\n        newAdjList[key] = newAdjList[key].filter(id => id !== selectedNode.id);\n      }\n      return newAdjList;\n    });\n    setSelectedNode(null);\n  };\n\n  // Function to handle clicking on a node\n  const handleNodeClick = node => {\n    if (dragging) {\n      return;\n    }\n    if (isAddingEdge) {\n      if (selectedNode && selectedNode.id !== node.id) {\n        const edgeExists = edges.some(edge => edge.from.id === selectedNode.id && edge.to.id === node.id || !isDirected && edge.from.id === node.id && edge.to.id === selectedNode.id);\n        if (!edgeExists) {\n          const newEdge = {\n            from: selectedNode,\n            to: node,\n            color: defaultEdgeColor\n          };\n          setEdges(prevEdges => [...prevEdges, newEdge]);\n          setAdjList(prevAdjList => {\n            const newAdjList = {\n              ...prevAdjList\n            };\n            if (!newAdjList[selectedNode.id]) newAdjList[selectedNode.id] = [];\n            if (!newAdjList[node.id]) newAdjList[node.id] = [];\n            newAdjList[selectedNode.id].push(node.id);\n            if (!isDirected) {\n              newAdjList[node.id].push(selectedNode.id);\n            }\n            return newAdjList;\n          });\n        }\n        setIsAddingEdge(false);\n        setSelectedNode(null);\n      } else if (selectedNode && selectedNode.id === node.id) {\n        setSelectedNode(null);\n        setIsAddingEdge(false);\n      }\n      setText(startingText);\n    } else if (isDFS) {\n      setVisitedNodes([]);\n      setVisitedEdges([]);\n      dfs(node);\n      setIsDFS(false);\n    } else if (isBFS) {\n      setVisitedNodes([]);\n      setVisitedEdges([]);\n      bfs(node);\n      setIsBFS(false);\n    } else if (isPrim) {\n      setIsPrim(false);\n      animatePrimsAlgorithm(node);\n    } else if (isShortestPath) {\n      if (!startNode) {\n        setStartNode(node);\n        setText(\"Select End Node for Shortest Path\");\n      } else if (!endNode) {\n        setEndNode(node);\n        setText(\"Finding Shortest Path...\");\n        findShortestPath(startNode, node);\n        setIsShortestPath(false);\n      }\n    } else if (isTSP) {\n      setVisitedNodes([]);\n      setVisitedEdges([]);\n      tsp(node);\n      setIsTSP(false);\n    } else {\n      if (selectedNode && selectedNode.id === node.id) {\n        setSelectedNode(null);\n        setText(startingText);\n      } else {\n        if (!algorithmRunning) {\n          setSelectedNode(node);\n        }\n      }\n    }\n  };\n\n  // Function to handle mouse down event for dragging\n  const handleMouseDown = () => {\n    setDragging(false);\n  };\n\n  // Function to handle slider change\n  const handleSliderChange = event => {\n    const newValue = event.target.value;\n    setSliderValue(newValue);\n    sliderValueRef.current = newValue;\n  };\n\n  // Function to start removing an edge\n  const startRemovingEdge = () => {\n    if (algorithmRunning) {\n      return;\n    }\n    if (isRemovingEdge) {\n      setIsRemovingEdge(false);\n      setText(\"\");\n      return;\n    }\n    if (edges.length < 1) {\n      alert(\"must be at least one edge\");\n      return;\n    }\n    setText(\"Click on an edge to remove it\");\n    setIsRemovingEdge(true);\n  };\n\n  // Function to initiate adding an edge\n  const handleAddEdge = () => {\n    if (selectedNode === null) return;\n    if (!isDirected) {\n      if (nodes.length * (nodes.length - 1) / 2 === edges.length) {\n        alert(\"cannot add another edge\");\n        return;\n      }\n    } else {\n      if (nodes.length * (nodes.length - 1) === edges.length) {\n        alert(\"cannot add another edge\");\n        return;\n      }\n    }\n    if (nodes.length < 2) {\n      alert(\"You need at least two nodes to add an edge.\");\n      return;\n    }\n    setIsAddingEdge(true);\n    setText(\"Click another node to add edge\");\n  };\n\n  // Function to handle clicking on an edge\n  const handleEdgeClick = edge => {\n    if (isRemovingEdge) {\n      setEdges(edges.filter(e => e !== edge));\n      setIsRemovingEdge(false);\n      setAdjList(prevAdjList => {\n        const newAdjList = {\n          ...prevAdjList\n        };\n        newAdjList[edge.from.id] = newAdjList[edge.from.id].filter(id => id !== edge.to.id);\n        newAdjList[edge.to.id] = newAdjList[edge.to.id].filter(id => id !== edge.from.id);\n        return newAdjList;\n      });\n      setText(startingText);\n    }\n  };\n\n  // Function to handle dragging a node\n  const handleDrag = (e, data, node) => {\n    setDragging(true);\n    node.x = data.x;\n    node.y = data.y;\n    setNodes([...nodes]);\n  };\n\n  // Function to handle stopping the drag of a node\n  const handleDragStop = () => {\n    setTimeout(() => {\n      setDragging(false);\n    }, 0);\n  };\n  return {\n    addNode,\n    generateGraph,\n    resetGraph,\n    removeNode,\n    handleNodeClick,\n    handleMouseDown,\n    handleSliderChange,\n    startRemovingEdge,\n    handleAddEdge,\n    handleEdgeClick,\n    handleDrag,\n    handleDragStop\n  };\n};\n_s(useNodeFunctions, \"hXwr6hd4FrSOp21KYcarR/P4Lw4=\", false, function () {\n  return [useGraphStates, useAlgorithms];\n});","map":{"version":3,"names":["useAlgorithms","useGraphStates","useNodeFunctions","_s","nodes","edges","nodeCount","setClickedTraversal","setClickedMST","setText","setNodes","setNodeCount","setVisitedNodes","setVisitedEdges","defaultEdgeColor","setIsRemovingEdge","setSelectedNode","dragging","setEdges","algorithmRunning","isRemovingEdge","setAdjList","isAddingEdge","setIsAddingEdge","selectedNode","isDirected","startNode","setIsDFS","setIsBFS","setIsPrim","endNode","setEndNode","tsp","setIsTSP","setStartNode","findShortestPath","setIsShortestPath","setDragging","isTSP","isBFS","isDFS","isPrim","isShortestPath","setSliderValue","sliderValueRef","dfs","bfs","animatePrimsAlgorithm","startingText","addNode","length","alert","newNode","id","x","Math","random","y","prevAdjList","generateGraph","numNodes","numEdges","response","prompt","isNaN","newNodes","newEdges","newAdjList","gridSize","ceil","sqrt","areaWidth","areaHeight","margin","gridSpacingX","gridSpacingY","i","row","floor","col","push","from","to","edgeExists","some","edge","newEdge","color","resetGraph","removeNode","filter","node","key","handleNodeClick","prevEdges","handleMouseDown","handleSliderChange","event","newValue","target","value","current","startRemovingEdge","handleAddEdge","handleEdgeClick","e","handleDrag","data","handleDragStop","setTimeout"],"sources":["/Users/tani/Desktop/visualizer/Visusalizer Project/src/Components/NodeFunctions.js"],"sourcesContent":["import { useAlgorithms } from './Algorithms';\nimport { useGraphStates } from './GraphsContext';\n\nexport const useNodeFunctions = () => {\n\n    const {\n        nodes, edges, nodeCount, setClickedTraversal, setClickedMST, setText, setNodes,\n        setNodeCount, setVisitedNodes, setVisitedEdges, defaultEdgeColor, setIsRemovingEdge, setSelectedNode, \n        dragging, setEdges, algorithmRunning, isRemovingEdge, setAdjList, isAddingEdge, setIsAddingEdge,\n        selectedNode, isDirected, startNode, setIsDFS, setIsBFS, setIsPrim,\n        endNode, setEndNode, tsp, setIsTSP,\n        setStartNode, findShortestPath, setIsShortestPath, setDragging,\n        isTSP, isBFS, isDFS, isPrim, isShortestPath, setSliderValue, sliderValueRef\n    } = useGraphStates();\n\n    const {dfs, bfs, animatePrimsAlgorithm} = useAlgorithms();\n\n    const startingText = \"Move Node, Select Node, or Press Button to Continue\";\n\n    // Function to add a new node to the graph\n    const addNode = () => {\n        if(algorithmRunning){\n            return;\n        }\n\n        if(nodes.length >= 20){\n            alert(\"too many nodes\");\n            return;\n        }\n\n        setText(startingText);\n        const newNode = {\n            id: nodeCount,\n            x: Math.random() * 480,\n            y: Math.random() * 480,\n        };\n        setNodes([...nodes, newNode]);\n        setAdjList(prevAdjList => ({ ...prevAdjList, [newNode.id]: [] }));\n        setNodeCount(nodeCount + 1);\n    };\n\n    // Function to generate a random graph\n    const generateGraph = () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n\n        var numNodes = 0;\n        var numEdges = -1;\n\n        do{\n            const response = prompt(\"Enter the number of nodes for the graph:\", \"\");\n            if(response === null){\n                return;\n            }\n            if(isNaN(response)){\n                alert(\"Invalid input. Please enter numbers only\");\n                continue;\n            }\n\n            if(response <= 0 || response > 20){\n                alert(\"Invalid input. Number of nodes must be between 1 and 20\");\n                continue;\n            }\n\n            numNodes = response;\n\n        }while(numNodes === 0);\n\n        do{\n            const response = prompt(\"Enter the number of edges for the graph:\", \"\");\n            if(response === null){\n                return;\n            }\n\n            if(isNaN(response)){\n                alert(\"Invalid input. Please enter numbers only\");\n                continue;\n            }\n\n            if(!isDirected){\n                if(response > ((numNodes * (numNodes - 1)) / 2)){\n                    alert(\"Invalid input. Too many edges for the undirected graph\");\n                    continue;\n                }\n            }else{\n                if(response > ((numNodes * (numNodes - 1)))){\n                    alert(\"Invalid input. Too many edges for the directed graph\");\n                    continue;\n                }\n            }\n            \n            if(response < 0){\n                alert(\"Invalid input. Not enough edges\");\n                continue;\n            }\n\n            numEdges = response;\n\n        }while(numEdges === -1);\n\n        setNodes([]);\n        setEdges([]);\n        setAdjList({});\n        setNodeCount(0);\n        setVisitedNodes([]);\n        setVisitedEdges([]);\n        setSelectedNode(null);\n        setText(startingText);\n\n        const newNodes = [];\n        const newEdges = [];\n        const newAdjList = {};\n\n\n        const gridSize = Math.ceil(Math.sqrt(numNodes));\n        const areaWidth = 500; \n        const areaHeight = 500; \n        const margin = 10;\n        const gridSpacingX = (areaWidth - 2 * margin) / gridSize;\n        const gridSpacingY = (areaHeight - 2 * margin) / gridSize;\n\n        for (let i = 0; i < numNodes; i++) {\n            const row = Math.floor(i / gridSize);\n            const col = i % gridSize;\n            const x = margin + col * gridSpacingX + Math.random() * gridSpacingX * 0.9;\n            const y = margin + row * gridSpacingY + Math.random() * gridSpacingY * 0.9;\n\n            const newNode = {\n                id: i,\n                x: x,\n                y: y,\n            };\n            newNodes.push(newNode);\n            newAdjList[i] = [];\n        }\n\n        while (newEdges.length < numEdges) {\n            const from = newNodes[Math.floor(Math.random() * numNodes)];\n            const to = newNodes[Math.floor(Math.random() * numNodes)];\n            if (from.id !== to.id) {\n                const edgeExists = newEdges.some(edge => \n                    (edge.from.id === from.id && edge.to.id === to.id) ||\n                    (!isDirected && edge.from.id === to.id && edge.to.id === from.id)\n                );\n                if (!edgeExists) {\n                    const newEdge = { from, to, color: defaultEdgeColor };\n                    newEdges.push(newEdge);\n                    newAdjList[from.id].push(to.id);\n                    if(!isDirected){\n                        newAdjList[to.id].push(from.id);\n                    }\n                }\n            }\n        }\n\n        setNodes(newNodes);\n        setEdges(newEdges);\n        setAdjList(newAdjList);\n        setNodeCount(newNodes.length);\n    };\n\n    // Function to reset the graph\n    const resetGraph = () => {\n        if(algorithmRunning){\n            return;\n        }\n        setNodes([]);\n        setEdges([]);\n        setClickedMST(false);\n        setClickedTraversal(false);\n        setIsRemovingEdge(false);\n        setText(startingText);\n    };\n\n    // Function to remove a selected node form the graph\n    const removeNode = () => {\n        if (selectedNode == null) return;\n\n        setNodes(nodes.filter(node => node.id !== selectedNode.id));\n        setEdges(edges.filter(edge => edge.from.id !== selectedNode.id && edge.to.id !== selectedNode.id));\n        setAdjList(prevAdjList => {\n            const newAdjList = { ...prevAdjList };\n            delete newAdjList[selectedNode.id];\n            for (const key in newAdjList) {\n                newAdjList[key] = newAdjList[key].filter(id => id !== selectedNode.id);\n            }\n            return newAdjList;\n        });\n        setSelectedNode(null);\n    };\n\n    // Function to handle clicking on a node\n    const handleNodeClick = (node) => {\n        if (dragging) {\n            return;\n        }\n\n        if (isAddingEdge) {\n            if (selectedNode && selectedNode.id !== node.id) {\n                const edgeExists = edges.some(edge =>\n                    (edge.from.id === selectedNode.id && edge.to.id === node.id) ||\n                    (!isDirected && edge.from.id === node.id && edge.to.id === selectedNode.id)\n                );\n\n                if(!edgeExists){\n                    const newEdge = { from: selectedNode, to: node, color: defaultEdgeColor };\n                    setEdges(prevEdges => [...prevEdges, newEdge]);\n\n                    setAdjList(prevAdjList => {\n                        const newAdjList = { ...prevAdjList };\n                        if (!newAdjList[selectedNode.id]) newAdjList[selectedNode.id] = [];\n                        if (!newAdjList[node.id]) newAdjList[node.id] = [];\n                        newAdjList[selectedNode.id].push(node.id);\n                        if (!isDirected) {\n                            newAdjList[node.id].push(selectedNode.id);\n                        }\n                        return newAdjList;\n                    })\n                }\n                \n                setIsAddingEdge(false);\n                setSelectedNode(null);\n            } else if (selectedNode && selectedNode.id === node.id) {\n                setSelectedNode(null);\n                setIsAddingEdge(false);\n            }\n            setText(startingText);\n        } else if(isDFS){\n            setVisitedNodes([]);\n            setVisitedEdges([]);\n            dfs(node);\n            setIsDFS(false);\n        } else if(isBFS){\n            setVisitedNodes([]);\n            setVisitedEdges([]);\n            bfs(node);\n            setIsBFS(false);\n        }else if(isPrim){\n            setIsPrim(false);\n            animatePrimsAlgorithm(node);\n        }else if(isShortestPath){\n            if(!startNode){\n                setStartNode(node);\n                setText(\"Select End Node for Shortest Path\");\n            }else if(!endNode){\n                setEndNode(node);\n                setText(\"Finding Shortest Path...\");\n                findShortestPath(startNode, node);\n                setIsShortestPath(false);\n            }\n        }else if(isTSP){\n            setVisitedNodes([]);\n            setVisitedEdges([]);\n            tsp(node);\n            setIsTSP(false);\n        }else{\n            if (selectedNode && selectedNode.id === node.id) {\n                setSelectedNode(null); \n                setText(startingText);\n            } else {\n                if(!algorithmRunning){\n                    setSelectedNode(node);\n                }\n                \n            }\n        }\n    }\n\n    // Function to handle mouse down event for dragging\n    const handleMouseDown = () => {\n        setDragging(false);\n    };\n\n    // Function to handle slider change\n    const handleSliderChange = (event) => {\n        const newValue = event.target.value;\n        setSliderValue(newValue);\n        sliderValueRef.current = newValue;\n    }\n\n    // Function to start removing an edge\n    const startRemovingEdge = () => {\n        if(algorithmRunning){\n            return;\n        }\n\n        if(isRemovingEdge){\n            setIsRemovingEdge(false);\n            setText(\"\");\n            return;\n        }\n\n        if(edges.length < 1){\n            alert(\"must be at least one edge\");\n            return;\n        }\n        setText(\"Click on an edge to remove it\");\n        setIsRemovingEdge(true);\n    }\n\n    // Function to initiate adding an edge\n    const handleAddEdge = () => {\n        if (selectedNode === null) return;\n\n        if(!isDirected){\n            if(((nodes.length * (nodes.length - 1)) / 2) === edges.length){\n                alert(\"cannot add another edge\");\n                return;\n            }\n        }else{\n            if(((nodes.length * (nodes.length - 1))) === edges.length){\n                alert(\"cannot add another edge\");\n                return;\n            }\n        }\n        \n\n        if (nodes.length < 2) {\n            alert(\"You need at least two nodes to add an edge.\");\n            return;\n        }\n        setIsAddingEdge(true);\n        setText(\"Click another node to add edge\");\n    };\n\n    // Function to handle clicking on an edge\n    const handleEdgeClick = (edge) => {\n        if (isRemovingEdge) {\n            setEdges(edges.filter(e => e !== edge));\n            setIsRemovingEdge(false);\n\n            setAdjList(prevAdjList => {\n                const newAdjList = { ...prevAdjList };\n                newAdjList[edge.from.id] = newAdjList[edge.from.id].filter(id => id !== edge.to.id);\n                newAdjList[edge.to.id] = newAdjList[edge.to.id].filter(id => id !== edge.from.id);\n                return newAdjList;\n            });\n            setText(startingText);\n        }\n    }\n\n    // Function to handle dragging a node\n    const handleDrag = (e, data, node) => {\n        setDragging(true);\n        node.x = data.x;\n        node.y = data.y;\n        setNodes([...nodes]);\n    };\n\n    // Function to handle stopping the drag of a node\n    const handleDragStop = () => {\n        setTimeout(() => {\n            setDragging(false);\n        }, 0);\n    };\n\n    return {addNode, generateGraph, resetGraph, removeNode, handleNodeClick, handleMouseDown, handleSliderChange, startRemovingEdge, handleAddEdge, handleEdgeClick, handleDrag, handleDragStop};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}