{"ast":null,"code":"var _s = $RefreshSig$();\nimport { calculateEdgeLength } from './GraphUtilities';\nimport UnionFind from './UnionFind';\nimport { useGraphStates } from './GraphsContext';\nimport { useNodeFunctions } from './NodeFunctions';\nexport const useAlgorithms = () => {\n  _s();\n  const {\n    nodes,\n    edges,\n    adjList,\n    setVisitedNodes,\n    setVisitedEdges,\n    setAlgorithmStarted,\n    setText,\n    resetEdges,\n    setCurrentNode,\n    isPausedRef,\n    currentStepRef,\n    isStepModeRef,\n    sliderValueRef,\n    totalSliderCount,\n    componentColors,\n    setComponents,\n    algorithmRunning,\n    isRemovingEdge,\n    setRunningAlgorithm,\n    setIsDFS,\n    setAlgorithmRunning,\n    treeEdgeColor,\n    isDirected,\n    currentEdgeColor,\n    setIsPaused,\n    setIsBFS,\n    setIsPrim,\n    setIsDirected,\n    defaultEdgeColor,\n    setDisablePause,\n    nodeCount,\n    setIsShortestPath,\n    setStartNode,\n    setEndNode,\n    setIsTSP,\n    sleep,\n    startNode\n  } = useGraphStates();\n  const {} = useNodeFunctions();\n\n  // Function to start DFS\n  const startDFS = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"DFS\");\n    setIsDFS(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin DFS\");\n  };\n\n  // DFS implementatoin\n  const dfs = async () => {\n    console.log(\"dfs start\");\n    setAlgorithmStarted(true);\n    setText(\"DFS in progress...\");\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let stepIndex = 0;\n    const dfsRecursive = async currentNode => {\n      if (visitedNodeSet.has(currentNode.id)) {\n        return;\n      }\n      visitedNodeSet.add(currentNode.id);\n      setVisitedNodes(prev => {\n        const updatedNodes = [...prev, {\n          id: currentNode.id,\n          color: treeEdgeColor\n        }];\n        return updatedNodes;\n      });\n      for (let neighborId of adjList[currentNode.id]) {\n        setCurrentNode(currentNode);\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n        if (!edge) {\n          continue;\n        }\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        if (!visitedEdgeSet.has(edge)) {\n          stepIndex++;\n          if (isPausedRef.current) {\n            await new Promise(resolve => {\n              const checkStep = () => {\n                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                  resolve();\n                } else {\n                  setTimeout(checkStep, 50);\n                }\n              };\n              checkStep();\n            });\n            if (isStepModeRef.current) {\n              setIsPaused(true);\n              isPausedRef.current = true;\n            }\n          } else {\n            await sleep(totalSliderCount - sliderValueRef.current);\n          }\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        }\n        if (!visitedNodeSet.has(neighborId)) {\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: treeEdgeColor\n          }]);\n          visitedEdgeSet.add(edge);\n          await dfsRecursive(neighborNode);\n        } else {\n          setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n        }\n      }\n    };\n    await dfsRecursive(startNode);\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"DFS Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to start BFS\n  const startBFS = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"BFS\");\n    setIsBFS(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin BFS\");\n  };\n\n  // BFS implementation\n  const bfs = async startNode => {\n    setAlgorithmStarted(true);\n    setText(\"BFS in progress...\");\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let stepIndex = 0;\n    const queue = [startNode];\n    visitedNodeSet.add(startNode.id);\n    setVisitedNodes([{\n      id: startNode.id,\n      color: treeEdgeColor\n    }]);\n    while (queue.length > 0) {\n      const currentNode = queue.shift();\n      setCurrentNode(currentNode);\n      for (let neighborId of adjList[currentNode.id]) {\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n        if (!edge) {\n          continue;\n        }\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        if (!visitedEdgeSet.has(edge)) {\n          stepIndex++;\n          if (isPausedRef.current) {\n            await new Promise(resolve => {\n              const checkStep = () => {\n                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                  resolve();\n                } else {\n                  setTimeout(checkStep, 50);\n                }\n              };\n              checkStep();\n            });\n            if (isStepModeRef.current) {\n              setIsPaused(true);\n              isPausedRef.current = true;\n            }\n          } else {\n            await sleep(totalSliderCount - sliderValueRef.current);\n          }\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        }\n        if (!visitedNodeSet.has(neighborId)) {\n          visitedNodeSet.add(neighborId);\n          queue.push(neighborNode);\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: treeEdgeColor\n          }]);\n          setVisitedNodes(prev => [...prev, {\n            id: neighborId,\n            color: treeEdgeColor\n          }]);\n        } else {\n          setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n        }\n      }\n    }\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"BFS Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to start Prim's algorithm\n  const startPrim = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"Prim\");\n    setIsPrim(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin Prim's Algorithm\");\n  };\n\n  // Function to animate Prim's algorithm\n  const animatePrimsAlgorithm = async startNode => {\n    setAlgorithmStarted(true);\n    setIsDirected(false);\n    setText(\"Prim's Algorithm in progress...\");\n    const visitedNodeSet = new Set();\n    const edgeQueue = [];\n    let stepIndex = 0;\n    const addEdges = node => {\n      visitedNodeSet.add(node.id);\n      setVisitedNodes(prev => [...prev, {\n        id: node.id,\n        color: treeEdgeColor\n      }]);\n      (adjList[node.id] || []).forEach(neighborId => {\n        if (!visitedNodeSet.has(neighborId)) {\n          const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === node.id);\n          if (edge) {\n            edgeQueue.push({\n              ...edge,\n              length: calculateEdgeLength(edge)\n            });\n          }\n        }\n      });\n      edgeQueue.sort((a, b) => a.length - b.length);\n    };\n    const animateStep = async () => {\n      if (visitedNodeSet.size === nodes.length || edgeQueue.length === 0) {\n        setAlgorithmStarted(false);\n        setText(\"Prim's Algorithm Done!\");\n        setTimeout(resetEdges, 1000);\n        return;\n      }\n      const edgesToHighlight = edgeQueue.slice(0, 1);\n      edgesToHighlight.forEach(edge => {\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n      });\n      stepIndex++;\n      if (isPausedRef.current) {\n        await new Promise(resolve => {\n          const checkStep = () => {\n            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n              resolve();\n            } else {\n              setTimeout(checkStep, 50);\n            }\n          };\n          checkStep();\n        });\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      } else {\n        await sleep(totalSliderCount - sliderValueRef.current);\n      }\n      if (isStepModeRef.current) {\n        setIsPaused(true);\n        isPausedRef.current = true;\n      }\n      const edge = edgeQueue.shift();\n      const {\n        from,\n        to\n      } = edge;\n      const fromInMST = visitedNodeSet.has(from.id);\n      const toInMST = visitedNodeSet.has(to.id);\n      if (fromInMST && !toInMST || !fromInMST && toInMST) {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: treeEdgeColor\n        }]);\n        if (fromInMST && !toInMST) {\n          addEdges(to);\n        } else if (!fromInMST && toInMST) {\n          addEdges(from);\n        }\n      } else {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: defaultEdgeColor\n        }]);\n      }\n      animateStep();\n    };\n    addEdges(startNode);\n    animateStep();\n  };\n\n  // Function to animate Kruskall's algorithm\n  const animateKruskalsAlgorithm = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setIsDirected(false);\n    setRunningAlgorithm(\"Kruskall\");\n    setDisablePause(true);\n    setAlgorithmRunning(true);\n    setText(\"Kruskall's Algorithm in progress...\");\n    const sortedEdges = [...edges].sort((a, b) => calculateEdgeLength(a) - calculateEdgeLength(b));\n    let componentIndex = 0;\n    let currentComponentEdges = [];\n    let currentComponentNodes = [];\n    let uf;\n    const visitedNodeSet = new Set();\n    const foundComponents = [];\n    const dfsComponent = (currentNode, component) => {\n      if (visitedNodeSet.has(currentNode.id)) {\n        return;\n      }\n      visitedNodeSet.add(currentNode.id);\n      component.push(currentNode);\n      adjList[currentNode.id].forEach(neighborId => {\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        if (!visitedNodeSet.has(neighborId)) {\n          dfsComponent(neighborNode, component);\n        }\n      });\n    };\n    nodes.forEach(node => {\n      if (!visitedNodeSet.has(node.id)) {\n        const component = [];\n        dfsComponent(node, component);\n        foundComponents.push(component);\n      }\n    });\n    setComponents(foundComponents);\n    const animateComponentMST = component => {\n      uf = new UnionFind(nodeCount);\n      currentComponentEdges = [];\n      currentComponentNodes = component.map(node => node.id);\n      let edgeIndex = 0;\n      const color = componentColors[componentIndex % componentColors.length];\n      const highlightNodesAndEdges = index => {\n        if (index < currentComponentEdges.length) {\n          const {\n            from,\n            to\n          } = currentComponentEdges[index];\n          setVisitedNodes(prev => [...prev, {\n            id: from.id,\n            color\n          }, {\n            id: to.id,\n            color\n          }]);\n          setVisitedEdges(prev => [...prev, currentComponentEdges[index]]);\n          setTimeout(() => highlightNodesAndEdges(index + 1), totalSliderCount - sliderValueRef.current);\n        } else {\n          componentIndex++;\n          if (componentIndex < foundComponents.length) {\n            setTimeout(() => animateComponentMST(foundComponents[componentIndex]), 0);\n          } else {\n            setTimeout(resetEdges, 1000);\n            setText(\"Kruskall's Algorithm Done!\");\n          }\n        }\n      };\n      const animateStep = () => {\n        if (currentComponentEdges.length === component.length - 1 || edgeIndex >= sortedEdges.length) {\n          highlightNodesAndEdges(0);\n          return;\n        }\n        const edge = sortedEdges[edgeIndex];\n        edgeIndex++;\n        if (currentComponentNodes.includes(edge.from.id) && currentComponentNodes.includes(edge.to.id) && uf.find(edge.from.id) !== uf.find(edge.to.id)) {\n          uf.union(edge.from.id, edge.to.id);\n          currentComponentEdges.push({\n            ...edge,\n            color\n          });\n        }\n        animateStep();\n      };\n      animateStep();\n    };\n    if (foundComponents.length > 0) {\n      animateComponentMST(foundComponents[0]);\n    } else {\n      console.log(\"No components found.\");\n      setAlgorithmRunning(false);\n    }\n  };\n\n  // Function to start shortest path algorithm\n  const startShortestPath = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"SP\");\n    setIsShortestPath(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Start Node for Shortest Path\");\n  };\n\n  // Function to find the shortest path between two nodes\n  const findShortestPath = async (startNode, targetNode) => {\n    setAlgorithmStarted(true);\n    setText(\"Shortest Path Algorithm in progress...\");\n    const dist = {};\n    const prev = {};\n    const visitedEdgeSet = new Set();\n    const visitedNodeSet = new Set();\n    const priorityQueue = new Set(nodes.map(node => node.id));\n    let stepIndex = 0;\n    nodes.forEach(node => {\n      dist[node.id] = Infinity;\n      prev[node.id] = null;\n    });\n    dist[startNode.id] = 0;\n    const getMinDistNode = () => {\n      let minNode = null;\n      priorityQueue.forEach(nodeId => {\n        if (minNode === null || dist[nodeId] < dist[minNode]) {\n          minNode = nodeId;\n        }\n      });\n      return minNode;\n    };\n    while (priorityQueue.size > 0) {\n      const currentNodeId = getMinDistNode();\n      const currentNode = nodes.find(node => node.id === currentNodeId);\n      if (dist[currentNodeId] === Infinity) break;\n      priorityQueue.delete(currentNodeId);\n      if (currentNodeId === targetNode.id) {\n        break;\n      }\n      for (let neighborId of adjList[currentNode.id]) {\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n        if (!edge) {\n          continue;\n        }\n        setCurrentNode(currentNode);\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        if (!visitedEdgeSet.has(edge)) {\n          stepIndex++;\n          if (isPausedRef.current) {\n            await new Promise(resolve => {\n              const checkStep = () => {\n                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                  resolve();\n                } else {\n                  setTimeout(checkStep, 50);\n                }\n              };\n              checkStep();\n            });\n            if (isStepModeRef.current) {\n              setIsPaused(true);\n              isPausedRef.current = true;\n            }\n          } else {\n            await sleep(totalSliderCount - sliderValueRef.current);\n          }\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n          visitedEdgeSet.add(edge);\n        }\n        const alt = dist[currentNode.id] + calculateEdgeLength(edge);\n        if (alt < dist[neighborId]) {\n          dist[neighborId] = alt;\n          prev[neighborId] = currentNode.id;\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: treeEdgeColor\n          }]);\n          visitedEdgeSet.add(edge);\n        } else {\n          setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color === currentEdgeColor)));\n        }\n      }\n      visitedNodeSet.add(currentNode.id);\n      setVisitedNodes(prev => {\n        const updatedNodes = [...prev, {\n          id: currentNode.id,\n          color: treeEdgeColor\n        }];\n        return updatedNodes;\n      });\n    }\n    setStartNode(null);\n    setEndNode(null);\n    setAlgorithmStarted(false);\n    setCurrentNode(null);\n    setText(\"Shortest Path Done!\");\n    const path = [];\n    let currentNodeId = targetNode.id;\n    while (currentNodeId !== null) {\n      path.unshift(currentNodeId);\n      currentNodeId = prev[currentNodeId];\n    }\n    if (path.length === 1) {\n      setText(\"No path Found!\");\n      setTimeout(resetEdges, 1000);\n      return;\n    }\n    setVisitedEdges(prev => {\n      return prev.map(e => {\n        if (path.includes(e.from.id) && path.includes(e.to.id)) {\n          return {\n            ...e,\n            color: treeEdgeColor\n          };\n        } else {\n          return {\n            ...e,\n            color: defaultEdgeColor\n          };\n        }\n      });\n    });\n    setVisitedNodes(prev => {\n      return nodes.map(node => {\n        if (path.includes(node.id)) {\n          return {\n            id: node.id,\n            color: treeEdgeColor\n          };\n        } else {\n          return {\n            id: node.id,\n            color: \"black\"\n          };\n        }\n      });\n    });\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to start TSP\n  const startTSP = async () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"TSP\");\n    setIsTSP(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin TSP\");\n  };\n\n  // Function to animate TSP\n  const tsp = async node => {\n    setAlgorithmStarted(true);\n    setText(\"TSP in progress...\");\n    const startNode = node;\n    const unvisited = new Set(nodes.map(node => node.id));\n    const visited = [];\n    const stack = [];\n    let currentNode = startNode;\n    let stepIndex = 0;\n    unvisited.delete(currentNode.id);\n    visited.push(currentNode);\n    setVisitedNodes([{\n      id: currentNode.id,\n      color: treeEdgeColor\n    }]);\n    while (unvisited.size > 0) {\n      let nearestNode = null;\n      let shortestDistance = Infinity;\n      let currentEdge = null;\n      for (let neighborId of unvisited) {\n        setCurrentNode(currentNode);\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        // eslint-disable-next-line\n        const edge = edges.find(e => isDirected && e && e.from && e.to && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && e && e.from && e.to && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n        if (!edge) {\n          continue;\n        }\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n        const distance = calculateEdgeLength({\n          from: currentNode,\n          to: neighborNode\n        });\n        setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)));\n        if (distance < shortestDistance) {\n          shortestDistance = distance;\n          nearestNode = neighborNode;\n          currentEdge = edge;\n        }\n      }\n      if (nearestNode && currentEdge) {\n        stack.push({\n          currentNode,\n          nearestNode,\n          shortestDistance\n        });\n        setVisitedEdges(prev => [...prev, {\n          ...currentEdge,\n          color: treeEdgeColor\n        }]);\n        setVisitedNodes(prev => [...prev, {\n          id: nearestNode.id,\n          color: treeEdgeColor\n        }]);\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n        currentNode = nearestNode;\n        unvisited.delete(currentNode.id);\n        visited.push(currentNode);\n      } else {\n        const previousState = stack.pop();\n        if (previousState) {\n          currentNode = previousState.currentNode;\n        } else {\n          break;\n        }\n      }\n    }\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"TSP Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to color graph\n  const graphColoring = async () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"Color\");\n    setDisablePause(true);\n    setAlgorithmRunning(true);\n    setText(\"Graph Coloring in progress...\");\n    const availableColors = componentColors;\n    const colors = {};\n    const colorGraph = node => {\n      const neighborColors = adjList[node.id].map(neighborId => colors[neighborId]);\n      for (let color of availableColors) {\n        if (!neighborColors.includes(color)) {\n          colors[node.id] = color;\n          break;\n        }\n      }\n    };\n    for (let node of nodes) {\n      colorGraph(node);\n      setVisitedNodes(prev => [...prev, {\n        id: node.id,\n        color: colors[node.id]\n      }]);\n      await new Promise(resolve => setTimeout(resolve, totalSliderCount - sliderValueRef.current));\n    }\n    setText(\"Graph Coloring Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to find connected components in a graph\n  const findConnectedComponents = async () => {\n    console.log(\"hhihi\");\n    setRunningAlgorithm(\"Connected\");\n    setAlgorithmStarted(true);\n    setText(\"Connected Components in progress...\");\n    setAlgorithmRunning(true);\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let componentIndex = 0;\n    let stepIndex = 0;\n    const dfsRecursive = async (currentNode, componentColor) => {\n      if (visitedNodeSet.has(currentNode.id)) {\n        return;\n      }\n      visitedNodeSet.add(currentNode.id);\n      setVisitedNodes(prev => {\n        const updatedNodes = [...prev, {\n          id: currentNode.id,\n          color: componentColor\n        }];\n        return updatedNodes;\n      });\n      for (let neighborId of adjList[currentNode.id]) {\n        setCurrentNode(currentNode);\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        const edge = edges.find(e => e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id);\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        if (!visitedEdgeSet.has(edge)) {\n          stepIndex++;\n          if (isPausedRef.current) {\n            await new Promise(resolve => {\n              const checkStep = () => {\n                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                  resolve();\n                } else {\n                  setTimeout(checkStep, 50);\n                }\n              };\n              checkStep();\n            });\n            if (isStepModeRef.current) {\n              setIsPaused(true);\n              isPausedRef.current = true;\n            }\n          } else {\n            await sleep(totalSliderCount - sliderValueRef.current);\n          }\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        }\n        if (!visitedNodeSet.has(neighborId)) {\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: componentColor\n          }]);\n          visitedEdgeSet.add(edge);\n          await dfsRecursive(neighborNode, componentColor);\n        } else {\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: componentColor\n          }]);\n        }\n      }\n    };\n    for (let node of nodes) {\n      if (!visitedNodeSet.has(node.id)) {\n        const componentColor = componentColors[componentIndex % componentColors.length];\n        componentIndex++;\n        await dfsRecursive(node, componentColor);\n      }\n    }\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"Connected Components Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to find strong components\n  const findStrongComponents = async () => {\n    setRunningAlgorithm(\"Connected\");\n    setAlgorithmStarted(true);\n    setText(\"Strong Components in progress...\");\n    setAlgorithmRunning(true);\n    const stack = [];\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    const reverseAdjList = {};\n    let stepIndex = 0;\n    const dfs1 = async node => {\n      if (visitedNodeSet.has(node.id)) {\n        return;\n      }\n      visitedNodeSet.add(node.id);\n      for (let neighborId of adjList[node.id]) {\n        if (!visitedNodeSet.has(neighborId)) {\n          const neighborNode = nodes.find(n => n.id === neighborId);\n          await dfs1(neighborNode);\n        }\n      }\n      stack.push(node);\n    };\n    const reverseGraph = () => {\n      nodes.forEach(node => {\n        reverseAdjList[node.id] = [];\n      });\n      edges.forEach(edge => {\n        reverseAdjList[edge.to.id].push(edge.from.id);\n      });\n    };\n    const dfs2 = async (node, componentColor) => {\n      if (visitedNodeSet.has(node.id)) {\n        return;\n      }\n      visitedNodeSet.add(node.id);\n      setVisitedNodes(prev => {\n        const updatedNodes = [...prev, {\n          id: node.id,\n          color: componentColor\n        }];\n        return updatedNodes;\n      });\n      for (let neighborId of reverseAdjList[node.id]) {\n        setCurrentNode(node);\n        const neighborNode = nodes.find(n => n.id === neighborId);\n        const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId);\n        if (!edge) {\n          continue;\n        }\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        if (!visitedEdgeSet.has(edge)) {\n          stepIndex++;\n          if (isPausedRef.current) {\n            await new Promise(resolve => {\n              const checkStep = () => {\n                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                  resolve();\n                } else {\n                  setTimeout(checkStep, 50);\n                }\n              };\n              checkStep();\n            });\n            if (isStepModeRef.current) {\n              setIsPaused(true);\n              isPausedRef.current = true;\n            }\n          } else {\n            await sleep(totalSliderCount - sliderValueRef.current);\n          }\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        }\n        if (!visitedNodeSet.has(neighborId)) {\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: componentColor\n          }]);\n          visitedEdgeSet.add(edge);\n          await dfs2(neighborNode, componentColor);\n        } else {\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: componentColor\n          }]);\n        }\n      }\n    };\n    reverseGraph();\n    for (let node of nodes) {\n      if (!visitedNodeSet.has(node.id)) {\n        await dfs1(node);\n      }\n    }\n    visitedNodeSet.clear();\n    visitedEdgeSet.clear();\n    let componentIndex = 0;\n    while (stack.length > 0) {\n      const node = stack.pop();\n      if (!visitedNodeSet.has(node.id)) {\n        const componentColor = componentColors[componentIndex % componentColors.length];\n        componentIndex++;\n        await dfs2(node, componentColor);\n      }\n    }\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"Strong Components Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n  return {\n    startDFS,\n    dfs,\n    startBFS,\n    bfs,\n    startPrim,\n    animatePrimsAlgorithm,\n    animateKruskalsAlgorithm,\n    startShortestPath,\n    findShortestPath,\n    startTSP,\n    tsp,\n    graphColoring,\n    findConnectedComponents,\n    findStrongComponents\n  };\n};\n_s(useAlgorithms, \"0lACD49jwmF/FW7zybfG/YVl+dY=\", false, function () {\n  return [useGraphStates, useNodeFunctions];\n});","map":{"version":3,"names":["calculateEdgeLength","UnionFind","useGraphStates","useNodeFunctions","useAlgorithms","_s","nodes","edges","adjList","setVisitedNodes","setVisitedEdges","setAlgorithmStarted","setText","resetEdges","setCurrentNode","isPausedRef","currentStepRef","isStepModeRef","sliderValueRef","totalSliderCount","componentColors","setComponents","algorithmRunning","isRemovingEdge","setRunningAlgorithm","setIsDFS","setAlgorithmRunning","treeEdgeColor","isDirected","currentEdgeColor","setIsPaused","setIsBFS","setIsPrim","setIsDirected","defaultEdgeColor","setDisablePause","nodeCount","setIsShortestPath","setStartNode","setEndNode","setIsTSP","sleep","startNode","startDFS","dfs","console","log","visitedNodeSet","Set","visitedEdgeSet","stepIndex","dfsRecursive","currentNode","has","id","add","prev","updatedNodes","color","neighborId","neighborNode","find","node","edge","e","from","to","current","Promise","resolve","checkStep","setTimeout","filter","startBFS","bfs","queue","length","shift","push","startPrim","animatePrimsAlgorithm","edgeQueue","addEdges","forEach","sort","a","b","animateStep","size","edgesToHighlight","slice","fromInMST","toInMST","animateKruskalsAlgorithm","sortedEdges","componentIndex","currentComponentEdges","currentComponentNodes","uf","foundComponents","dfsComponent","component","animateComponentMST","map","edgeIndex","highlightNodesAndEdges","index","includes","union","startShortestPath","findShortestPath","targetNode","dist","priorityQueue","Infinity","getMinDistNode","minNode","nodeId","currentNodeId","delete","alt","path","unshift","startTSP","tsp","unvisited","visited","stack","nearestNode","shortestDistance","currentEdge","distance","previousState","pop","graphColoring","availableColors","colors","colorGraph","neighborColors","findConnectedComponents","componentColor","findStrongComponents","reverseAdjList","dfs1","n","reverseGraph","dfs2","clear"],"sources":["/Users/tani/Desktop/visualizer/Visusalizer Project/src/Components/Algorithms.js"],"sourcesContent":["import {calculateEdgeLength} from './GraphUtilities';\nimport UnionFind from './UnionFind';\nimport { useGraphStates } from './GraphsContext';\nimport { useNodeFunctions } from './NodeFunctions';\n\nexport const useAlgorithms = () => {\n    const {\n        nodes, edges, adjList, setVisitedNodes, setVisitedEdges, setAlgorithmStarted, setText, resetEdges,\n        setCurrentNode, isPausedRef, currentStepRef, isStepModeRef, sliderValueRef, totalSliderCount, \n        componentColors, setComponents, algorithmRunning, isRemovingEdge, setRunningAlgorithm, setIsDFS, setAlgorithmRunning,\n        treeEdgeColor, isDirected, currentEdgeColor, setIsPaused, setIsBFS, setIsPrim, setIsDirected, defaultEdgeColor,\n        setDisablePause, nodeCount, setIsShortestPath, setStartNode, setEndNode, setIsTSP, sleep, startNode\n    } = useGraphStates();\n\n    const {} = useNodeFunctions();\n\n    // Function to start DFS\n    const startDFS = () => {\n        if(algorithmRunning|| isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"DFS\");\n        setIsDFS(true);\n        setAlgorithmRunning(true);\n        setText(\"Select Node to begin DFS\");\n    }\n\n    // DFS implementatoin\n    const dfs = async () => {\n        console.log(\"dfs start\");\n        setAlgorithmStarted(true);\n        setText(\"DFS in progress...\");\n\n        const visitedNodeSet = new Set();\n        const visitedEdgeSet = new Set();\n        let stepIndex = 0;\n\n        const dfsRecursive = async (currentNode) => {\n            if (visitedNodeSet.has(currentNode.id)) {\n                return;\n            }\n\n            visitedNodeSet.add(currentNode.id);\n            setVisitedNodes(prev => { \n                const updatedNodes = [...prev, { id: currentNode.id, color: treeEdgeColor }];\n                return updatedNodes;\n            });\n\n            for (let neighborId of adjList[currentNode.id]) {\n                setCurrentNode(currentNode);     \n                const neighborNode = nodes.find(node => node.id === neighborId); \n                const edge = edges.find(e =>                                     \n                    (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === currentNode.id)))\n                );\n\n                if(!edge){\n                    continue;\n                }\n\n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n            \n                if (!visitedEdgeSet.has(edge)) {\n                    stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                }\n\n                if (!visitedNodeSet.has(neighborId)) { \n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: treeEdgeColor }\n                    ]);\n                    visitedEdgeSet.add(edge);\n\n                    await dfsRecursive(neighborNode);\n                } else {\n                    setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n                }\n            }\n\n        };\n\n        await dfsRecursive(startNode);\n        setCurrentNode(null);\n        setAlgorithmStarted(false);\n        setText(\"DFS Done!\");\n        setTimeout(resetEdges, 1000); \n    };\n\n    // Function to start BFS\n    const startBFS = () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"BFS\");\n        setIsBFS(true);\n        setAlgorithmRunning(true);\n        setText(\"Select Node to begin BFS\");\n    }\n\n    // BFS implementation\n    const bfs = async (startNode) => {\n        setAlgorithmStarted(true);\n        setText(\"BFS in progress...\");\n        const visitedNodeSet = new Set();\n        const visitedEdgeSet = new Set();\n        let stepIndex = 0;\n\n\n        const queue = [startNode];\n        visitedNodeSet.add(startNode.id);\n        setVisitedNodes([{ id: startNode.id, color: treeEdgeColor }]);\n\n        while (queue.length > 0) {\n            const currentNode = queue.shift();\n            setCurrentNode(currentNode);\n            \n            for (let neighborId of adjList[currentNode.id]) {\n                const neighborNode = nodes.find(node => node.id === neighborId);\n                const edge = edges.find(e =>                                     \n                    (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === currentNode.id)))\n                );\n\n                if(!edge){\n                    continue;\n                }\n\n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n                if(!visitedEdgeSet.has(edge)){\n                    stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                }\n\n                if (!visitedNodeSet.has(neighborId)) {\n                    visitedNodeSet.add(neighborId);\n                    queue.push(neighborNode);\n\n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: treeEdgeColor }\n                    ]);\n                    setVisitedNodes(prev => [...prev, { id: neighborId, color: treeEdgeColor }]);\n\n                } else{\n                    setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n                }\n                \n            }\n        }\n\n        setCurrentNode(null);\n        setAlgorithmStarted(false);\n        setText(\"BFS Done!\");\n        setTimeout(resetEdges, 1000); \n    };\n\n    // Function to start Prim's algorithm\n    const startPrim = () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"Prim\");\n        setIsPrim(true);\n        setAlgorithmRunning(true);\n        setText(\"Select Node to begin Prim's Algorithm\");\n    }\n\n    // Function to animate Prim's algorithm\n    const animatePrimsAlgorithm = async (startNode) => {\n        setAlgorithmStarted(true);\n        setIsDirected(false);\n        setText(\"Prim's Algorithm in progress...\");\n        const visitedNodeSet = new Set();\n        const edgeQueue = [];\n        let stepIndex = 0;\n\n        const addEdges = (node) => {\n            visitedNodeSet.add(node.id);\n            setVisitedNodes(prev => [...prev, { id: node.id, color: treeEdgeColor }]);\n            (adjList[node.id] || []).forEach(neighborId => {\n                if (!visitedNodeSet.has(neighborId)) {\n                    const edge = edges.find(e => \n                        (e.from.id === node.id && e.to.id === neighborId) ||\n                        (e.from.id === neighborId && e.to.id === node.id)\n                    );\n                    if (edge) {\n                        edgeQueue.push({ ...edge, length: calculateEdgeLength(edge) });\n                    }\n                }\n            });\n            edgeQueue.sort((a, b) => a.length - b.length); \n        };\n\n        const animateStep = async () => {\n            if (visitedNodeSet.size === nodes.length || edgeQueue.length === 0) {\n                setAlgorithmStarted(false);\n                setText(\"Prim's Algorithm Done!\");\n                setTimeout(resetEdges, 1000);\n                return;\n            }\n\n            const edgesToHighlight = edgeQueue.slice(0, 1); \n            edgesToHighlight.forEach(edge => {\n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n            });\n\n            stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n\n            const edge = edgeQueue.shift();\n            const { from, to } = edge;\n            const fromInMST = visitedNodeSet.has(from.id);\n            const toInMST = visitedNodeSet.has(to.id);\n\n            if ((fromInMST && !toInMST) || (!fromInMST && toInMST)) {\n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: treeEdgeColor }\n                ]);\n\n                if (fromInMST && !toInMST) {\n                    addEdges(to);\n                } else if (!fromInMST && toInMST) {\n                    addEdges(from);\n                }\n            } else {\n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: defaultEdgeColor }\n                ]);\n            }\n\n            animateStep();\n        };\n\n        addEdges(startNode);\n        animateStep();\n    };\n\n    // Function to animate Kruskall's algorithm\n    const animateKruskalsAlgorithm = () => {\n        if (algorithmRunning || isRemovingEdge) {\n            return;\n        }\n        setIsDirected(false);\n        setRunningAlgorithm(\"Kruskall\");\n        setDisablePause(true);\n        setAlgorithmRunning(true);\n        setText(\"Kruskall's Algorithm in progress...\");\n\n        const sortedEdges = [...edges].sort((a, b) => calculateEdgeLength(a) - calculateEdgeLength(b));\n        let componentIndex = 0;\n        let currentComponentEdges = [];\n        let currentComponentNodes = [];\n        let uf;\n\n        const visitedNodeSet = new Set();\n        const foundComponents = [];\n\n        const dfsComponent = (currentNode, component) => {\n            if (visitedNodeSet.has(currentNode.id)) {\n                return;\n            }\n            visitedNodeSet.add(currentNode.id);\n            component.push(currentNode);\n            adjList[currentNode.id].forEach(neighborId => {\n                const neighborNode = nodes.find(node => node.id === neighborId);\n                if (!visitedNodeSet.has(neighborId)) {\n                    dfsComponent(neighborNode, component);\n                }\n            });\n        };\n\n        nodes.forEach(node => {\n            if (!visitedNodeSet.has(node.id)) {\n                const component = [];\n                dfsComponent(node, component);\n                foundComponents.push(component);\n            }\n        });\n\n        setComponents(foundComponents);\n\n        const animateComponentMST = (component) => {\n            uf = new UnionFind(nodeCount); \n            currentComponentEdges = [];\n            currentComponentNodes = component.map(node => node.id);\n            let edgeIndex = 0;\n            const color = componentColors[componentIndex % componentColors.length];\n\n            const highlightNodesAndEdges = (index) => {\n                if (index < currentComponentEdges.length) {\n                    const { from, to } = currentComponentEdges[index];\n                    setVisitedNodes(prev => [...prev, { id: from.id, color }, { id: to.id, color }]);\n                    setVisitedEdges(prev => [...prev, currentComponentEdges[index]]);\n                    setTimeout(() => highlightNodesAndEdges(index + 1), totalSliderCount - sliderValueRef.current); \n                } else {\n                    componentIndex++;\n                    if (componentIndex < foundComponents.length) {\n                        setTimeout(() => animateComponentMST(foundComponents[componentIndex]), 0); \n                    } else {\n                        setTimeout(resetEdges, 1000);\n                        setText(\"Kruskall's Algorithm Done!\");\n                    }\n                }\n            };\n\n            const animateStep = () => {\n                if (currentComponentEdges.length === component.length - 1 || edgeIndex >= sortedEdges.length) {\n                    highlightNodesAndEdges(0);\n                    return;\n                }\n\n                const edge = sortedEdges[edgeIndex];\n                edgeIndex++;\n\n                if (currentComponentNodes.includes(edge.from.id) && currentComponentNodes.includes(edge.to.id) &&\n                    uf.find(edge.from.id) !== uf.find(edge.to.id)) {\n                    uf.union(edge.from.id, edge.to.id);\n                    currentComponentEdges.push({ ...edge, color });\n                }\n\n                animateStep();\n            };\n\n            animateStep();\n        };\n\n        if (foundComponents.length > 0) {\n            animateComponentMST(foundComponents[0]);\n        } else {\n            console.log(\"No components found.\");\n            setAlgorithmRunning(false);\n        }\n    };\n\n    // Function to start shortest path algorithm\n    const startShortestPath = () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"SP\");\n\n        setIsShortestPath(true);\n        setAlgorithmRunning(true);\n        setText(\"Select Start Node for Shortest Path\");\n    }\n\n    // Function to find the shortest path between two nodes\n    const findShortestPath = async (startNode, targetNode) => {\n        setAlgorithmStarted(true);\n        setText(\"Shortest Path Algorithm in progress...\");\n        const dist = {};\n        const prev = {};\n        const visitedEdgeSet = new Set();\n        const visitedNodeSet = new Set();\n        const priorityQueue = new Set(nodes.map(node => node.id)); \n        let stepIndex = 0;\n\n        nodes.forEach(node => {\n            dist[node.id] = Infinity;\n            prev[node.id] = null;\n        });\n        dist[startNode.id] = 0;\n\n        const getMinDistNode = () => {\n            let minNode = null;\n            priorityQueue.forEach(nodeId => {\n                if (minNode === null || dist[nodeId] < dist[minNode]) {\n                    minNode = nodeId;\n                }\n            });\n            return minNode;\n        };\n\n        while (priorityQueue.size > 0) {\n            const currentNodeId = getMinDistNode();\n            const currentNode = nodes.find(node => node.id === currentNodeId);\n\n            if (dist[currentNodeId] === Infinity) break;\n\n            priorityQueue.delete(currentNodeId);\n\n            if (currentNodeId === targetNode.id) {\n                break;\n            }\n\n            for (let neighborId of adjList[currentNode.id]) {\n                const neighborNode = nodes.find(node => node.id === neighborId);\n                const edge = edges.find(e => \n                    (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === currentNode.id)))\n                );\n\n                if(!edge){\n                    continue;\n                }\n\n                setCurrentNode(currentNode);\n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n                if (!visitedEdgeSet.has(edge)) {\n                    stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                    visitedEdgeSet.add(edge);\n                }\n\n                const alt = dist[currentNode.id] + calculateEdgeLength(edge);\n\n                if (alt < dist[neighborId]) {\n                    dist[neighborId] = alt;\n                    prev[neighborId] = currentNode.id;\n\n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: treeEdgeColor }\n                    ]);\n\n                    visitedEdgeSet.add(edge);\n                } else {\n                    setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color === currentEdgeColor)));\n                }\n            }\n\n            visitedNodeSet.add(currentNode.id);\n            setVisitedNodes(prev => {\n                const updatedNodes = [...prev, { id: currentNode.id, color: treeEdgeColor }];\n                return updatedNodes;\n            });\n        }\n\n        setStartNode(null);\n        setEndNode(null);\n        setAlgorithmStarted(false);\n        setCurrentNode(null);\n        setText(\"Shortest Path Done!\");\n\n        const path = [];\n\n        let currentNodeId = targetNode.id;\n        while (currentNodeId !== null) {\n            path.unshift(currentNodeId);\n            currentNodeId = prev[currentNodeId];\n        }\n\n        if(path.length === 1){\n            setText(\"No path Found!\");\n            setTimeout(resetEdges, 1000);\n            return;\n        }\n\n        setVisitedEdges(prev => {\n            return prev.map(e => {\n                if (path.includes(e.from.id) && path.includes(e.to.id)) {\n                    return { ...e, color: treeEdgeColor };\n                } else {\n                    return { ...e, color: defaultEdgeColor };\n                }\n            });\n        });\n\n        setVisitedNodes(prev => {\n            return nodes.map(node => {\n                if (path.includes(node.id)) {\n                    return { id: node.id, color: treeEdgeColor };\n                } else {\n                    return { id: node.id, color: \"black\" };\n                }\n            });\n        });\n\n        setTimeout(resetEdges, 1000);\n    };\n\n    // Function to start TSP\n    const startTSP = async () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"TSP\");\n        setIsTSP(true);\n        setAlgorithmRunning(true);\n        setText(\"Select Node to begin TSP\");\n    }\n\n    // Function to animate TSP\n    const tsp = async (node) => {\n        setAlgorithmStarted(true);\n        setText(\"TSP in progress...\");\n        const startNode = node;\n        const unvisited = new Set(nodes.map(node => node.id));\n        const visited = [];\n        const stack = [];\n        let currentNode = startNode;\n        let stepIndex = 0;\n\n        unvisited.delete(currentNode.id);\n        visited.push(currentNode);\n        setVisitedNodes([{ id: currentNode.id, color: treeEdgeColor }]);\n\n        while (unvisited.size > 0) {\n            let nearestNode = null;\n            let shortestDistance = Infinity;\n            let currentEdge = null;\n\n            for (let neighborId of unvisited) {\n                setCurrentNode(currentNode);\n                const neighborNode = nodes.find(node => node.id === neighborId);\n                // eslint-disable-next-line\n                const edge = edges.find(e => \n                    (isDirected && e && e.from && e.to && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (!isDirected && e && e.from && e.to && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === currentNode.id)))\n                );\n\n                if (!edge) {\n                    continue;\n                }\n                \n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n                stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n                const distance = calculateEdgeLength({ from: currentNode, to: neighborNode });\n                setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)));\n                if (distance < shortestDistance) {\n                    shortestDistance = distance;\n                    nearestNode = neighborNode;\n                    currentEdge = edge;\n                }\n                \n            }\n\n            if (nearestNode && currentEdge) {\n                stack.push({ currentNode, nearestNode, shortestDistance });\n\n                setVisitedEdges(prev => [...prev, { ...currentEdge, color: treeEdgeColor }]);\n                setVisitedNodes(prev => [...prev, { id: nearestNode.id, color: treeEdgeColor }]);\n\n                stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n\n                currentNode = nearestNode;\n                unvisited.delete(currentNode.id);\n                visited.push(currentNode);\n            } else {\n                const previousState = stack.pop();\n                if (previousState) {\n                    currentNode = previousState.currentNode;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        setCurrentNode(null);\n        setAlgorithmStarted(false);\n        setText(\"TSP Done!\");\n        setTimeout(resetEdges, 1000);\n    };\n\n    // Function to color graph\n    const graphColoring = async () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"Color\");\n        setDisablePause(true);\n        setAlgorithmRunning(true);\n        setText(\"Graph Coloring in progress...\");\n\n        const availableColors = componentColors;\n        const colors = {};\n\n        const colorGraph = (node) => {\n            const neighborColors = adjList[node.id].map(neighborId => colors[neighborId]);\n            for(let color of availableColors){\n                if(!neighborColors.includes(color)){\n                    colors[node.id] = color;\n                    break;\n                }\n            }\n        }\n\n        for(let node of nodes){\n            colorGraph(node);\n            setVisitedNodes(prev => [...prev, {id: node.id, color: colors[node.id]}]);\n            await new Promise(resolve => setTimeout(resolve, totalSliderCount - sliderValueRef.current));\n        }\n\n        setText(\"Graph Coloring Done!\");\n        setTimeout(resetEdges, 1000);\n    }\n\n    // Function to find connected components in a graph\n    const findConnectedComponents = async () => {\n        console.log(\"hhihi\");\n        setRunningAlgorithm(\"Connected\");\n        setAlgorithmStarted(true);\n        setText(\"Connected Components in progress...\");\n        setAlgorithmRunning(true);\n        const visitedNodeSet = new Set();\n        const visitedEdgeSet = new Set();\n        let componentIndex = 0;\n        let stepIndex = 0;\n\n        const dfsRecursive = async (currentNode, componentColor) => {\n            if (visitedNodeSet.has(currentNode.id)) {\n                return;\n            }\n\n            visitedNodeSet.add(currentNode.id);\n            setVisitedNodes(prev => { \n                const updatedNodes = [...prev, { id: currentNode.id, color: componentColor }];\n                return updatedNodes;\n            });\n\n            for (let neighborId of adjList[currentNode.id]) {\n                setCurrentNode(currentNode);     \n                const neighborNode = nodes.find(node => node.id === neighborId); \n                const edge = edges.find(e =>                                     \n                    (e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === currentNode.id)\n                );\n\n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n                if (!visitedEdgeSet.has(edge)) {\n                    stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                }\n\n                if (!visitedNodeSet.has(neighborId)) { \n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: componentColor }\n                    ]);\n                    visitedEdgeSet.add(edge);\n\n                    await dfsRecursive(neighborNode, componentColor);\n                } else {\n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: componentColor }\n                    ]);\n                }\n            }\n        };\n\n        for (let node of nodes) {\n            if (!visitedNodeSet.has(node.id)) {\n                const componentColor = componentColors[componentIndex % componentColors.length];\n                componentIndex++;\n                await dfsRecursive(node, componentColor);\n            }\n        }\n\n        setCurrentNode(null);\n        setAlgorithmStarted(false);\n        setText(\"Connected Components Done!\");\n        setTimeout(resetEdges, 1000); \n    };\n\n    // Function to find strong components\n    const findStrongComponents = async () => {\n        setRunningAlgorithm(\"Connected\");\n        setAlgorithmStarted(true);\n        setText(\"Strong Components in progress...\");\n        setAlgorithmRunning(true);\n\n        const stack = [];\n        const visitedNodeSet = new Set();\n        const visitedEdgeSet = new Set();\n        const reverseAdjList = {};\n        let stepIndex = 0;\n\n        const dfs1 = async (node) => {\n            if (visitedNodeSet.has(node.id)) {\n                return;\n            }\n\n            visitedNodeSet.add(node.id);\n            \n            for (let neighborId of adjList[node.id]) {\n                if (!visitedNodeSet.has(neighborId)) {\n                    const neighborNode = nodes.find(n => n.id === neighborId);\n                    await dfs1(neighborNode);\n                }\n            }\n            \n            stack.push(node);\n        };\n\n        const reverseGraph = () => {\n            nodes.forEach(node => {\n                reverseAdjList[node.id] = [];\n            });\n            edges.forEach(edge => {\n                reverseAdjList[edge.to.id].push(edge.from.id);\n            });\n        };\n\n        const dfs2 = async (node, componentColor) => {\n            if (visitedNodeSet.has(node.id)) {\n                return;\n            }\n            \n            visitedNodeSet.add(node.id);\n            setVisitedNodes(prev => { \n                const updatedNodes = [...prev, { id: node.id, color: componentColor }];\n                return updatedNodes;\n            });\n        \n            for (let neighborId of reverseAdjList[node.id]) {\n                setCurrentNode(node);\n                const neighborNode = nodes.find(n => n.id === neighborId);\n                const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId);\n                \n                if (!edge) {\n                    continue;\n                }\n        \n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n        \n                if (!visitedEdgeSet.has(edge)) {\n                    stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if (isStepModeRef.current) {\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n        \n                    if (isStepModeRef.current) {\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                }\n                \n                if (!visitedNodeSet.has(neighborId)) { \n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: componentColor }\n                    ]);\n                    visitedEdgeSet.add(edge);\n\n                    await dfs2(neighborNode, componentColor);\n                } else {\n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: componentColor }\n                    ]);\n                }\n            }\n        };\n\n        reverseGraph();\n\n        for (let node of nodes) {\n            if (!visitedNodeSet.has(node.id)) {\n                await dfs1(node);\n            }\n        }\n\n        visitedNodeSet.clear();\n        visitedEdgeSet.clear();\n\n        let componentIndex = 0;\n        while (stack.length > 0) {\n            const node = stack.pop();\n            if (!visitedNodeSet.has(node.id)) {\n                const componentColor = componentColors[componentIndex % componentColors.length];\n                componentIndex++;\n                await dfs2(node, componentColor);\n            }\n        }\n\n        setCurrentNode(null);\n        setAlgorithmStarted(false);\n        setText(\"Strong Components Done!\");\n        setTimeout(resetEdges, 1000);\n    };\n\n    return {startDFS, dfs, startBFS, bfs, startPrim, animatePrimsAlgorithm, animateKruskalsAlgorithm, startShortestPath, findShortestPath, startTSP, tsp, graphColoring, findConnectedComponents, findStrongComponents};\n\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}