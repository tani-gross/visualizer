{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useGraphStates } from './GraphsContext';\nexport const useNodeFunctions = () => {\n  _s();\n  const {\n    nodes,\n    edges,\n    isStepMode,\n    isPaused,\n    setClickedTraveral,\n    setClickedMST,\n    setText,\n    setClickedPaths,\n    setIsStepMode,\n    isPausedRef,\n    currentStepRef,\n    isStepModeRef,\n    setCurrentStep,\n    runningAlgorithm,\n    componentColors,\n    setEdges,\n    algorithmRunning,\n    isRemovingEdge,\n    setAdjList,\n    GraphsProvider,\n    setAlgorithmRunning,\n    selectedNode,\n    isDirected,\n    setIsPaused,\n    startNode,\n    reoveNode,\n    setIsDirected,\n    setShowWeights,\n    showWeights,\n    algorithmStarted,\n    disablePause,\n    sliderValue,\n    calculateMidpoint,\n    calculateAngle,\n    visitedEdges,\n    calculateEdgeLength,\n    isTSP,\n    isBFS,\n    isDFS,\n    isPrim,\n    isShortestPath,\n    currentNode,\n    visitedNodes,\n    components,\n    text,\n    clickedTraversal,\n    clickedMST,\n    clickedPaths,\n    animateKruskalsAlgorithm,\n    startPrim,\n    startDFS,\n    startBFS,\n    startShortestPath,\n    startTSP,\n    graphColoring,\n    findConnectedComponents,\n    findStrongComponents\n  } = useGraphStates();\n\n  // Function to add a new node to the graph\n  const addNode = () => {\n    console.log(\"here\");\n    if (algorithmRunning) {\n      return;\n    }\n    if (nodes.length >= 20) {\n      alert(\"too many nodes\");\n      return;\n    }\n    setText(startingText);\n    const newNode = {\n      id: nodeCount,\n      x: Math.random() * 480,\n      y: Math.random() * 480\n    };\n    setNodes([...nodes, newNode]);\n    setAdjList(prevAdjList => ({\n      ...prevAdjList,\n      [newNode.id]: []\n    }));\n    setNodeCount(nodeCount + 1);\n  };\n\n  // Function to generate a random graph\n  const generateGraph = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    var numNodes = 0;\n    var numEdges = -1;\n    do {\n      const response = prompt(\"Enter the number of nodes for the graph:\", \"\");\n      if (response === null) {\n        return;\n      }\n      if (isNaN(response)) {\n        alert(\"Invalid input. Please enter numbers only\");\n        continue;\n      }\n      if (response <= 0 || response > 20) {\n        alert(\"Invalid input. Number of nodes must be between 1 and 20\");\n        continue;\n      }\n      numNodes = response;\n    } while (numNodes === 0);\n    do {\n      const response = prompt(\"Enter the number of edges for the graph:\", \"\");\n      if (response === null) {\n        return;\n      }\n      if (isNaN(response)) {\n        alert(\"Invalid input. Please enter numbers only\");\n        continue;\n      }\n      if (!isDirected) {\n        if (response > numNodes * (numNodes - 1) / 2) {\n          alert(\"Invalid input. Too many edges for the undirected graph\");\n          continue;\n        }\n      } else {\n        if (response > numNodes * (numNodes - 1)) {\n          alert(\"Invalid input. Too many edges for the directed graph\");\n          continue;\n        }\n      }\n      if (response < 0) {\n        alert(\"Invalid input. Not enough edges\");\n        continue;\n      }\n      numEdges = response;\n    } while (numEdges === -1);\n    setNodes([]);\n    setEdges([]);\n    setAdjList({});\n    setNodeCount(0);\n    setVisitedNodes([]);\n    setVisitedEdges([]);\n    setSelectedNode(null);\n    setText(startingText);\n    const newNodes = [];\n    const newEdges = [];\n    const newAdjList = {};\n    const gridSize = Math.ceil(Math.sqrt(numNodes));\n    const areaWidth = 500;\n    const areaHeight = 500;\n    const margin = 10;\n    const gridSpacingX = (areaWidth - 2 * margin) / gridSize;\n    const gridSpacingY = (areaHeight - 2 * margin) / gridSize;\n    for (let i = 0; i < numNodes; i++) {\n      const row = Math.floor(i / gridSize);\n      const col = i % gridSize;\n      const x = margin + col * gridSpacingX + Math.random() * gridSpacingX * 0.9;\n      const y = margin + row * gridSpacingY + Math.random() * gridSpacingY * 0.9;\n      const newNode = {\n        id: i,\n        x: x,\n        y: y\n      };\n      newNodes.push(newNode);\n      newAdjList[i] = [];\n    }\n    while (newEdges.length < numEdges) {\n      const from = newNodes[Math.floor(Math.random() * numNodes)];\n      const to = newNodes[Math.floor(Math.random() * numNodes)];\n      if (from.id !== to.id) {\n        const edgeExists = newEdges.some(edge => edge.from.id === from.id && edge.to.id === to.id || !isDirected && edge.from.id === to.id && edge.to.id === from.id);\n        if (!edgeExists) {\n          const newEdge = {\n            from,\n            to,\n            color: defaultEdgeColor\n          };\n          newEdges.push(newEdge);\n          newAdjList[from.id].push(to.id);\n          if (!isDirected) {\n            newAdjList[to.id].push(from.id);\n          }\n        }\n      }\n    }\n    setNodes(newNodes);\n    setEdges(newEdges);\n    setAdjList(newAdjList);\n    setNodeCount(newNodes.length);\n  };\n\n  // Function to reset the graph\n  const resetGraph = () => {\n    if (algorithmRunning) {\n      return;\n    }\n    setNodes([]);\n    setEdges([]);\n    setClickedMST(false);\n    setClickedTraveral(false);\n    setIsRemovingEdge(false);\n    setText(startingText);\n  };\n\n  // Function to remove a selected node form the graph\n  const removeNode = () => {\n    if (selectedNode == null) return;\n    setNodes(nodes.filter(node => node.id !== selectedNode.id));\n    setEdges(edges.filter(edge => edge.from.id !== selectedNode.id && edge.to.id !== selectedNode.id));\n    setAdjList(prevAdjList => {\n      const newAdjList = {\n        ...prevAdjList\n      };\n      delete newAdjList[selectedNode.id];\n      for (const key in newAdjList) {\n        newAdjList[key] = newAdjList[key].filter(id => id !== selectedNode.id);\n      }\n      return newAdjList;\n    });\n    setSelectedNode(null);\n  };\n\n  // Function to handle clicking on a node\n  const handleNodeClick = node => {\n    if (dragging) {\n      return;\n    }\n    if (isAddingEdge) {\n      if (selectedNode && selectedNode.id !== node.id) {\n        const edgeExists = edges.some(edge => edge.from.id === selectedNode.id && edge.to.id === node.id || !isDirected && edge.from.id === node.id && edge.to.id === selectedNode.id);\n        if (!edgeExists) {\n          const newEdge = {\n            from: selectedNode,\n            to: node,\n            color: defaultEdgeColor\n          };\n          setEdges(prevEdges => [...prevEdges, newEdge]);\n          setAdjList(prevAdjList => {\n            const newAdjList = {\n              ...prevAdjList\n            };\n            if (!newAdjList[selectedNode.id]) newAdjList[selectedNode.id] = [];\n            if (!newAdjList[node.id]) newAdjList[node.id] = [];\n            newAdjList[selectedNode.id].push(node.id);\n            if (!isDirected) {\n              newAdjList[node.id].push(selectedNode.id);\n            }\n            return newAdjList;\n          });\n        }\n        setIsAddingEdge(false);\n        setSelectedNode(null);\n      } else if (selectedNode && selectedNode.id === node.id) {\n        setSelectedNode(null);\n        setIsAddingEdge(false);\n      }\n      setText(startingText);\n    } else if (isDFS) {\n      setVisitedNodes([]);\n      setVisitedEdges([]);\n      dfs(node);\n      setIsDFS(false);\n    } else if (isBFS) {\n      setVisitedNodes([]);\n      setVisitedEdges([]);\n      bfs(node);\n      setIsBFS(false);\n    } else if (isPrim) {\n      setIsPrim(false);\n      animatePrimsAlgorithm(node);\n    } else if (isShortestPath) {\n      if (!startNode) {\n        setStartNode(node);\n        setText(\"Select End Node for Shortest Path\");\n      } else if (!endNode) {\n        setEndNode(node);\n        setText(\"Finding Shortest Path...\");\n        findShortestPath(startNode, node);\n        setIsShortestPath(false);\n      }\n    } else if (isTSP) {\n      setVisitedNodes([]);\n      setVisitedEdges([]);\n      tsp(node);\n      setIsTSP(false);\n    } else {\n      if (selectedNode && selectedNode.id === node.id) {\n        setSelectedNode(null);\n        setText(startingText);\n      } else {\n        if (!algorithmRunning) {\n          setSelectedNode(node);\n        }\n      }\n    }\n  };\n\n  // Function to handle mouse down event for dragging\n  const handleMouseDown = () => {\n    setDragging(false);\n  };\n\n  // Function to handle slider change\n  const handleSliderChange = event => {\n    const newValue = event.target.value;\n    setSliderValue(newValue);\n    sliderValueRef.current = newValue;\n  };\n\n  // Function to start removing an edge\n  const startRemovingEdge = () => {\n    if (algorithmRunning) {\n      return;\n    }\n    if (isRemovingEdge) {\n      setIsRemovingEdge(false);\n      setText(\"\");\n      return;\n    }\n    if (edges.length < 1) {\n      alert(\"must be at least one edge\");\n      return;\n    }\n    setText(\"Click on an edge to remove it\");\n    setIsRemovingEdge(true);\n  };\n\n  // Function to initiate adding an edge\n  const handleAddEdge = () => {\n    if (selectedNode === null) return;\n    if (!isDirected) {\n      if (nodes.length * (nodes.length - 1) / 2 === edges.length) {\n        alert(\"cannot add another edge\");\n        return;\n      }\n    } else {\n      if (nodes.length * (nodes.length - 1) === edges.length) {\n        alert(\"cannot add another edge\");\n        return;\n      }\n    }\n    if (nodes.length < 2) {\n      alert(\"You need at least two nodes to add an edge.\");\n      return;\n    }\n    setIsAddingEdge(true);\n    setText(\"Click another node to add edge\");\n  };\n\n  // Function to handle clicking on an edge\n  const handleEdgeClick = edge => {\n    if (isRemovingEdge) {\n      setEdges(edges.filter(e => e !== edge));\n      setIsRemovingEdge(false);\n      setAdjList(prevAdjList => {\n        const newAdjList = {\n          ...prevAdjList\n        };\n        newAdjList[edge.from.id] = newAdjList[edge.from.id].filter(id => id !== edge.to.id);\n        newAdjList[edge.to.id] = newAdjList[edge.to.id].filter(id => id !== edge.from.id);\n        return newAdjList;\n      });\n      setText(startingText);\n    }\n  };\n\n  // Function to handle dragging a node\n  const handleDrag = (e, data, node) => {\n    setDragging(true);\n    node.x = data.x;\n    node.y = data.y;\n    setNodes([...nodes]);\n  };\n\n  // Function to handle stopping the drag of a node\n  const handleDragStop = () => {\n    setTimeout(() => {\n      setDragging(false);\n    }, 0);\n  };\n  return {\n    addNode,\n    generateGraph,\n    resetGraph,\n    removeNode,\n    handleNodeClick,\n    handleMouseDown,\n    handleSliderChange,\n    startRemovingEdge,\n    handleAddEdge,\n    handleEdgeClick,\n    handleDrag,\n    handleDragStop\n  };\n};\n_s(useNodeFunctions, \"83iYA3bSyVH2gXQhMpnpfVpAO88=\", false, function () {\n  return [useGraphStates];\n});","map":{"version":3,"names":["useGraphStates","useNodeFunctions","_s","nodes","edges","isStepMode","isPaused","setClickedTraveral","setClickedMST","setText","setClickedPaths","setIsStepMode","isPausedRef","currentStepRef","isStepModeRef","setCurrentStep","runningAlgorithm","componentColors","setEdges","algorithmRunning","isRemovingEdge","setAdjList","GraphsProvider","setAlgorithmRunning","selectedNode","isDirected","setIsPaused","startNode","reoveNode","setIsDirected","setShowWeights","showWeights","algorithmStarted","disablePause","sliderValue","calculateMidpoint","calculateAngle","visitedEdges","calculateEdgeLength","isTSP","isBFS","isDFS","isPrim","isShortestPath","currentNode","visitedNodes","components","text","clickedTraversal","clickedMST","clickedPaths","animateKruskalsAlgorithm","startPrim","startDFS","startBFS","startShortestPath","startTSP","graphColoring","findConnectedComponents","findStrongComponents","addNode","console","log","length","alert","startingText","newNode","id","nodeCount","x","Math","random","y","setNodes","prevAdjList","setNodeCount","generateGraph","numNodes","numEdges","response","prompt","isNaN","setVisitedNodes","setVisitedEdges","setSelectedNode","newNodes","newEdges","newAdjList","gridSize","ceil","sqrt","areaWidth","areaHeight","margin","gridSpacingX","gridSpacingY","i","row","floor","col","push","from","to","edgeExists","some","edge","newEdge","color","defaultEdgeColor","resetGraph","setIsRemovingEdge","removeNode","filter","node","key","handleNodeClick","dragging","isAddingEdge","prevEdges","setIsAddingEdge","dfs","setIsDFS","bfs","setIsBFS","setIsPrim","animatePrimsAlgorithm","setStartNode","endNode","setEndNode","findShortestPath","setIsShortestPath","tsp","setIsTSP","handleMouseDown","setDragging","handleSliderChange","event","newValue","target","value","setSliderValue","sliderValueRef","current","startRemovingEdge","handleAddEdge","handleEdgeClick","e","handleDrag","data","handleDragStop","setTimeout"],"sources":["/Users/tani/Desktop/visualizer/Visusalizer Project/src/Components/NodeFunctions.js"],"sourcesContent":["import { useGraphStates } from './GraphsContext';\n\nexport const useNodeFunctions = () => {\n\n    const {\n        nodes, edges, isStepMode, isPaused, setClickedTraveral, setClickedMST, setText, setClickedPaths,\n        setIsStepMode, isPausedRef, currentStepRef, isStepModeRef, setCurrentStep, runningAlgorithm, \n        componentColors, setEdges, algorithmRunning, isRemovingEdge, setAdjList, GraphsProvider, setAlgorithmRunning,\n        selectedNode, isDirected, setIsPaused, startNode, reoveNode, setIsDirected,\n        setShowWeights, showWeights, algorithmStarted, disablePause, sliderValue,\n        calculateMidpoint, calculateAngle, visitedEdges, calculateEdgeLength,\n         isTSP, isBFS, isDFS, isPrim, isShortestPath, currentNode, visitedNodes, components, text, clickedTraversal,\n        clickedMST, clickedPaths,animateKruskalsAlgorithm, startPrim, startDFS, startBFS, startShortestPath, startTSP, graphColoring,\n        findConnectedComponents, findStrongComponents\n    } = useGraphStates();\n\n\n    // Function to add a new node to the graph\n    const addNode = () => {\n        console.log(\"here\");\n        if(algorithmRunning){\n            return;\n        }\n\n        if(nodes.length >= 20){\n            alert(\"too many nodes\");\n            return;\n        }\n\n        setText(startingText);\n        const newNode = {\n            id: nodeCount,\n            x: Math.random() * 480,\n            y: Math.random() * 480,\n        };\n        setNodes([...nodes, newNode]);\n        setAdjList(prevAdjList => ({ ...prevAdjList, [newNode.id]: [] }));\n        setNodeCount(nodeCount + 1);\n    };\n\n    // Function to generate a random graph\n    const generateGraph = () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n\n        var numNodes = 0;\n        var numEdges = -1;\n\n        do{\n            const response = prompt(\"Enter the number of nodes for the graph:\", \"\");\n            if(response === null){\n                return;\n            }\n            if(isNaN(response)){\n                alert(\"Invalid input. Please enter numbers only\");\n                continue;\n            }\n\n            if(response <= 0 || response > 20){\n                alert(\"Invalid input. Number of nodes must be between 1 and 20\");\n                continue;\n            }\n\n            numNodes = response;\n\n        }while(numNodes === 0);\n\n        do{\n            const response = prompt(\"Enter the number of edges for the graph:\", \"\");\n            if(response === null){\n                return;\n            }\n\n            if(isNaN(response)){\n                alert(\"Invalid input. Please enter numbers only\");\n                continue;\n            }\n\n            if(!isDirected){\n                if(response > ((numNodes * (numNodes - 1)) / 2)){\n                    alert(\"Invalid input. Too many edges for the undirected graph\");\n                    continue;\n                }\n            }else{\n                if(response > ((numNodes * (numNodes - 1)))){\n                    alert(\"Invalid input. Too many edges for the directed graph\");\n                    continue;\n                }\n            }\n            \n            if(response < 0){\n                alert(\"Invalid input. Not enough edges\");\n                continue;\n            }\n\n            numEdges = response;\n\n        }while(numEdges === -1);\n\n        setNodes([]);\n        setEdges([]);\n        setAdjList({});\n        setNodeCount(0);\n        setVisitedNodes([]);\n        setVisitedEdges([]);\n        setSelectedNode(null);\n        setText(startingText);\n\n        const newNodes = [];\n        const newEdges = [];\n        const newAdjList = {};\n\n\n        const gridSize = Math.ceil(Math.sqrt(numNodes));\n        const areaWidth = 500; \n        const areaHeight = 500; \n        const margin = 10;\n        const gridSpacingX = (areaWidth - 2 * margin) / gridSize;\n        const gridSpacingY = (areaHeight - 2 * margin) / gridSize;\n\n        for (let i = 0; i < numNodes; i++) {\n            const row = Math.floor(i / gridSize);\n            const col = i % gridSize;\n            const x = margin + col * gridSpacingX + Math.random() * gridSpacingX * 0.9;\n            const y = margin + row * gridSpacingY + Math.random() * gridSpacingY * 0.9;\n\n            const newNode = {\n                id: i,\n                x: x,\n                y: y,\n            };\n            newNodes.push(newNode);\n            newAdjList[i] = [];\n        }\n\n        while (newEdges.length < numEdges) {\n            const from = newNodes[Math.floor(Math.random() * numNodes)];\n            const to = newNodes[Math.floor(Math.random() * numNodes)];\n            if (from.id !== to.id) {\n                const edgeExists = newEdges.some(edge => \n                    (edge.from.id === from.id && edge.to.id === to.id) ||\n                    (!isDirected && edge.from.id === to.id && edge.to.id === from.id)\n                );\n                if (!edgeExists) {\n                    const newEdge = { from, to, color: defaultEdgeColor };\n                    newEdges.push(newEdge);\n                    newAdjList[from.id].push(to.id);\n                    if(!isDirected){\n                        newAdjList[to.id].push(from.id);\n                    }\n                }\n            }\n        }\n\n        setNodes(newNodes);\n        setEdges(newEdges);\n        setAdjList(newAdjList);\n        setNodeCount(newNodes.length);\n    };\n\n    // Function to reset the graph\n    const resetGraph = () => {\n        if(algorithmRunning){\n            return;\n        }\n        setNodes([]);\n        setEdges([]);\n        setClickedMST(false);\n        setClickedTraveral(false);\n        setIsRemovingEdge(false);\n        setText(startingText);\n    };\n\n    // Function to remove a selected node form the graph\n    const removeNode = () => {\n        if (selectedNode == null) return;\n\n        setNodes(nodes.filter(node => node.id !== selectedNode.id));\n        setEdges(edges.filter(edge => edge.from.id !== selectedNode.id && edge.to.id !== selectedNode.id));\n        setAdjList(prevAdjList => {\n            const newAdjList = { ...prevAdjList };\n            delete newAdjList[selectedNode.id];\n            for (const key in newAdjList) {\n                newAdjList[key] = newAdjList[key].filter(id => id !== selectedNode.id);\n            }\n            return newAdjList;\n        });\n        setSelectedNode(null);\n    };\n\n    // Function to handle clicking on a node\n    const handleNodeClick = (node) => {\n        if (dragging) {\n            return;\n        }\n\n        if (isAddingEdge) {\n            if (selectedNode && selectedNode.id !== node.id) {\n                const edgeExists = edges.some(edge =>\n                    (edge.from.id === selectedNode.id && edge.to.id === node.id) ||\n                    (!isDirected && edge.from.id === node.id && edge.to.id === selectedNode.id)\n                );\n\n                if(!edgeExists){\n                    const newEdge = { from: selectedNode, to: node, color: defaultEdgeColor };\n                    setEdges(prevEdges => [...prevEdges, newEdge]);\n\n                    setAdjList(prevAdjList => {\n                        const newAdjList = { ...prevAdjList };\n                        if (!newAdjList[selectedNode.id]) newAdjList[selectedNode.id] = [];\n                        if (!newAdjList[node.id]) newAdjList[node.id] = [];\n                        newAdjList[selectedNode.id].push(node.id);\n                        if (!isDirected) {\n                            newAdjList[node.id].push(selectedNode.id);\n                        }\n                        return newAdjList;\n                    })\n                }\n                \n                setIsAddingEdge(false);\n                setSelectedNode(null);\n            } else if (selectedNode && selectedNode.id === node.id) {\n                setSelectedNode(null);\n                setIsAddingEdge(false);\n            }\n            setText(startingText);\n        } else if(isDFS){\n            setVisitedNodes([]);\n            setVisitedEdges([]);\n            dfs(node);\n            setIsDFS(false);\n        } else if(isBFS){\n            setVisitedNodes([]);\n            setVisitedEdges([]);\n            bfs(node);\n            setIsBFS(false);\n        }else if(isPrim){\n            setIsPrim(false);\n            animatePrimsAlgorithm(node);\n        }else if(isShortestPath){\n            if(!startNode){\n                setStartNode(node);\n                setText(\"Select End Node for Shortest Path\");\n            }else if(!endNode){\n                setEndNode(node);\n                setText(\"Finding Shortest Path...\");\n                findShortestPath(startNode, node);\n                setIsShortestPath(false);\n            }\n        }else if(isTSP){\n            setVisitedNodes([]);\n            setVisitedEdges([]);\n            tsp(node);\n            setIsTSP(false);\n        }else{\n            if (selectedNode && selectedNode.id === node.id) {\n                setSelectedNode(null); \n                setText(startingText);\n            } else {\n                if(!algorithmRunning){\n                    setSelectedNode(node);\n                }\n                \n            }\n        }\n    }\n\n    // Function to handle mouse down event for dragging\n    const handleMouseDown = () => {\n        setDragging(false);\n    };\n\n    // Function to handle slider change\n    const handleSliderChange = (event) => {\n        const newValue = event.target.value;\n        setSliderValue(newValue);\n        sliderValueRef.current = newValue;\n    }\n\n    // Function to start removing an edge\n    const startRemovingEdge = () => {\n        if(algorithmRunning){\n            return;\n        }\n\n        if(isRemovingEdge){\n            setIsRemovingEdge(false);\n            setText(\"\");\n            return;\n        }\n\n        if(edges.length < 1){\n            alert(\"must be at least one edge\");\n            return;\n        }\n        setText(\"Click on an edge to remove it\");\n        setIsRemovingEdge(true);\n    }\n\n    // Function to initiate adding an edge\n    const handleAddEdge = () => {\n        if (selectedNode === null) return;\n\n        if(!isDirected){\n            if(((nodes.length * (nodes.length - 1)) / 2) === edges.length){\n                alert(\"cannot add another edge\");\n                return;\n            }\n        }else{\n            if(((nodes.length * (nodes.length - 1))) === edges.length){\n                alert(\"cannot add another edge\");\n                return;\n            }\n        }\n        \n\n        if (nodes.length < 2) {\n            alert(\"You need at least two nodes to add an edge.\");\n            return;\n        }\n        setIsAddingEdge(true);\n        setText(\"Click another node to add edge\");\n    };\n\n    // Function to handle clicking on an edge\n    const handleEdgeClick = (edge) => {\n        if (isRemovingEdge) {\n            setEdges(edges.filter(e => e !== edge));\n            setIsRemovingEdge(false);\n\n            setAdjList(prevAdjList => {\n                const newAdjList = { ...prevAdjList };\n                newAdjList[edge.from.id] = newAdjList[edge.from.id].filter(id => id !== edge.to.id);\n                newAdjList[edge.to.id] = newAdjList[edge.to.id].filter(id => id !== edge.from.id);\n                return newAdjList;\n            });\n            setText(startingText);\n        }\n    }\n\n    // Function to handle dragging a node\n    const handleDrag = (e, data, node) => {\n        setDragging(true);\n        node.x = data.x;\n        node.y = data.y;\n        setNodes([...nodes]);\n    };\n\n    // Function to handle stopping the drag of a node\n    const handleDragStop = () => {\n        setTimeout(() => {\n            setDragging(false);\n        }, 0);\n    };\n\n    return {addNode, generateGraph, resetGraph, removeNode, handleNodeClick, handleMouseDown, handleSliderChange, startRemovingEdge, handleAddEdge, handleEdgeClick, handleDrag, handleDragStop};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}