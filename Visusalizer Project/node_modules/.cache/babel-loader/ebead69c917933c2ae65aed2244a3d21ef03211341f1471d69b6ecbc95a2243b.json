{"ast":null,"code":"import { useGraphStates } from './Graphs';\nconst {\n  nodes,\n  setNodes,\n  edges,\n  setEdges,\n  selectedNode,\n  setSelectedNode,\n  adjList,\n  setAdjList,\n  startingText,\n  setText,\n  isDirected,\n  nodeCount,\n  setNodeCount\n} = useGraphStates();\n\n// Function to add a new node to the graph\nexport const addNode = (nodes, setNodes, nodeCount, setNodeCount, adjList, setAdjList, startingText, setText) => {\n  if (algorithmRunning) {\n    return;\n  }\n  if (nodes.length >= 20) {\n    alert(\"too many nodes\");\n    return;\n  }\n  setText(startingText);\n  const newNode = {\n    id: nodeCount,\n    x: Math.random() * 480,\n    y: Math.random() * 480\n  };\n  setNodes([...nodes, newNode]);\n  setAdjList(prevAdjList => ({\n    ...prevAdjList,\n    [newNode.id]: []\n  }));\n  setNodeCount(nodeCount + 1);\n};\n\n// Function to generate a random graph\nexport const generateGraph = () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  var numNodes = 0;\n  var numEdges = -1;\n  do {\n    const response = prompt(\"Enter the number of nodes for the graph:\", \"\");\n    if (response === null) {\n      return;\n    }\n    if (isNaN(response)) {\n      alert(\"Invalid input. Please enter numbers only\");\n      continue;\n    }\n    if (response <= 0 || response > 20) {\n      alert(\"Invalid input. Number of nodes must be between 1 and 20\");\n      continue;\n    }\n    numNodes = response;\n  } while (numNodes === 0);\n  do {\n    const response = prompt(\"Enter the number of edges for the graph:\", \"\");\n    if (response === null) {\n      return;\n    }\n    if (isNaN(response)) {\n      alert(\"Invalid input. Please enter numbers only\");\n      continue;\n    }\n    if (!isDirected) {\n      if (response > numNodes * (numNodes - 1) / 2) {\n        alert(\"Invalid input. Too many edges for the undirected graph\");\n        continue;\n      }\n    } else {\n      if (response > numNodes * (numNodes - 1)) {\n        alert(\"Invalid input. Too many edges for the directed graph\");\n        continue;\n      }\n    }\n    if (response < 0) {\n      alert(\"Invalid input. Not enough edges\");\n      continue;\n    }\n    numEdges = response;\n  } while (numEdges === -1);\n  setNodes([]);\n  setEdges([]);\n  setAdjList({});\n  setNodeCount(0);\n  setVisitedNodes([]);\n  setVisitedEdges([]);\n  setSelectedNode(null);\n  setText(startingText);\n  const newNodes = [];\n  const newEdges = [];\n  const newAdjList = {};\n  const gridSize = Math.ceil(Math.sqrt(numNodes));\n  const areaWidth = 500;\n  const areaHeight = 500;\n  const margin = 10;\n  const gridSpacingX = (areaWidth - 2 * margin) / gridSize;\n  const gridSpacingY = (areaHeight - 2 * margin) / gridSize;\n  for (let i = 0; i < numNodes; i++) {\n    const row = Math.floor(i / gridSize);\n    const col = i % gridSize;\n    const x = margin + col * gridSpacingX + Math.random() * gridSpacingX * 0.9;\n    const y = margin + row * gridSpacingY + Math.random() * gridSpacingY * 0.9;\n    const newNode = {\n      id: i,\n      x: x,\n      y: y\n    };\n    newNodes.push(newNode);\n    newAdjList[i] = [];\n  }\n  while (newEdges.length < numEdges) {\n    const from = newNodes[Math.floor(Math.random() * numNodes)];\n    const to = newNodes[Math.floor(Math.random() * numNodes)];\n    if (from.id !== to.id) {\n      const edgeExists = newEdges.some(edge => edge.from.id === from.id && edge.to.id === to.id || !isDirected && edge.from.id === to.id && edge.to.id === from.id);\n      if (!edgeExists) {\n        const newEdge = {\n          from,\n          to,\n          color: defaultEdgeColor\n        };\n        newEdges.push(newEdge);\n        newAdjList[from.id].push(to.id);\n        if (!isDirected) {\n          newAdjList[to.id].push(from.id);\n        }\n      }\n    }\n  }\n  setNodes(newNodes);\n  setEdges(newEdges);\n  setAdjList(newAdjList);\n  setNodeCount(newNodes.length);\n};\n\n// Function to reset the graph\nexport const resetGraph = () => {\n  if (algorithmRunning) {\n    return;\n  }\n  setNodes([]);\n  setEdges([]);\n  setClickedMST(false);\n  setClickedTraveral(false);\n  setIsRemovingEdge(false);\n  setText(startingText);\n};\n\n// Function to remove a selected node form the graph\nexport const removeNode = () => {\n  if (selectedNode == null) return;\n  setNodes(nodes.filter(node => node.id !== selectedNode.id));\n  setEdges(edges.filter(edge => edge.from.id !== selectedNode.id && edge.to.id !== selectedNode.id));\n  setAdjList(prevAdjList => {\n    const newAdjList = {\n      ...prevAdjList\n    };\n    delete newAdjList[selectedNode.id];\n    for (const key in newAdjList) {\n      newAdjList[key] = newAdjList[key].filter(id => id !== selectedNode.id);\n    }\n    return newAdjList;\n  });\n  setSelectedNode(null);\n};\n\n// Function to handle clicking on a node\nexport const handleNodeClick = node => {\n  if (dragging) {\n    return;\n  }\n  if (isAddingEdge) {\n    if (selectedNode && selectedNode.id !== node.id) {\n      const edgeExists = edges.some(edge => edge.from.id === selectedNode.id && edge.to.id === node.id || !isDirected && edge.from.id === node.id && edge.to.id === selectedNode.id);\n      if (!edgeExists) {\n        const newEdge = {\n          from: selectedNode,\n          to: node,\n          color: defaultEdgeColor\n        };\n        setEdges(prevEdges => [...prevEdges, newEdge]);\n        setAdjList(prevAdjList => {\n          const newAdjList = {\n            ...prevAdjList\n          };\n          if (!newAdjList[selectedNode.id]) newAdjList[selectedNode.id] = [];\n          if (!newAdjList[node.id]) newAdjList[node.id] = [];\n          newAdjList[selectedNode.id].push(node.id);\n          if (!isDirected) {\n            newAdjList[node.id].push(selectedNode.id);\n          }\n          return newAdjList;\n        });\n      }\n      setIsAddingEdge(false);\n      setSelectedNode(null);\n    } else if (selectedNode && selectedNode.id === node.id) {\n      setSelectedNode(null);\n      setIsAddingEdge(false);\n    }\n    setText(startingText);\n  } else if (isDFS) {\n    setVisitedNodes([]);\n    setVisitedEdges([]);\n    dfs(node);\n    setIsDFS(false);\n  } else if (isBFS) {\n    setVisitedNodes([]);\n    setVisitedEdges([]);\n    bfs(node);\n    setIsBFS(false);\n  } else if (isPrim) {\n    setIsPrim(false);\n    animatePrimsAlgorithm(node);\n  } else if (isShortestPath) {\n    if (!startNode) {\n      setStartNode(node);\n      setText(\"Select End Node for Shortest Path\");\n    } else if (!endNode) {\n      setEndNode(node);\n      setText(\"Finding Shortest Path...\");\n      findShortestPath(startNode, node);\n      setIsShortestPath(false);\n    }\n  } else if (isTSP) {\n    setVisitedNodes([]);\n    setVisitedEdges([]);\n    tsp(node);\n    setIsTSP(false);\n  } else {\n    if (selectedNode && selectedNode.id === node.id) {\n      setSelectedNode(null);\n      setText(startingText);\n    } else {\n      if (!algorithmRunning) {\n        setSelectedNode(node);\n      }\n    }\n  }\n};\n\n// Function to handle mouse down event for dragging\nexport const handleMouseDown = () => {\n  setDragging(false);\n};\n\n// Function to handle slider change\nexport const handleSliderChange = event => {\n  const newValue = event.target.value;\n  setSliderValue(newValue);\n  sliderValueRef.current = newValue;\n};\n\n// Function to start removing an edge\nexport const startRemovingEdge = () => {\n  if (algorithmRunning) {\n    return;\n  }\n  if (isRemovingEdge) {\n    setIsRemovingEdge(false);\n    setText(\"\");\n    return;\n  }\n  if (edges.length < 1) {\n    alert(\"must be at least one edge\");\n    return;\n  }\n  setText(\"Click on an edge to remove it\");\n  setIsRemovingEdge(true);\n};\n\n// Function to initiate adding an edge\nexport const handleAddEdge = () => {\n  if (selectedNode === null) return;\n  if (!isDirected) {\n    if (nodes.length * (nodes.length - 1) / 2 === edges.length) {\n      alert(\"cannot add another edge\");\n      return;\n    }\n  } else {\n    if (nodes.length * (nodes.length - 1) === edges.length) {\n      alert(\"cannot add another edge\");\n      return;\n    }\n  }\n  if (nodes.length < 2) {\n    alert(\"You need at least two nodes to add an edge.\");\n    return;\n  }\n  setIsAddingEdge(true);\n  setText(\"Click another node to add edge\");\n};\n\n// Function to handle clicking on an edge\nexport const handleEdgeClick = edge => {\n  if (isRemovingEdge) {\n    setEdges(edges.filter(e => e !== edge));\n    setIsRemovingEdge(false);\n    setAdjList(prevAdjList => {\n      const newAdjList = {\n        ...prevAdjList\n      };\n      newAdjList[edge.from.id] = newAdjList[edge.from.id].filter(id => id !== edge.to.id);\n      newAdjList[edge.to.id] = newAdjList[edge.to.id].filter(id => id !== edge.from.id);\n      return newAdjList;\n    });\n    setText(startingText);\n  }\n};\n\n// Function to handle dragging a node\nexport const handleDrag = (e, data, node) => {\n  setDragging(true);\n  node.x = data.x;\n  node.y = data.y;\n  setNodes([...nodes]);\n};\n\n// Function to handle stopping the drag of a node\nexport const handleDragStop = () => {\n  setTimeout(() => {\n    setDragging(false);\n  }, 0);\n};","map":{"version":3,"names":["useGraphStates","nodes","setNodes","edges","setEdges","selectedNode","setSelectedNode","adjList","setAdjList","startingText","setText","isDirected","nodeCount","setNodeCount","addNode","algorithmRunning","length","alert","newNode","id","x","Math","random","y","prevAdjList","generateGraph","isRemovingEdge","numNodes","numEdges","response","prompt","isNaN","setVisitedNodes","setVisitedEdges","newNodes","newEdges","newAdjList","gridSize","ceil","sqrt","areaWidth","areaHeight","margin","gridSpacingX","gridSpacingY","i","row","floor","col","push","from","to","edgeExists","some","edge","newEdge","color","defaultEdgeColor","resetGraph","setClickedMST","setClickedTraveral","setIsRemovingEdge","removeNode","filter","node","key","handleNodeClick","dragging","isAddingEdge","prevEdges","setIsAddingEdge","isDFS","dfs","setIsDFS","isBFS","bfs","setIsBFS","isPrim","setIsPrim","animatePrimsAlgorithm","isShortestPath","startNode","setStartNode","endNode","setEndNode","findShortestPath","setIsShortestPath","isTSP","tsp","setIsTSP","handleMouseDown","setDragging","handleSliderChange","event","newValue","target","value","setSliderValue","sliderValueRef","current","startRemovingEdge","handleAddEdge","handleEdgeClick","e","handleDrag","data","handleDragStop","setTimeout"],"sources":["/Users/tani/Desktop/visualizer/Visusalizer Project/src/Components/NodeFunctions.js"],"sourcesContent":["import { useGraphStates } from './Graphs';\n\nconst {\n    nodes, setNodes, edges, setEdges, selectedNode, setSelectedNode, adjList, setAdjList, \n    startingText, setText, isDirected, nodeCount, setNodeCount\n} = useGraphStates();\n\n// Function to add a new node to the graph\nexport const addNode = (nodes, setNodes, nodeCount, setNodeCount, adjList, setAdjList, startingText, setText) => {\n    if(algorithmRunning){\n        return;\n    }\n\n    if(nodes.length >= 20){\n        alert(\"too many nodes\");\n        return;\n    }\n\n    setText(startingText);\n    const newNode = {\n        id: nodeCount,\n        x: Math.random() * 480,\n        y: Math.random() * 480,\n    };\n    setNodes([...nodes, newNode]);\n    setAdjList(prevAdjList => ({ ...prevAdjList, [newNode.id]: [] }));\n    setNodeCount(nodeCount + 1);\n};\n\n// Function to generate a random graph\nexport const generateGraph = () => {\n    if(algorithmRunning || isRemovingEdge){\n        return;\n    }\n\n    var numNodes = 0;\n    var numEdges = -1;\n\n    do{\n        const response = prompt(\"Enter the number of nodes for the graph:\", \"\");\n        if(response === null){\n            return;\n        }\n        if(isNaN(response)){\n            alert(\"Invalid input. Please enter numbers only\");\n            continue;\n        }\n\n        if(response <= 0 || response > 20){\n            alert(\"Invalid input. Number of nodes must be between 1 and 20\");\n            continue;\n        }\n\n        numNodes = response;\n\n    }while(numNodes === 0);\n\n    do{\n        const response = prompt(\"Enter the number of edges for the graph:\", \"\");\n        if(response === null){\n            return;\n        }\n\n        if(isNaN(response)){\n            alert(\"Invalid input. Please enter numbers only\");\n            continue;\n        }\n\n        if(!isDirected){\n            if(response > ((numNodes * (numNodes - 1)) / 2)){\n                alert(\"Invalid input. Too many edges for the undirected graph\");\n                continue;\n            }\n        }else{\n            if(response > ((numNodes * (numNodes - 1)))){\n                alert(\"Invalid input. Too many edges for the directed graph\");\n                continue;\n            }\n        }\n        \n        if(response < 0){\n            alert(\"Invalid input. Not enough edges\");\n            continue;\n        }\n\n        numEdges = response;\n\n    }while(numEdges === -1);\n\n    setNodes([]);\n    setEdges([]);\n    setAdjList({});\n    setNodeCount(0);\n    setVisitedNodes([]);\n    setVisitedEdges([]);\n    setSelectedNode(null);\n    setText(startingText);\n\n    const newNodes = [];\n    const newEdges = [];\n    const newAdjList = {};\n\n\n    const gridSize = Math.ceil(Math.sqrt(numNodes));\n    const areaWidth = 500; \n    const areaHeight = 500; \n    const margin = 10;\n    const gridSpacingX = (areaWidth - 2 * margin) / gridSize;\n    const gridSpacingY = (areaHeight - 2 * margin) / gridSize;\n\n    for (let i = 0; i < numNodes; i++) {\n        const row = Math.floor(i / gridSize);\n        const col = i % gridSize;\n        const x = margin + col * gridSpacingX + Math.random() * gridSpacingX * 0.9;\n        const y = margin + row * gridSpacingY + Math.random() * gridSpacingY * 0.9;\n\n        const newNode = {\n            id: i,\n            x: x,\n            y: y,\n        };\n        newNodes.push(newNode);\n        newAdjList[i] = [];\n    }\n\n    while (newEdges.length < numEdges) {\n        const from = newNodes[Math.floor(Math.random() * numNodes)];\n        const to = newNodes[Math.floor(Math.random() * numNodes)];\n        if (from.id !== to.id) {\n            const edgeExists = newEdges.some(edge => \n                (edge.from.id === from.id && edge.to.id === to.id) ||\n                (!isDirected && edge.from.id === to.id && edge.to.id === from.id)\n            );\n            if (!edgeExists) {\n                const newEdge = { from, to, color: defaultEdgeColor };\n                newEdges.push(newEdge);\n                newAdjList[from.id].push(to.id);\n                if(!isDirected){\n                    newAdjList[to.id].push(from.id);\n                }\n            }\n        }\n    }\n\n    setNodes(newNodes);\n    setEdges(newEdges);\n    setAdjList(newAdjList);\n    setNodeCount(newNodes.length);\n};\n\n// Function to reset the graph\nexport const resetGraph = () => {\n    if(algorithmRunning){\n        return;\n    }\n    setNodes([]);\n    setEdges([]);\n    setClickedMST(false);\n    setClickedTraveral(false);\n    setIsRemovingEdge(false);\n    setText(startingText);\n};\n\n// Function to remove a selected node form the graph\nexport const removeNode = () => {\n    if (selectedNode == null) return;\n\n    setNodes(nodes.filter(node => node.id !== selectedNode.id));\n    setEdges(edges.filter(edge => edge.from.id !== selectedNode.id && edge.to.id !== selectedNode.id));\n    setAdjList(prevAdjList => {\n        const newAdjList = { ...prevAdjList };\n        delete newAdjList[selectedNode.id];\n        for (const key in newAdjList) {\n            newAdjList[key] = newAdjList[key].filter(id => id !== selectedNode.id);\n        }\n        return newAdjList;\n    });\n    setSelectedNode(null);\n};\n\n// Function to handle clicking on a node\nexport const handleNodeClick = (node) => {\n    if (dragging) {\n        return;\n    }\n\n    if (isAddingEdge) {\n        if (selectedNode && selectedNode.id !== node.id) {\n            const edgeExists = edges.some(edge =>\n                (edge.from.id === selectedNode.id && edge.to.id === node.id) ||\n                (!isDirected && edge.from.id === node.id && edge.to.id === selectedNode.id)\n            );\n\n            if(!edgeExists){\n                const newEdge = { from: selectedNode, to: node, color: defaultEdgeColor };\n                setEdges(prevEdges => [...prevEdges, newEdge]);\n\n                setAdjList(prevAdjList => {\n                    const newAdjList = { ...prevAdjList };\n                    if (!newAdjList[selectedNode.id]) newAdjList[selectedNode.id] = [];\n                    if (!newAdjList[node.id]) newAdjList[node.id] = [];\n                    newAdjList[selectedNode.id].push(node.id);\n                    if (!isDirected) {\n                        newAdjList[node.id].push(selectedNode.id);\n                    }\n                    return newAdjList;\n                })\n            }\n            \n            setIsAddingEdge(false);\n            setSelectedNode(null);\n        } else if (selectedNode && selectedNode.id === node.id) {\n            setSelectedNode(null);\n            setIsAddingEdge(false);\n        }\n        setText(startingText);\n    } else if(isDFS){\n        setVisitedNodes([]);\n        setVisitedEdges([]);\n        dfs(node);\n        setIsDFS(false);\n    } else if(isBFS){\n        setVisitedNodes([]);\n        setVisitedEdges([]);\n        bfs(node);\n        setIsBFS(false);\n    }else if(isPrim){\n        setIsPrim(false);\n        animatePrimsAlgorithm(node);\n    }else if(isShortestPath){\n        if(!startNode){\n            setStartNode(node);\n            setText(\"Select End Node for Shortest Path\");\n        }else if(!endNode){\n            setEndNode(node);\n            setText(\"Finding Shortest Path...\");\n            findShortestPath(startNode, node);\n            setIsShortestPath(false);\n        }\n    }else if(isTSP){\n        setVisitedNodes([]);\n        setVisitedEdges([]);\n        tsp(node);\n        setIsTSP(false);\n    }else{\n        if (selectedNode && selectedNode.id === node.id) {\n            setSelectedNode(null); \n            setText(startingText);\n        } else {\n            if(!algorithmRunning){\n                setSelectedNode(node);\n            }\n            \n        }\n    }\n}\n\n// Function to handle mouse down event for dragging\nexport const handleMouseDown = () => {\n    setDragging(false);\n};\n\n// Function to handle slider change\nexport const handleSliderChange = (event) => {\n    const newValue = event.target.value;\n    setSliderValue(newValue);\n    sliderValueRef.current = newValue;\n}\n\n// Function to start removing an edge\nexport const startRemovingEdge = () => {\n    if(algorithmRunning){\n        return;\n    }\n\n    if(isRemovingEdge){\n        setIsRemovingEdge(false);\n        setText(\"\");\n        return;\n    }\n\n    if(edges.length < 1){\n        alert(\"must be at least one edge\");\n        return;\n    }\n    setText(\"Click on an edge to remove it\");\n    setIsRemovingEdge(true);\n}\n\n// Function to initiate adding an edge\nexport const handleAddEdge = () => {\n    if (selectedNode === null) return;\n\n    if(!isDirected){\n        if(((nodes.length * (nodes.length - 1)) / 2) === edges.length){\n            alert(\"cannot add another edge\");\n            return;\n        }\n    }else{\n        if(((nodes.length * (nodes.length - 1))) === edges.length){\n            alert(\"cannot add another edge\");\n            return;\n        }\n    }\n    \n\n    if (nodes.length < 2) {\n        alert(\"You need at least two nodes to add an edge.\");\n        return;\n    }\n    setIsAddingEdge(true);\n    setText(\"Click another node to add edge\");\n};\n\n// Function to handle clicking on an edge\nexport const handleEdgeClick = (edge) => {\n    if (isRemovingEdge) {\n        setEdges(edges.filter(e => e !== edge));\n        setIsRemovingEdge(false);\n\n        setAdjList(prevAdjList => {\n            const newAdjList = { ...prevAdjList };\n            newAdjList[edge.from.id] = newAdjList[edge.from.id].filter(id => id !== edge.to.id);\n            newAdjList[edge.to.id] = newAdjList[edge.to.id].filter(id => id !== edge.from.id);\n            return newAdjList;\n        });\n        setText(startingText);\n    }\n}\n\n// Function to handle dragging a node\nexport const handleDrag = (e, data, node) => {\n    setDragging(true);\n    node.x = data.x;\n    node.y = data.y;\n    setNodes([...nodes]);\n};\n\n// Function to handle stopping the drag of a node\nexport const handleDragStop = () => {\n    setTimeout(() => {\n        setDragging(false);\n    }, 0);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}