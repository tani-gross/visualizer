{"ast":null,"code":"var _s = $RefreshSig$();\nimport { sleep } from './GraphUtilities';\nimport UnionFind from './UnionFind';\nimport { useGraphStates } from './Graphs';\n\n// Function to start DFS\nexport const startDFS = () => {\n  _s();\n  const {\n    nodes,\n    edges,\n    adjList,\n    setVisitedNodes,\n    setVisitedEdges,\n    setAlgorithmStarted,\n    setText,\n    resetEdges,\n    setCurrentNode,\n    isPausedRef,\n    currentStepRef,\n    isStepModeRef,\n    sliderValueRef,\n    totalSliderCount,\n    componentColors,\n    setComponents\n  } = useGraphStates();\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setRunningAlgorithm(\"DFS\");\n  setIsDFS(true);\n  setAlgorithmRunning(true);\n  setText(\"Select Node to begin DFS\");\n};\n\n// DFS implementatoin\n_s(startDFS, \"s3XMzf1yww9A9wBrKRuDt0o9fPk=\", false, function () {\n  return [useGraphStates];\n});\nexport const dfs = async () => {\n  setAlgorithmStarted(true);\n  setText(\"DFS in progress...\");\n  const visitedNodeSet = new Set();\n  const visitedEdgeSet = new Set();\n  let stepIndex = 0;\n  const dfsRecursive = async currentNode => {\n    if (visitedNodeSet.has(currentNode.id)) {\n      return;\n    }\n    visitedNodeSet.add(currentNode.id);\n    setVisitedNodes(prev => {\n      const updatedNodes = [...prev, {\n        id: currentNode.id,\n        color: treeEdgeColor\n      }];\n      return updatedNodes;\n    });\n    for (let neighborId of adjList[currentNode.id]) {\n      setCurrentNode(currentNode);\n      const neighborNode = nodes.find(node => node.id === neighborId);\n      const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n      if (!edge) {\n        continue;\n      }\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n      if (!visitedEdgeSet.has(edge)) {\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      }\n      if (!visitedNodeSet.has(neighborId)) {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: treeEdgeColor\n        }]);\n        visitedEdgeSet.add(edge);\n        await dfsRecursive(neighborNode);\n      } else {\n        setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n      }\n    }\n  };\n  await dfsRecursive(startNode);\n  setCurrentNode(null);\n  setAlgorithmStarted(false);\n  setText(\"DFS Done!\");\n  setTimeout(resetEdges, 1000);\n};\n\n// Function to start BFS\nexport const startBFS = () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setRunningAlgorithm(\"BFS\");\n  setIsBFS(true);\n  setAlgorithmRunning(true);\n  setText(\"Select Node to begin BFS\");\n};\n\n// BFS implementation\nexport const bfs = async startNode => {\n  setAlgorithmStarted(true);\n  setText(\"BFS in progress...\");\n  const visitedNodeSet = new Set();\n  const visitedEdgeSet = new Set();\n  let stepIndex = 0;\n  const queue = [startNode];\n  visitedNodeSet.add(startNode.id);\n  setVisitedNodes([{\n    id: startNode.id,\n    color: treeEdgeColor\n  }]);\n  while (queue.length > 0) {\n    const currentNode = queue.shift();\n    setCurrentNode(currentNode);\n    for (let neighborId of adjList[currentNode.id]) {\n      const neighborNode = nodes.find(node => node.id === neighborId);\n      const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n      if (!edge) {\n        continue;\n      }\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n      if (!visitedEdgeSet.has(edge)) {\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      }\n      if (!visitedNodeSet.has(neighborId)) {\n        visitedNodeSet.add(neighborId);\n        queue.push(neighborNode);\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: treeEdgeColor\n        }]);\n        setVisitedNodes(prev => [...prev, {\n          id: neighborId,\n          color: treeEdgeColor\n        }]);\n      } else {\n        setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n      }\n    }\n  }\n  setCurrentNode(null);\n  setAlgorithmStarted(false);\n  setText(\"BFS Done!\");\n  setTimeout(resetEdges, 1000);\n};\n\n// Function to start Prim's algorithm\nexport const startPrim = () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setRunningAlgorithm(\"Prim\");\n  setIsPrim(true);\n  setAlgorithmRunning(true);\n  setText(\"Select Node to begin Prim's Algorithm\");\n};\n\n// Function to animate Prim's algorithm\nexport const animatePrimsAlgorithm = async startNode => {\n  setAlgorithmStarted(true);\n  setIsDirected(false);\n  setText(\"Prim's Algorithm in progress...\");\n  const visitedNodeSet = new Set();\n  const edgeQueue = [];\n  let stepIndex = 0;\n  const addEdges = node => {\n    visitedNodeSet.add(node.id);\n    setVisitedNodes(prev => [...prev, {\n      id: node.id,\n      color: treeEdgeColor\n    }]);\n    (adjList[node.id] || []).forEach(neighborId => {\n      if (!visitedNodeSet.has(neighborId)) {\n        const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === node.id);\n        if (edge) {\n          edgeQueue.push({\n            ...edge,\n            length: calculateEdgeLength(edge)\n          });\n        }\n      }\n    });\n    edgeQueue.sort((a, b) => a.length - b.length);\n  };\n  const animateStep = async () => {\n    if (visitedNodeSet.size === nodes.length || edgeQueue.length === 0) {\n      setAlgorithmStarted(false);\n      setText(\"Prim's Algorithm Done!\");\n      setTimeout(resetEdges, 1000);\n      return;\n    }\n    const edgesToHighlight = edgeQueue.slice(0, 1);\n    edgesToHighlight.forEach(edge => {\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n    });\n    stepIndex++;\n    if (isPausedRef.current) {\n      await new Promise(resolve => {\n        const checkStep = () => {\n          if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n            resolve();\n          } else {\n            setTimeout(checkStep, 50);\n          }\n        };\n        checkStep();\n      });\n      if (isStepModeRef.current) {\n        setIsPaused(true);\n        isPausedRef.current = true;\n      }\n    } else {\n      await sleep(totalSliderCount - sliderValueRef.current);\n    }\n    if (isStepModeRef.current) {\n      setIsPaused(true);\n      isPausedRef.current = true;\n    }\n    const edge = edgeQueue.shift();\n    const {\n      from,\n      to\n    } = edge;\n    const fromInMST = visitedNodeSet.has(from.id);\n    const toInMST = visitedNodeSet.has(to.id);\n    if (fromInMST && !toInMST || !fromInMST && toInMST) {\n      setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n        ...edge,\n        color: treeEdgeColor\n      }]);\n      if (fromInMST && !toInMST) {\n        addEdges(to);\n      } else if (!fromInMST && toInMST) {\n        addEdges(from);\n      }\n    } else {\n      setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n        ...edge,\n        color: defaultEdgeColor\n      }]);\n    }\n    animateStep();\n  };\n  addEdges(startNode);\n  animateStep();\n};\n\n// Function to animate Kruskall's algorithm\nexport const animateKruskalsAlgorithm = () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setIsDirected(false);\n  setRunningAlgorithm(\"Kruskall\");\n  setDisablePause(true);\n  setAlgorithmRunning(true);\n  setText(\"Kruskall's Algorithm in progress...\");\n  const sortedEdges = [...edges].sort((a, b) => calculateEdgeLength(a) - calculateEdgeLength(b));\n  let componentIndex = 0;\n  let currentComponentEdges = [];\n  let currentComponentNodes = [];\n  let uf;\n  const visitedNodeSet = new Set();\n  const foundComponents = [];\n  const dfsComponent = (currentNode, component) => {\n    if (visitedNodeSet.has(currentNode.id)) {\n      return;\n    }\n    visitedNodeSet.add(currentNode.id);\n    component.push(currentNode);\n    adjList[currentNode.id].forEach(neighborId => {\n      const neighborNode = nodes.find(node => node.id === neighborId);\n      if (!visitedNodeSet.has(neighborId)) {\n        dfsComponent(neighborNode, component);\n      }\n    });\n  };\n  nodes.forEach(node => {\n    if (!visitedNodeSet.has(node.id)) {\n      const component = [];\n      dfsComponent(node, component);\n      foundComponents.push(component);\n    }\n  });\n  setComponents(foundComponents);\n  const animateComponentMST = component => {\n    uf = new UnionFind(nodeCount);\n    currentComponentEdges = [];\n    currentComponentNodes = component.map(node => node.id);\n    let edgeIndex = 0;\n    const color = componentColors[componentIndex % componentColors.length];\n    const highlightNodesAndEdges = index => {\n      if (index < currentComponentEdges.length) {\n        const {\n          from,\n          to\n        } = currentComponentEdges[index];\n        setVisitedNodes(prev => [...prev, {\n          id: from.id,\n          color\n        }, {\n          id: to.id,\n          color\n        }]);\n        setVisitedEdges(prev => [...prev, currentComponentEdges[index]]);\n        setTimeout(() => highlightNodesAndEdges(index + 1), totalSliderCount - sliderValueRef.current);\n      } else {\n        componentIndex++;\n        if (componentIndex < foundComponents.length) {\n          setTimeout(() => animateComponentMST(foundComponents[componentIndex]), 0);\n        } else {\n          setTimeout(resetEdges, 1000);\n          setText(\"Kruskall's Algorithm Done!\");\n        }\n      }\n    };\n    const animateStep = () => {\n      if (currentComponentEdges.length === component.length - 1 || edgeIndex >= sortedEdges.length) {\n        highlightNodesAndEdges(0);\n        return;\n      }\n      const edge = sortedEdges[edgeIndex];\n      edgeIndex++;\n      if (currentComponentNodes.includes(edge.from.id) && currentComponentNodes.includes(edge.to.id) && uf.find(edge.from.id) !== uf.find(edge.to.id)) {\n        uf.union(edge.from.id, edge.to.id);\n        currentComponentEdges.push({\n          ...edge,\n          color\n        });\n      }\n      animateStep();\n    };\n    animateStep();\n  };\n  if (foundComponents.length > 0) {\n    animateComponentMST(foundComponents[0]);\n  } else {\n    console.log(\"No components found.\");\n    setAlgorithmRunning(false);\n  }\n};\n\n// Function to start shortest path algorithm\nexport const startShortestPath = () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setRunningAlgorithm(\"SP\");\n  setIsShortestPath(true);\n  setAlgorithmRunning(true);\n  setText(\"Select Start Node for Shortest Path\");\n};\n\n// Function to find the shortest path between two nodes\nexport const findShortestPath = async (startNode, targetNode) => {\n  setAlgorithmStarted(true);\n  setText(\"Shortest Path Algorithm in progress...\");\n  const dist = {};\n  const prev = {};\n  const visitedEdgeSet = new Set();\n  const visitedNodeSet = new Set();\n  const priorityQueue = new Set(nodes.map(node => node.id));\n  let stepIndex = 0;\n  nodes.forEach(node => {\n    dist[node.id] = Infinity;\n    prev[node.id] = null;\n  });\n  dist[startNode.id] = 0;\n  const getMinDistNode = () => {\n    let minNode = null;\n    priorityQueue.forEach(nodeId => {\n      if (minNode === null || dist[nodeId] < dist[minNode]) {\n        minNode = nodeId;\n      }\n    });\n    return minNode;\n  };\n  while (priorityQueue.size > 0) {\n    const currentNodeId = getMinDistNode();\n    const currentNode = nodes.find(node => node.id === currentNodeId);\n    if (dist[currentNodeId] === Infinity) break;\n    priorityQueue.delete(currentNodeId);\n    if (currentNodeId === targetNode.id) {\n      break;\n    }\n    for (let neighborId of adjList[currentNode.id]) {\n      const neighborNode = nodes.find(node => node.id === neighborId);\n      const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n      if (!edge) {\n        continue;\n      }\n      setCurrentNode(currentNode);\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n      if (!visitedEdgeSet.has(edge)) {\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n        visitedEdgeSet.add(edge);\n      }\n      const alt = dist[currentNode.id] + calculateEdgeLength(edge);\n      if (alt < dist[neighborId]) {\n        dist[neighborId] = alt;\n        prev[neighborId] = currentNode.id;\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: treeEdgeColor\n        }]);\n        visitedEdgeSet.add(edge);\n      } else {\n        setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color === currentEdgeColor)));\n      }\n    }\n    visitedNodeSet.add(currentNode.id);\n    setVisitedNodes(prev => {\n      const updatedNodes = [...prev, {\n        id: currentNode.id,\n        color: treeEdgeColor\n      }];\n      return updatedNodes;\n    });\n  }\n  setStartNode(null);\n  setEndNode(null);\n  setAlgorithmStarted(false);\n  setCurrentNode(null);\n  setText(\"Shortest Path Done!\");\n  const path = [];\n  let currentNodeId = targetNode.id;\n  while (currentNodeId !== null) {\n    path.unshift(currentNodeId);\n    currentNodeId = prev[currentNodeId];\n  }\n  if (path.length === 1) {\n    setText(\"No path Found!\");\n    setTimeout(resetEdges, 1000);\n    return;\n  }\n  setVisitedEdges(prev => {\n    return prev.map(e => {\n      if (path.includes(e.from.id) && path.includes(e.to.id)) {\n        return {\n          ...e,\n          color: treeEdgeColor\n        };\n      } else {\n        return {\n          ...e,\n          color: defaultEdgeColor\n        };\n      }\n    });\n  });\n  setVisitedNodes(prev => {\n    return nodes.map(node => {\n      if (path.includes(node.id)) {\n        return {\n          id: node.id,\n          color: treeEdgeColor\n        };\n      } else {\n        return {\n          id: node.id,\n          color: \"black\"\n        };\n      }\n    });\n  });\n  setTimeout(resetEdges, 1000);\n};\n\n// Function to start TSP\nexport const startTSP = async () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setRunningAlgorithm(\"TSP\");\n  setIsTSP(true);\n  setAlgorithmRunning(true);\n  setText(\"Select Node to begin TSP\");\n};\n\n// Function to animate TSP\nexport const tsp = async node => {\n  setAlgorithmStarted(true);\n  setText(\"TSP in progress...\");\n  const startNode = node;\n  const unvisited = new Set(nodes.map(node => node.id));\n  const visited = [];\n  const stack = [];\n  let currentNode = startNode;\n  let stepIndex = 0;\n  unvisited.delete(currentNode.id);\n  visited.push(currentNode);\n  setVisitedNodes([{\n    id: currentNode.id,\n    color: treeEdgeColor\n  }]);\n  while (unvisited.size > 0) {\n    let nearestNode = null;\n    let shortestDistance = Infinity;\n    let currentEdge = null;\n    for (let neighborId of unvisited) {\n      setCurrentNode(currentNode);\n      const neighborNode = nodes.find(node => node.id === neighborId);\n      // eslint-disable-next-line\n      const edge = edges.find(e => isDirected && e && e.from && e.to && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && e && e.from && e.to && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n      if (!edge) {\n        continue;\n      }\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n      stepIndex++;\n      if (isPausedRef.current) {\n        await new Promise(resolve => {\n          const checkStep = () => {\n            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n              resolve();\n            } else {\n              setTimeout(checkStep, 50);\n            }\n          };\n          checkStep();\n        });\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      } else {\n        await sleep(totalSliderCount - sliderValueRef.current);\n      }\n      if (isStepModeRef.current) {\n        setIsPaused(true);\n        isPausedRef.current = true;\n      }\n      const distance = calculateEdgeLength({\n        from: currentNode,\n        to: neighborNode\n      });\n      setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)));\n      if (distance < shortestDistance) {\n        shortestDistance = distance;\n        nearestNode = neighborNode;\n        currentEdge = edge;\n      }\n    }\n    if (nearestNode && currentEdge) {\n      stack.push({\n        currentNode,\n        nearestNode,\n        shortestDistance\n      });\n      setVisitedEdges(prev => [...prev, {\n        ...currentEdge,\n        color: treeEdgeColor\n      }]);\n      setVisitedNodes(prev => [...prev, {\n        id: nearestNode.id,\n        color: treeEdgeColor\n      }]);\n      stepIndex++;\n      if (isPausedRef.current) {\n        await new Promise(resolve => {\n          const checkStep = () => {\n            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n              resolve();\n            } else {\n              setTimeout(checkStep, 50);\n            }\n          };\n          checkStep();\n        });\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      } else {\n        await sleep(totalSliderCount - sliderValueRef.current);\n      }\n      if (isStepModeRef.current) {\n        setIsPaused(true);\n        isPausedRef.current = true;\n      }\n      currentNode = nearestNode;\n      unvisited.delete(currentNode.id);\n      visited.push(currentNode);\n    } else {\n      const previousState = stack.pop();\n      if (previousState) {\n        currentNode = previousState.currentNode;\n      } else {\n        break;\n      }\n    }\n  }\n  setCurrentNode(null);\n  setAlgorithmStarted(false);\n  setText(\"TSP Done!\");\n  setTimeout(resetEdges, 1000);\n};\n\n// Function to color graph\nexport const graphColoring = async () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setRunningAlgorithm(\"Color\");\n  setDisablePause(true);\n  setAlgorithmRunning(true);\n  setText(\"Graph Coloring in progress...\");\n  const availableColors = componentColors;\n  const colors = {};\n  const colorGraph = node => {\n    const neighborColors = adjList[node.id].map(neighborId => colors[neighborId]);\n    for (let color of availableColors) {\n      if (!neighborColors.includes(color)) {\n        colors[node.id] = color;\n        break;\n      }\n    }\n  };\n  for (let node of nodes) {\n    colorGraph(node);\n    setVisitedNodes(prev => [...prev, {\n      id: node.id,\n      color: colors[node.id]\n    }]);\n    await new Promise(resolve => setTimeout(resolve, totalSliderCount - sliderValueRef.current));\n  }\n  setText(\"Graph Coloring Done!\");\n  setTimeout(resetEdges, 1000);\n};\n\n// Function to find connected components in a graph\nexport const findConnectedComponents = async () => {\n  setRunningAlgorithm(\"Connected\");\n  setAlgorithmStarted(true);\n  setText(\"Connected Components in progress...\");\n  setAlgorithmRunning(true);\n  const visitedNodeSet = new Set();\n  const visitedEdgeSet = new Set();\n  let componentIndex = 0;\n  let stepIndex = 0;\n  const dfsRecursive = async (currentNode, componentColor) => {\n    if (visitedNodeSet.has(currentNode.id)) {\n      return;\n    }\n    visitedNodeSet.add(currentNode.id);\n    setVisitedNodes(prev => {\n      const updatedNodes = [...prev, {\n        id: currentNode.id,\n        color: componentColor\n      }];\n      return updatedNodes;\n    });\n    for (let neighborId of adjList[currentNode.id]) {\n      setCurrentNode(currentNode);\n      const neighborNode = nodes.find(node => node.id === neighborId);\n      const edge = edges.find(e => e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id);\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n      if (!visitedEdgeSet.has(edge)) {\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      }\n      if (!visitedNodeSet.has(neighborId)) {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: componentColor\n        }]);\n        visitedEdgeSet.add(edge);\n        await dfsRecursive(neighborNode, componentColor);\n      } else {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: componentColor\n        }]);\n      }\n    }\n  };\n  for (let node of nodes) {\n    if (!visitedNodeSet.has(node.id)) {\n      const componentColor = componentColors[componentIndex % componentColors.length];\n      componentIndex++;\n      await dfsRecursive(node, componentColor);\n    }\n  }\n  setCurrentNode(null);\n  setAlgorithmStarted(false);\n  setText(\"Connected Components Done!\");\n  setTimeout(resetEdges, 1000);\n};\n\n// Function to find strong components\nexport const findStrongComponents = async () => {\n  setRunningAlgorithm(\"Connected\");\n  setAlgorithmStarted(true);\n  setText(\"Strong Components in progress...\");\n  setAlgorithmRunning(true);\n  const stack = [];\n  const visitedNodeSet = new Set();\n  const visitedEdgeSet = new Set();\n  const reverseAdjList = {};\n  let stepIndex = 0;\n  const dfs1 = async node => {\n    if (visitedNodeSet.has(node.id)) {\n      return;\n    }\n    visitedNodeSet.add(node.id);\n    for (let neighborId of adjList[node.id]) {\n      if (!visitedNodeSet.has(neighborId)) {\n        const neighborNode = nodes.find(n => n.id === neighborId);\n        await dfs1(neighborNode);\n      }\n    }\n    stack.push(node);\n  };\n  const reverseGraph = () => {\n    nodes.forEach(node => {\n      reverseAdjList[node.id] = [];\n    });\n    edges.forEach(edge => {\n      reverseAdjList[edge.to.id].push(edge.from.id);\n    });\n  };\n  const dfs2 = async (node, componentColor) => {\n    if (visitedNodeSet.has(node.id)) {\n      return;\n    }\n    visitedNodeSet.add(node.id);\n    setVisitedNodes(prev => {\n      const updatedNodes = [...prev, {\n        id: node.id,\n        color: componentColor\n      }];\n      return updatedNodes;\n    });\n    for (let neighborId of reverseAdjList[node.id]) {\n      setCurrentNode(node);\n      const neighborNode = nodes.find(n => n.id === neighborId);\n      const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId);\n      if (!edge) {\n        continue;\n      }\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n      if (!visitedEdgeSet.has(edge)) {\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      }\n      if (!visitedNodeSet.has(neighborId)) {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: componentColor\n        }]);\n        visitedEdgeSet.add(edge);\n        await dfs2(neighborNode, componentColor);\n      } else {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: componentColor\n        }]);\n      }\n    }\n  };\n  reverseGraph();\n  for (let node of nodes) {\n    if (!visitedNodeSet.has(node.id)) {\n      await dfs1(node);\n    }\n  }\n  visitedNodeSet.clear();\n  visitedEdgeSet.clear();\n  let componentIndex = 0;\n  while (stack.length > 0) {\n    const node = stack.pop();\n    if (!visitedNodeSet.has(node.id)) {\n      const componentColor = componentColors[componentIndex % componentColors.length];\n      componentIndex++;\n      await dfs2(node, componentColor);\n    }\n  }\n  setCurrentNode(null);\n  setAlgorithmStarted(false);\n  setText(\"Strong Components Done!\");\n  setTimeout(resetEdges, 1000);\n};","map":{"version":3,"names":["sleep","UnionFind","useGraphStates","startDFS","_s","nodes","edges","adjList","setVisitedNodes","setVisitedEdges","setAlgorithmStarted","setText","resetEdges","setCurrentNode","isPausedRef","currentStepRef","isStepModeRef","sliderValueRef","totalSliderCount","componentColors","setComponents","algorithmRunning","isRemovingEdge","setRunningAlgorithm","setIsDFS","setAlgorithmRunning","dfs","visitedNodeSet","Set","visitedEdgeSet","stepIndex","dfsRecursive","currentNode","has","id","add","prev","updatedNodes","color","treeEdgeColor","neighborId","neighborNode","find","node","edge","e","isDirected","from","to","currentEdgeColor","current","Promise","resolve","checkStep","setTimeout","setIsPaused","filter","startNode","startBFS","setIsBFS","bfs","queue","length","shift","push","startPrim","setIsPrim","animatePrimsAlgorithm","setIsDirected","edgeQueue","addEdges","forEach","calculateEdgeLength","sort","a","b","animateStep","size","edgesToHighlight","slice","fromInMST","toInMST","defaultEdgeColor","animateKruskalsAlgorithm","setDisablePause","sortedEdges","componentIndex","currentComponentEdges","currentComponentNodes","uf","foundComponents","dfsComponent","component","animateComponentMST","nodeCount","map","edgeIndex","highlightNodesAndEdges","index","includes","union","console","log","startShortestPath","setIsShortestPath","findShortestPath","targetNode","dist","priorityQueue","Infinity","getMinDistNode","minNode","nodeId","currentNodeId","delete","alt","setStartNode","setEndNode","path","unshift","startTSP","setIsTSP","tsp","unvisited","visited","stack","nearestNode","shortestDistance","currentEdge","distance","previousState","pop","graphColoring","availableColors","colors","colorGraph","neighborColors","findConnectedComponents","componentColor","findStrongComponents","reverseAdjList","dfs1","n","reverseGraph","dfs2","clear"],"sources":["/Users/tani/Desktop/visualizer/Visusalizer Project/src/Components/Algorithms.js"],"sourcesContent":["import {sleep} from './GraphUtilities';\nimport UnionFind from './UnionFind';\nimport { useGraphStates } from './Graphs';\n\n// Function to start DFS\nexport const startDFS = () => {\n    const {\n    nodes, edges, adjList, setVisitedNodes, setVisitedEdges, setAlgorithmStarted, setText, resetEdges,\n    setCurrentNode, isPausedRef, currentStepRef, isStepModeRef, sliderValueRef, totalSliderCount, \n    componentColors, setComponents\n} = useGraphStates();\n    if(algorithmRunning|| isRemovingEdge){\n        return;\n    }\n    setRunningAlgorithm(\"DFS\");\n    setIsDFS(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin DFS\");\n}\n\n// DFS implementatoin\nexport const dfs = async () => {\n    setAlgorithmStarted(true);\n    setText(\"DFS in progress...\");\n\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let stepIndex = 0;\n\n    const dfsRecursive = async (currentNode) => {\n        if (visitedNodeSet.has(currentNode.id)) {\n            return;\n        }\n\n        visitedNodeSet.add(currentNode.id);\n        setVisitedNodes(prev => { \n            const updatedNodes = [...prev, { id: currentNode.id, color: treeEdgeColor }];\n            return updatedNodes;\n        });\n\n        for (let neighborId of adjList[currentNode.id]) {\n            setCurrentNode(currentNode);     \n            const neighborNode = nodes.find(node => node.id === neighborId); \n            const edge = edges.find(e =>                                     \n                (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (e.from.id === neighborId && e.to.id === currentNode.id)))\n            );\n\n            if(!edge){\n                continue;\n            }\n\n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n           \n            if (!visitedEdgeSet.has(edge)) {\n                stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n            }\n\n            if (!visitedNodeSet.has(neighborId)) { \n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: treeEdgeColor }\n                ]);\n                visitedEdgeSet.add(edge);\n\n                await dfsRecursive(neighborNode);\n            } else {\n                setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n            }\n        }\n\n    };\n\n    await dfsRecursive(startNode);\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"DFS Done!\");\n    setTimeout(resetEdges, 1000); \n};\n\n// Function to start BFS\nexport const startBFS = () => {\n    if(algorithmRunning || isRemovingEdge){\n        return;\n    }\n    setRunningAlgorithm(\"BFS\");\n    setIsBFS(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin BFS\");\n}\n\n// BFS implementation\nexport const bfs = async (startNode) => {\n    setAlgorithmStarted(true);\n    setText(\"BFS in progress...\");\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let stepIndex = 0;\n\n\n    const queue = [startNode];\n    visitedNodeSet.add(startNode.id);\n    setVisitedNodes([{ id: startNode.id, color: treeEdgeColor }]);\n\n    while (queue.length > 0) {\n        const currentNode = queue.shift();\n        setCurrentNode(currentNode);\n        \n        for (let neighborId of adjList[currentNode.id]) {\n            const neighborNode = nodes.find(node => node.id === neighborId);\n            const edge = edges.find(e =>                                     \n                (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (e.from.id === neighborId && e.to.id === currentNode.id)))\n            );\n\n            if(!edge){\n                continue;\n            }\n\n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n            if(!visitedEdgeSet.has(edge)){\n                stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n            }\n\n            if (!visitedNodeSet.has(neighborId)) {\n                visitedNodeSet.add(neighborId);\n                queue.push(neighborNode);\n\n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: treeEdgeColor }\n                ]);\n                setVisitedNodes(prev => [...prev, { id: neighborId, color: treeEdgeColor }]);\n\n            } else{\n                setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n            }\n            \n        }\n    }\n\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"BFS Done!\");\n    setTimeout(resetEdges, 1000); \n};\n\n// Function to start Prim's algorithm\nexport const startPrim = () => {\n    if(algorithmRunning || isRemovingEdge){\n        return;\n    }\n    setRunningAlgorithm(\"Prim\");\n    setIsPrim(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin Prim's Algorithm\");\n}\n\n// Function to animate Prim's algorithm\nexport const animatePrimsAlgorithm = async (startNode) => {\n    setAlgorithmStarted(true);\n    setIsDirected(false);\n    setText(\"Prim's Algorithm in progress...\");\n    const visitedNodeSet = new Set();\n    const edgeQueue = [];\n    let stepIndex = 0;\n\n    const addEdges = (node) => {\n        visitedNodeSet.add(node.id);\n        setVisitedNodes(prev => [...prev, { id: node.id, color: treeEdgeColor }]);\n        (adjList[node.id] || []).forEach(neighborId => {\n            if (!visitedNodeSet.has(neighborId)) {\n                const edge = edges.find(e => \n                    (e.from.id === node.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === node.id)\n                );\n                if (edge) {\n                    edgeQueue.push({ ...edge, length: calculateEdgeLength(edge) });\n                }\n            }\n        });\n        edgeQueue.sort((a, b) => a.length - b.length); \n    };\n\n    const animateStep = async () => {\n        if (visitedNodeSet.size === nodes.length || edgeQueue.length === 0) {\n            setAlgorithmStarted(false);\n            setText(\"Prim's Algorithm Done!\");\n            setTimeout(resetEdges, 1000);\n            return;\n        }\n\n        const edgesToHighlight = edgeQueue.slice(0, 1); \n        edgesToHighlight.forEach(edge => {\n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n        });\n\n        stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n\n        const edge = edgeQueue.shift();\n        const { from, to } = edge;\n        const fromInMST = visitedNodeSet.has(from.id);\n        const toInMST = visitedNodeSet.has(to.id);\n\n        if ((fromInMST && !toInMST) || (!fromInMST && toInMST)) {\n            setVisitedEdges(prev => [\n                ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                { ...edge, color: treeEdgeColor }\n            ]);\n\n            if (fromInMST && !toInMST) {\n                addEdges(to);\n            } else if (!fromInMST && toInMST) {\n                addEdges(from);\n            }\n        } else {\n            setVisitedEdges(prev => [\n                ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                { ...edge, color: defaultEdgeColor }\n            ]);\n        }\n\n        animateStep();\n    };\n\n    addEdges(startNode);\n    animateStep();\n};\n\n// Function to animate Kruskall's algorithm\nexport const animateKruskalsAlgorithm = () => {\n    if (algorithmRunning || isRemovingEdge) {\n        return;\n    }\n    setIsDirected(false);\n    setRunningAlgorithm(\"Kruskall\");\n    setDisablePause(true);\n    setAlgorithmRunning(true);\n    setText(\"Kruskall's Algorithm in progress...\");\n\n    const sortedEdges = [...edges].sort((a, b) => calculateEdgeLength(a) - calculateEdgeLength(b));\n    let componentIndex = 0;\n    let currentComponentEdges = [];\n    let currentComponentNodes = [];\n    let uf;\n\n    const visitedNodeSet = new Set();\n    const foundComponents = [];\n\n    const dfsComponent = (currentNode, component) => {\n        if (visitedNodeSet.has(currentNode.id)) {\n            return;\n        }\n        visitedNodeSet.add(currentNode.id);\n        component.push(currentNode);\n        adjList[currentNode.id].forEach(neighborId => {\n            const neighborNode = nodes.find(node => node.id === neighborId);\n            if (!visitedNodeSet.has(neighborId)) {\n                dfsComponent(neighborNode, component);\n            }\n        });\n    };\n\n    nodes.forEach(node => {\n        if (!visitedNodeSet.has(node.id)) {\n            const component = [];\n            dfsComponent(node, component);\n            foundComponents.push(component);\n        }\n    });\n\n    setComponents(foundComponents);\n\n    const animateComponentMST = (component) => {\n        uf = new UnionFind(nodeCount); \n        currentComponentEdges = [];\n        currentComponentNodes = component.map(node => node.id);\n        let edgeIndex = 0;\n        const color = componentColors[componentIndex % componentColors.length];\n\n        const highlightNodesAndEdges = (index) => {\n            if (index < currentComponentEdges.length) {\n                const { from, to } = currentComponentEdges[index];\n                setVisitedNodes(prev => [...prev, { id: from.id, color }, { id: to.id, color }]);\n                setVisitedEdges(prev => [...prev, currentComponentEdges[index]]);\n                setTimeout(() => highlightNodesAndEdges(index + 1), totalSliderCount - sliderValueRef.current); \n            } else {\n                componentIndex++;\n                if (componentIndex < foundComponents.length) {\n                    setTimeout(() => animateComponentMST(foundComponents[componentIndex]), 0); \n                } else {\n                    setTimeout(resetEdges, 1000);\n                    setText(\"Kruskall's Algorithm Done!\");\n                }\n            }\n        };\n\n        const animateStep = () => {\n            if (currentComponentEdges.length === component.length - 1 || edgeIndex >= sortedEdges.length) {\n                highlightNodesAndEdges(0);\n                return;\n            }\n\n            const edge = sortedEdges[edgeIndex];\n            edgeIndex++;\n\n            if (currentComponentNodes.includes(edge.from.id) && currentComponentNodes.includes(edge.to.id) &&\n                uf.find(edge.from.id) !== uf.find(edge.to.id)) {\n                uf.union(edge.from.id, edge.to.id);\n                currentComponentEdges.push({ ...edge, color });\n            }\n\n            animateStep();\n        };\n\n        animateStep();\n    };\n\n    if (foundComponents.length > 0) {\n        animateComponentMST(foundComponents[0]);\n    } else {\n        console.log(\"No components found.\");\n        setAlgorithmRunning(false);\n    }\n};\n\n// Function to start shortest path algorithm\nexport const startShortestPath = () => {\n    if(algorithmRunning || isRemovingEdge){\n        return;\n    }\n    setRunningAlgorithm(\"SP\");\n\n    setIsShortestPath(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Start Node for Shortest Path\");\n}\n\n// Function to find the shortest path between two nodes\nexport const findShortestPath = async (startNode, targetNode) => {\n    setAlgorithmStarted(true);\n    setText(\"Shortest Path Algorithm in progress...\");\n    const dist = {};\n    const prev = {};\n    const visitedEdgeSet = new Set();\n    const visitedNodeSet = new Set();\n    const priorityQueue = new Set(nodes.map(node => node.id)); \n    let stepIndex = 0;\n\n    nodes.forEach(node => {\n        dist[node.id] = Infinity;\n        prev[node.id] = null;\n    });\n    dist[startNode.id] = 0;\n\n    const getMinDistNode = () => {\n        let minNode = null;\n        priorityQueue.forEach(nodeId => {\n            if (minNode === null || dist[nodeId] < dist[minNode]) {\n                minNode = nodeId;\n            }\n        });\n        return minNode;\n    };\n\n    while (priorityQueue.size > 0) {\n        const currentNodeId = getMinDistNode();\n        const currentNode = nodes.find(node => node.id === currentNodeId);\n\n        if (dist[currentNodeId] === Infinity) break;\n\n        priorityQueue.delete(currentNodeId);\n\n        if (currentNodeId === targetNode.id) {\n            break;\n        }\n\n        for (let neighborId of adjList[currentNode.id]) {\n            const neighborNode = nodes.find(node => node.id === neighborId);\n            const edge = edges.find(e => \n                (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (e.from.id === neighborId && e.to.id === currentNode.id)))\n            );\n\n            if(!edge){\n                continue;\n            }\n\n            setCurrentNode(currentNode);\n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n            if (!visitedEdgeSet.has(edge)) {\n                stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n                visitedEdgeSet.add(edge);\n            }\n\n            const alt = dist[currentNode.id] + calculateEdgeLength(edge);\n\n            if (alt < dist[neighborId]) {\n                dist[neighborId] = alt;\n                prev[neighborId] = currentNode.id;\n\n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: treeEdgeColor }\n                ]);\n\n                visitedEdgeSet.add(edge);\n            } else {\n                setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color === currentEdgeColor)));\n            }\n        }\n\n        visitedNodeSet.add(currentNode.id);\n        setVisitedNodes(prev => {\n            const updatedNodes = [...prev, { id: currentNode.id, color: treeEdgeColor }];\n            return updatedNodes;\n        });\n    }\n\n    setStartNode(null);\n    setEndNode(null);\n    setAlgorithmStarted(false);\n    setCurrentNode(null);\n    setText(\"Shortest Path Done!\");\n\n    const path = [];\n\n    let currentNodeId = targetNode.id;\n    while (currentNodeId !== null) {\n        path.unshift(currentNodeId);\n        currentNodeId = prev[currentNodeId];\n    }\n\n    if(path.length === 1){\n        setText(\"No path Found!\");\n        setTimeout(resetEdges, 1000);\n        return;\n    }\n\n    setVisitedEdges(prev => {\n        return prev.map(e => {\n            if (path.includes(e.from.id) && path.includes(e.to.id)) {\n                return { ...e, color: treeEdgeColor };\n            } else {\n                return { ...e, color: defaultEdgeColor };\n            }\n        });\n    });\n\n    setVisitedNodes(prev => {\n        return nodes.map(node => {\n            if (path.includes(node.id)) {\n                return { id: node.id, color: treeEdgeColor };\n            } else {\n                return { id: node.id, color: \"black\" };\n            }\n        });\n    });\n\n    setTimeout(resetEdges, 1000);\n};\n\n// Function to start TSP\nexport const startTSP = async () => {\n    if(algorithmRunning || isRemovingEdge){\n        return;\n    }\n    setRunningAlgorithm(\"TSP\");\n    setIsTSP(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin TSP\");\n}\n\n// Function to animate TSP\nexport const tsp = async (node) => {\n    setAlgorithmStarted(true);\n    setText(\"TSP in progress...\");\n    const startNode = node;\n    const unvisited = new Set(nodes.map(node => node.id));\n    const visited = [];\n    const stack = [];\n    let currentNode = startNode;\n    let stepIndex = 0;\n\n    unvisited.delete(currentNode.id);\n    visited.push(currentNode);\n    setVisitedNodes([{ id: currentNode.id, color: treeEdgeColor }]);\n\n    while (unvisited.size > 0) {\n        let nearestNode = null;\n        let shortestDistance = Infinity;\n        let currentEdge = null;\n\n        for (let neighborId of unvisited) {\n            setCurrentNode(currentNode);\n            const neighborNode = nodes.find(node => node.id === neighborId);\n            // eslint-disable-next-line\n            const edge = edges.find(e => \n                (isDirected && e && e.from && e.to && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (!isDirected && e && e.from && e.to && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (e.from.id === neighborId && e.to.id === currentNode.id)))\n            );\n\n            if (!edge) {\n                continue;\n            }\n            \n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n            stepIndex++;\n            if (isPausedRef.current) {\n                await new Promise(resolve => {\n                    const checkStep = () => {\n                        if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                            resolve();\n                        } else {\n                            setTimeout(checkStep, 50);\n                        }\n                    };\n                    checkStep();\n                });\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n            } else {\n                await sleep(totalSliderCount - sliderValueRef.current);\n            }\n\n            if(isStepModeRef.current){\n                setIsPaused(true);\n                isPausedRef.current = true;\n            }\n            const distance = calculateEdgeLength({ from: currentNode, to: neighborNode });\n            setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)));\n            if (distance < shortestDistance) {\n                shortestDistance = distance;\n                nearestNode = neighborNode;\n                currentEdge = edge;\n            }\n            \n        }\n\n        if (nearestNode && currentEdge) {\n            stack.push({ currentNode, nearestNode, shortestDistance });\n\n            setVisitedEdges(prev => [...prev, { ...currentEdge, color: treeEdgeColor }]);\n            setVisitedNodes(prev => [...prev, { id: nearestNode.id, color: treeEdgeColor }]);\n\n            stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n\n            currentNode = nearestNode;\n            unvisited.delete(currentNode.id);\n            visited.push(currentNode);\n        } else {\n            const previousState = stack.pop();\n            if (previousState) {\n                currentNode = previousState.currentNode;\n            } else {\n                break;\n            }\n        }\n    }\n\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"TSP Done!\");\n    setTimeout(resetEdges, 1000);\n};\n\n// Function to color graph\nexport const graphColoring = async () => {\n    if(algorithmRunning || isRemovingEdge){\n        return;\n    }\n    setRunningAlgorithm(\"Color\");\n    setDisablePause(true);\n    setAlgorithmRunning(true);\n    setText(\"Graph Coloring in progress...\");\n\n    const availableColors = componentColors;\n    const colors = {};\n\n    const colorGraph = (node) => {\n        const neighborColors = adjList[node.id].map(neighborId => colors[neighborId]);\n        for(let color of availableColors){\n            if(!neighborColors.includes(color)){\n                colors[node.id] = color;\n                break;\n            }\n        }\n    }\n\n    for(let node of nodes){\n        colorGraph(node);\n        setVisitedNodes(prev => [...prev, {id: node.id, color: colors[node.id]}]);\n        await new Promise(resolve => setTimeout(resolve, totalSliderCount - sliderValueRef.current));\n    }\n\n    setText(\"Graph Coloring Done!\");\n    setTimeout(resetEdges, 1000);\n}\n\n// Function to find connected components in a graph\nexport const findConnectedComponents = async () => {\n    setRunningAlgorithm(\"Connected\");\n    setAlgorithmStarted(true);\n    setText(\"Connected Components in progress...\");\n    setAlgorithmRunning(true);\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let componentIndex = 0;\n    let stepIndex = 0;\n\n    const dfsRecursive = async (currentNode, componentColor) => {\n        if (visitedNodeSet.has(currentNode.id)) {\n            return;\n        }\n\n        visitedNodeSet.add(currentNode.id);\n        setVisitedNodes(prev => { \n            const updatedNodes = [...prev, { id: currentNode.id, color: componentColor }];\n            return updatedNodes;\n        });\n\n        for (let neighborId of adjList[currentNode.id]) {\n            setCurrentNode(currentNode);     \n            const neighborNode = nodes.find(node => node.id === neighborId); \n            const edge = edges.find(e =>                                     \n                (e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (e.from.id === neighborId && e.to.id === currentNode.id)\n            );\n\n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n            if (!visitedEdgeSet.has(edge)) {\n                stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n            }\n\n            if (!visitedNodeSet.has(neighborId)) { \n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: componentColor }\n                ]);\n                visitedEdgeSet.add(edge);\n\n                await dfsRecursive(neighborNode, componentColor);\n            } else {\n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: componentColor }\n                ]);\n            }\n        }\n    };\n\n    for (let node of nodes) {\n        if (!visitedNodeSet.has(node.id)) {\n            const componentColor = componentColors[componentIndex % componentColors.length];\n            componentIndex++;\n            await dfsRecursive(node, componentColor);\n        }\n    }\n\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"Connected Components Done!\");\n    setTimeout(resetEdges, 1000); \n};\n\n// Function to find strong components\nexport const findStrongComponents = async () => {\n    setRunningAlgorithm(\"Connected\");\n    setAlgorithmStarted(true);\n    setText(\"Strong Components in progress...\");\n    setAlgorithmRunning(true);\n\n    const stack = [];\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    const reverseAdjList = {};\n    let stepIndex = 0;\n\n    const dfs1 = async (node) => {\n        if (visitedNodeSet.has(node.id)) {\n            return;\n        }\n\n        visitedNodeSet.add(node.id);\n        \n        for (let neighborId of adjList[node.id]) {\n            if (!visitedNodeSet.has(neighborId)) {\n                const neighborNode = nodes.find(n => n.id === neighborId);\n                await dfs1(neighborNode);\n            }\n        }\n        \n        stack.push(node);\n    };\n\n    const reverseGraph = () => {\n        nodes.forEach(node => {\n            reverseAdjList[node.id] = [];\n        });\n        edges.forEach(edge => {\n            reverseAdjList[edge.to.id].push(edge.from.id);\n        });\n    };\n\n    const dfs2 = async (node, componentColor) => {\n        if (visitedNodeSet.has(node.id)) {\n            return;\n        }\n        \n        visitedNodeSet.add(node.id);\n        setVisitedNodes(prev => { \n            const updatedNodes = [...prev, { id: node.id, color: componentColor }];\n            return updatedNodes;\n        });\n    \n        for (let neighborId of reverseAdjList[node.id]) {\n            setCurrentNode(node);\n            const neighborNode = nodes.find(n => n.id === neighborId);\n            const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId);\n            \n            if (!edge) {\n                continue;\n            }\n    \n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n    \n            if (!visitedEdgeSet.has(edge)) {\n                stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if (isStepModeRef.current) {\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n    \n                if (isStepModeRef.current) {\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n            }\n            \n            if (!visitedNodeSet.has(neighborId)) { \n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: componentColor }\n                ]);\n                visitedEdgeSet.add(edge);\n\n                await dfs2(neighborNode, componentColor);\n            } else {\n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: componentColor }\n                ]);\n            }\n        }\n    };\n\n    reverseGraph();\n\n    for (let node of nodes) {\n        if (!visitedNodeSet.has(node.id)) {\n            await dfs1(node);\n        }\n    }\n\n    visitedNodeSet.clear();\n    visitedEdgeSet.clear();\n\n    let componentIndex = 0;\n    while (stack.length > 0) {\n        const node = stack.pop();\n        if (!visitedNodeSet.has(node.id)) {\n            const componentColor = componentColors[componentIndex % componentColors.length];\n            componentIndex++;\n            await dfs2(node, componentColor);\n        }\n    }\n\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"Strong Components Done!\");\n    setTimeout(resetEdges, 1000);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}