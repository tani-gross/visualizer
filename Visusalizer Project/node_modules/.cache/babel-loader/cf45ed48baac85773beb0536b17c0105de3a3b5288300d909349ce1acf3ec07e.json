{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useGraphStates } from './GraphsContext';\nexport const useNodeFunctions = () => {\n  _s();\n  const {\n    nodes,\n    edges,\n    startingText,\n    nodeCount,\n    setClickedTraveral,\n    setClickedMST,\n    setText,\n    setNodes,\n    setNodeCount,\n    setVisitedNodes,\n    setVisitedEdges,\n    defaultEdgeColor,\n    setIsRemovingEdge,\n    setSelectedNode,\n    dragging,\n    setEdges,\n    algorithmRunning,\n    isRemovingEdge,\n    setAdjList,\n    isAddingEdge,\n    setIsAddingEdge,\n    selectedNode,\n    isDirected,\n    dfs,\n    startNode,\n    setIsDFS,\n    bfs,\n    setIsBFS,\n    setIsPrim,\n    animatePrimsAlgorithm,\n    endNode,\n    setEndNode,\n    tsp,\n    setIsTSP,\n    setStartNode,\n    findShortestPath,\n    setIsShortestPath,\n    setDragging,\n    isTSP,\n    isBFS,\n    isDFS,\n    isPrim,\n    isShortestPath,\n    setSliderValue,\n    sliderValueRef\n  } = useGraphStates();\n  const {\n    goBack,\n    resetEdges,\n    setClickMST,\n    setClickPath,\n    setClickTraveral,\n    nextStep,\n    togglePlayPause,\n    toggleGraphType\n  } = useGraphStates();\n\n  // Function to add a new node to the graph\n  const addNode = () => {\n    if (algorithmRunning) {\n      return;\n    }\n    if (nodes.length >= 20) {\n      alert(\"too many nodes\");\n      return;\n    }\n    setText(startingText);\n    const newNode = {\n      id: nodeCount,\n      x: Math.random() * 480,\n      y: Math.random() * 480\n    };\n    setNodes([...nodes, newNode]);\n    setAdjList(prevAdjList => ({\n      ...prevAdjList,\n      [newNode.id]: []\n    }));\n    setNodeCount(nodeCount + 1);\n  };\n\n  // Function to generate a random graph\n  const generateGraph = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    var numNodes = 0;\n    var numEdges = -1;\n    do {\n      const response = prompt(\"Enter the number of nodes for the graph:\", \"\");\n      if (response === null) {\n        return;\n      }\n      if (isNaN(response)) {\n        alert(\"Invalid input. Please enter numbers only\");\n        continue;\n      }\n      if (response <= 0 || response > 20) {\n        alert(\"Invalid input. Number of nodes must be between 1 and 20\");\n        continue;\n      }\n      numNodes = response;\n    } while (numNodes === 0);\n    do {\n      const response = prompt(\"Enter the number of edges for the graph:\", \"\");\n      if (response === null) {\n        return;\n      }\n      if (isNaN(response)) {\n        alert(\"Invalid input. Please enter numbers only\");\n        continue;\n      }\n      if (!isDirected) {\n        if (response > numNodes * (numNodes - 1) / 2) {\n          alert(\"Invalid input. Too many edges for the undirected graph\");\n          continue;\n        }\n      } else {\n        if (response > numNodes * (numNodes - 1)) {\n          alert(\"Invalid input. Too many edges for the directed graph\");\n          continue;\n        }\n      }\n      if (response < 0) {\n        alert(\"Invalid input. Not enough edges\");\n        continue;\n      }\n      numEdges = response;\n    } while (numEdges === -1);\n    setNodes([]);\n    setEdges([]);\n    setAdjList({});\n    setNodeCount(0);\n    setVisitedNodes([]);\n    setVisitedEdges([]);\n    setSelectedNode(null);\n    setText(startingText);\n    const newNodes = [];\n    const newEdges = [];\n    const newAdjList = {};\n    const gridSize = Math.ceil(Math.sqrt(numNodes));\n    const areaWidth = 500;\n    const areaHeight = 500;\n    const margin = 10;\n    const gridSpacingX = (areaWidth - 2 * margin) / gridSize;\n    const gridSpacingY = (areaHeight - 2 * margin) / gridSize;\n    for (let i = 0; i < numNodes; i++) {\n      const row = Math.floor(i / gridSize);\n      const col = i % gridSize;\n      const x = margin + col * gridSpacingX + Math.random() * gridSpacingX * 0.9;\n      const y = margin + row * gridSpacingY + Math.random() * gridSpacingY * 0.9;\n      const newNode = {\n        id: i,\n        x: x,\n        y: y\n      };\n      newNodes.push(newNode);\n      newAdjList[i] = [];\n    }\n    while (newEdges.length < numEdges) {\n      const from = newNodes[Math.floor(Math.random() * numNodes)];\n      const to = newNodes[Math.floor(Math.random() * numNodes)];\n      if (from.id !== to.id) {\n        const edgeExists = newEdges.some(edge => edge.from.id === from.id && edge.to.id === to.id || !isDirected && edge.from.id === to.id && edge.to.id === from.id);\n        if (!edgeExists) {\n          const newEdge = {\n            from,\n            to,\n            color: defaultEdgeColor\n          };\n          newEdges.push(newEdge);\n          newAdjList[from.id].push(to.id);\n          if (!isDirected) {\n            newAdjList[to.id].push(from.id);\n          }\n        }\n      }\n    }\n    setNodes(newNodes);\n    setEdges(newEdges);\n    setAdjList(newAdjList);\n    setNodeCount(newNodes.length);\n  };\n\n  // Function to reset the graph\n  const resetGraph = () => {\n    if (algorithmRunning) {\n      return;\n    }\n    setNodes([]);\n    setEdges([]);\n    setClickedMST(false);\n    setClickedTraversal(false);\n    setIsRemovingEdge(false);\n    setText(startingText);\n  };\n\n  // Function to remove a selected node form the graph\n  const removeNode = () => {\n    if (selectedNode == null) return;\n    setNodes(nodes.filter(node => node.id !== selectedNode.id));\n    setEdges(edges.filter(edge => edge.from.id !== selectedNode.id && edge.to.id !== selectedNode.id));\n    setAdjList(prevAdjList => {\n      const newAdjList = {\n        ...prevAdjList\n      };\n      delete newAdjList[selectedNode.id];\n      for (const key in newAdjList) {\n        newAdjList[key] = newAdjList[key].filter(id => id !== selectedNode.id);\n      }\n      return newAdjList;\n    });\n    setSelectedNode(null);\n  };\n\n  // Function to handle clicking on a node\n  const handleNodeClick = node => {\n    if (dragging) {\n      return;\n    }\n    if (isAddingEdge) {\n      if (selectedNode && selectedNode.id !== node.id) {\n        const edgeExists = edges.some(edge => edge.from.id === selectedNode.id && edge.to.id === node.id || !isDirected && edge.from.id === node.id && edge.to.id === selectedNode.id);\n        if (!edgeExists) {\n          const newEdge = {\n            from: selectedNode,\n            to: node,\n            color: defaultEdgeColor\n          };\n          setEdges(prevEdges => [...prevEdges, newEdge]);\n          setAdjList(prevAdjList => {\n            const newAdjList = {\n              ...prevAdjList\n            };\n            if (!newAdjList[selectedNode.id]) newAdjList[selectedNode.id] = [];\n            if (!newAdjList[node.id]) newAdjList[node.id] = [];\n            newAdjList[selectedNode.id].push(node.id);\n            if (!isDirected) {\n              newAdjList[node.id].push(selectedNode.id);\n            }\n            return newAdjList;\n          });\n        }\n        setIsAddingEdge(false);\n        setSelectedNode(null);\n      } else if (selectedNode && selectedNode.id === node.id) {\n        setSelectedNode(null);\n        setIsAddingEdge(false);\n      }\n      setText(startingText);\n    } else if (isDFS) {\n      setVisitedNodes([]);\n      setVisitedEdges([]);\n      dfs(node);\n      setIsDFS(false);\n    } else if (isBFS) {\n      setVisitedNodes([]);\n      setVisitedEdges([]);\n      bfs(node);\n      setIsBFS(false);\n    } else if (isPrim) {\n      setIsPrim(false);\n      animatePrimsAlgorithm(node);\n    } else if (isShortestPath) {\n      if (!startNode) {\n        setStartNode(node);\n        setText(\"Select End Node for Shortest Path\");\n      } else if (!endNode) {\n        setEndNode(node);\n        setText(\"Finding Shortest Path...\");\n        findShortestPath(startNode, node);\n        setIsShortestPath(false);\n      }\n    } else if (isTSP) {\n      setVisitedNodes([]);\n      setVisitedEdges([]);\n      tsp(node);\n      setIsTSP(false);\n    } else {\n      if (selectedNode && selectedNode.id === node.id) {\n        setSelectedNode(null);\n        setText(startingText);\n      } else {\n        if (!algorithmRunning) {\n          setSelectedNode(node);\n        }\n      }\n    }\n  };\n\n  // Function to handle mouse down event for dragging\n  const handleMouseDown = () => {\n    setDragging(false);\n  };\n\n  // Function to handle slider change\n  const handleSliderChange = event => {\n    const newValue = event.target.value;\n    setSliderValue(newValue);\n    sliderValueRef.current = newValue;\n  };\n\n  // Function to start removing an edge\n  const startRemovingEdge = () => {\n    if (algorithmRunning) {\n      return;\n    }\n    if (isRemovingEdge) {\n      setIsRemovingEdge(false);\n      setText(\"\");\n      return;\n    }\n    if (edges.length < 1) {\n      alert(\"must be at least one edge\");\n      return;\n    }\n    setText(\"Click on an edge to remove it\");\n    setIsRemovingEdge(true);\n  };\n\n  // Function to initiate adding an edge\n  const handleAddEdge = () => {\n    if (selectedNode === null) return;\n    if (!isDirected) {\n      if (nodes.length * (nodes.length - 1) / 2 === edges.length) {\n        alert(\"cannot add another edge\");\n        return;\n      }\n    } else {\n      if (nodes.length * (nodes.length - 1) === edges.length) {\n        alert(\"cannot add another edge\");\n        return;\n      }\n    }\n    if (nodes.length < 2) {\n      alert(\"You need at least two nodes to add an edge.\");\n      return;\n    }\n    setIsAddingEdge(true);\n    setText(\"Click another node to add edge\");\n  };\n\n  // Function to handle clicking on an edge\n  const handleEdgeClick = edge => {\n    if (isRemovingEdge) {\n      setEdges(edges.filter(e => e !== edge));\n      setIsRemovingEdge(false);\n      setAdjList(prevAdjList => {\n        const newAdjList = {\n          ...prevAdjList\n        };\n        newAdjList[edge.from.id] = newAdjList[edge.from.id].filter(id => id !== edge.to.id);\n        newAdjList[edge.to.id] = newAdjList[edge.to.id].filter(id => id !== edge.from.id);\n        return newAdjList;\n      });\n      setText(startingText);\n    }\n  };\n\n  // Function to handle dragging a node\n  const handleDrag = (e, data, node) => {\n    setDragging(true);\n    node.x = data.x;\n    node.y = data.y;\n    setNodes([...nodes]);\n  };\n\n  // Function to handle stopping the drag of a node\n  const handleDragStop = () => {\n    setTimeout(() => {\n      setDragging(false);\n    }, 0);\n  };\n  return {\n    addNode,\n    generateGraph,\n    resetGraph,\n    removeNode,\n    handleNodeClick,\n    handleMouseDown,\n    handleSliderChange,\n    startRemovingEdge,\n    handleAddEdge,\n    handleEdgeClick,\n    handleDrag,\n    handleDragStop\n  };\n};\n_s(useNodeFunctions, \"fjFuDoRAx84XjFBmdD/UMAly4V4=\", false, function () {\n  return [useGraphStates, useGraphStates];\n});","map":{"version":3,"names":["useGraphStates","useNodeFunctions","_s","nodes","edges","startingText","nodeCount","setClickedTraveral","setClickedMST","setText","setNodes","setNodeCount","setVisitedNodes","setVisitedEdges","defaultEdgeColor","setIsRemovingEdge","setSelectedNode","dragging","setEdges","algorithmRunning","isRemovingEdge","setAdjList","isAddingEdge","setIsAddingEdge","selectedNode","isDirected","dfs","startNode","setIsDFS","bfs","setIsBFS","setIsPrim","animatePrimsAlgorithm","endNode","setEndNode","tsp","setIsTSP","setStartNode","findShortestPath","setIsShortestPath","setDragging","isTSP","isBFS","isDFS","isPrim","isShortestPath","setSliderValue","sliderValueRef","goBack","resetEdges","setClickMST","setClickPath","setClickTraveral","nextStep","togglePlayPause","toggleGraphType","addNode","length","alert","newNode","id","x","Math","random","y","prevAdjList","generateGraph","numNodes","numEdges","response","prompt","isNaN","newNodes","newEdges","newAdjList","gridSize","ceil","sqrt","areaWidth","areaHeight","margin","gridSpacingX","gridSpacingY","i","row","floor","col","push","from","to","edgeExists","some","edge","newEdge","color","resetGraph","setClickedTraversal","removeNode","filter","node","key","handleNodeClick","prevEdges","handleMouseDown","handleSliderChange","event","newValue","target","value","current","startRemovingEdge","handleAddEdge","handleEdgeClick","e","handleDrag","data","handleDragStop","setTimeout"],"sources":["/Users/tani/Desktop/visualizer/Visusalizer Project/src/Components/NodeFunctions.js"],"sourcesContent":["import { useGraphStates } from './GraphsContext';\n\nexport const useNodeFunctions = () => {\n\n    const {\n        nodes, edges, startingText, nodeCount, setClickedTraveral, setClickedMST, setText, setNodes,\n        setNodeCount, setVisitedNodes, setVisitedEdges, defaultEdgeColor, setIsRemovingEdge, setSelectedNode, \n        dragging, setEdges, algorithmRunning, isRemovingEdge, setAdjList, isAddingEdge, setIsAddingEdge,\n        selectedNode, isDirected, dfs, startNode, setIsDFS, bfs, setIsBFS, setIsPrim,\n        animatePrimsAlgorithm, endNode, setEndNode, tsp, setIsTSP,\n        setStartNode, findShortestPath, setIsShortestPath, setDragging,\n        isTSP, isBFS, isDFS, isPrim, isShortestPath, setSliderValue, sliderValueRef\n    } = useGraphStates();\n\n    const {goBack, resetEdges, setClickMST, setClickPath, setClickTraveral, nextStep, togglePlayPause, toggleGraphType} = useGraphStates();\n\n    // Function to add a new node to the graph\n    const addNode = () => {\n        if(algorithmRunning){\n            return;\n        }\n\n        if(nodes.length >= 20){\n            alert(\"too many nodes\");\n            return;\n        }\n\n        setText(startingText);\n        const newNode = {\n            id: nodeCount,\n            x: Math.random() * 480,\n            y: Math.random() * 480,\n        };\n        setNodes([...nodes, newNode]);\n        setAdjList(prevAdjList => ({ ...prevAdjList, [newNode.id]: [] }));\n        setNodeCount(nodeCount + 1);\n    };\n\n    // Function to generate a random graph\n    const generateGraph = () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n\n        var numNodes = 0;\n        var numEdges = -1;\n\n        do{\n            const response = prompt(\"Enter the number of nodes for the graph:\", \"\");\n            if(response === null){\n                return;\n            }\n            if(isNaN(response)){\n                alert(\"Invalid input. Please enter numbers only\");\n                continue;\n            }\n\n            if(response <= 0 || response > 20){\n                alert(\"Invalid input. Number of nodes must be between 1 and 20\");\n                continue;\n            }\n\n            numNodes = response;\n\n        }while(numNodes === 0);\n\n        do{\n            const response = prompt(\"Enter the number of edges for the graph:\", \"\");\n            if(response === null){\n                return;\n            }\n\n            if(isNaN(response)){\n                alert(\"Invalid input. Please enter numbers only\");\n                continue;\n            }\n\n            if(!isDirected){\n                if(response > ((numNodes * (numNodes - 1)) / 2)){\n                    alert(\"Invalid input. Too many edges for the undirected graph\");\n                    continue;\n                }\n            }else{\n                if(response > ((numNodes * (numNodes - 1)))){\n                    alert(\"Invalid input. Too many edges for the directed graph\");\n                    continue;\n                }\n            }\n            \n            if(response < 0){\n                alert(\"Invalid input. Not enough edges\");\n                continue;\n            }\n\n            numEdges = response;\n\n        }while(numEdges === -1);\n\n        setNodes([]);\n        setEdges([]);\n        setAdjList({});\n        setNodeCount(0);\n        setVisitedNodes([]);\n        setVisitedEdges([]);\n        setSelectedNode(null);\n        setText(startingText);\n\n        const newNodes = [];\n        const newEdges = [];\n        const newAdjList = {};\n\n\n        const gridSize = Math.ceil(Math.sqrt(numNodes));\n        const areaWidth = 500; \n        const areaHeight = 500; \n        const margin = 10;\n        const gridSpacingX = (areaWidth - 2 * margin) / gridSize;\n        const gridSpacingY = (areaHeight - 2 * margin) / gridSize;\n\n        for (let i = 0; i < numNodes; i++) {\n            const row = Math.floor(i / gridSize);\n            const col = i % gridSize;\n            const x = margin + col * gridSpacingX + Math.random() * gridSpacingX * 0.9;\n            const y = margin + row * gridSpacingY + Math.random() * gridSpacingY * 0.9;\n\n            const newNode = {\n                id: i,\n                x: x,\n                y: y,\n            };\n            newNodes.push(newNode);\n            newAdjList[i] = [];\n        }\n\n        while (newEdges.length < numEdges) {\n            const from = newNodes[Math.floor(Math.random() * numNodes)];\n            const to = newNodes[Math.floor(Math.random() * numNodes)];\n            if (from.id !== to.id) {\n                const edgeExists = newEdges.some(edge => \n                    (edge.from.id === from.id && edge.to.id === to.id) ||\n                    (!isDirected && edge.from.id === to.id && edge.to.id === from.id)\n                );\n                if (!edgeExists) {\n                    const newEdge = { from, to, color: defaultEdgeColor };\n                    newEdges.push(newEdge);\n                    newAdjList[from.id].push(to.id);\n                    if(!isDirected){\n                        newAdjList[to.id].push(from.id);\n                    }\n                }\n            }\n        }\n\n        setNodes(newNodes);\n        setEdges(newEdges);\n        setAdjList(newAdjList);\n        setNodeCount(newNodes.length);\n    };\n\n    // Function to reset the graph\n    const resetGraph = () => {\n        if(algorithmRunning){\n            return;\n        }\n        setNodes([]);\n        setEdges([]);\n        setClickedMST(false);\n        setClickedTraversal(false);\n        setIsRemovingEdge(false);\n        setText(startingText);\n    };\n\n    // Function to remove a selected node form the graph\n    const removeNode = () => {\n        if (selectedNode == null) return;\n\n        setNodes(nodes.filter(node => node.id !== selectedNode.id));\n        setEdges(edges.filter(edge => edge.from.id !== selectedNode.id && edge.to.id !== selectedNode.id));\n        setAdjList(prevAdjList => {\n            const newAdjList = { ...prevAdjList };\n            delete newAdjList[selectedNode.id];\n            for (const key in newAdjList) {\n                newAdjList[key] = newAdjList[key].filter(id => id !== selectedNode.id);\n            }\n            return newAdjList;\n        });\n        setSelectedNode(null);\n    };\n\n    // Function to handle clicking on a node\n    const handleNodeClick = (node) => {\n        if (dragging) {\n            return;\n        }\n\n        if (isAddingEdge) {\n            if (selectedNode && selectedNode.id !== node.id) {\n                const edgeExists = edges.some(edge =>\n                    (edge.from.id === selectedNode.id && edge.to.id === node.id) ||\n                    (!isDirected && edge.from.id === node.id && edge.to.id === selectedNode.id)\n                );\n\n                if(!edgeExists){\n                    const newEdge = { from: selectedNode, to: node, color: defaultEdgeColor };\n                    setEdges(prevEdges => [...prevEdges, newEdge]);\n\n                    setAdjList(prevAdjList => {\n                        const newAdjList = { ...prevAdjList };\n                        if (!newAdjList[selectedNode.id]) newAdjList[selectedNode.id] = [];\n                        if (!newAdjList[node.id]) newAdjList[node.id] = [];\n                        newAdjList[selectedNode.id].push(node.id);\n                        if (!isDirected) {\n                            newAdjList[node.id].push(selectedNode.id);\n                        }\n                        return newAdjList;\n                    })\n                }\n                \n                setIsAddingEdge(false);\n                setSelectedNode(null);\n            } else if (selectedNode && selectedNode.id === node.id) {\n                setSelectedNode(null);\n                setIsAddingEdge(false);\n            }\n            setText(startingText);\n        } else if(isDFS){\n            setVisitedNodes([]);\n            setVisitedEdges([]);\n            dfs(node);\n            setIsDFS(false);\n        } else if(isBFS){\n            setVisitedNodes([]);\n            setVisitedEdges([]);\n            bfs(node);\n            setIsBFS(false);\n        }else if(isPrim){\n            setIsPrim(false);\n            animatePrimsAlgorithm(node);\n        }else if(isShortestPath){\n            if(!startNode){\n                setStartNode(node);\n                setText(\"Select End Node for Shortest Path\");\n            }else if(!endNode){\n                setEndNode(node);\n                setText(\"Finding Shortest Path...\");\n                findShortestPath(startNode, node);\n                setIsShortestPath(false);\n            }\n        }else if(isTSP){\n            setVisitedNodes([]);\n            setVisitedEdges([]);\n            tsp(node);\n            setIsTSP(false);\n        }else{\n            if (selectedNode && selectedNode.id === node.id) {\n                setSelectedNode(null); \n                setText(startingText);\n            } else {\n                if(!algorithmRunning){\n                    setSelectedNode(node);\n                }\n                \n            }\n        }\n    }\n\n    // Function to handle mouse down event for dragging\n    const handleMouseDown = () => {\n        setDragging(false);\n    };\n\n    // Function to handle slider change\n    const handleSliderChange = (event) => {\n        const newValue = event.target.value;\n        setSliderValue(newValue);\n        sliderValueRef.current = newValue;\n    }\n\n    // Function to start removing an edge\n    const startRemovingEdge = () => {\n        if(algorithmRunning){\n            return;\n        }\n\n        if(isRemovingEdge){\n            setIsRemovingEdge(false);\n            setText(\"\");\n            return;\n        }\n\n        if(edges.length < 1){\n            alert(\"must be at least one edge\");\n            return;\n        }\n        setText(\"Click on an edge to remove it\");\n        setIsRemovingEdge(true);\n    }\n\n    // Function to initiate adding an edge\n    const handleAddEdge = () => {\n        if (selectedNode === null) return;\n\n        if(!isDirected){\n            if(((nodes.length * (nodes.length - 1)) / 2) === edges.length){\n                alert(\"cannot add another edge\");\n                return;\n            }\n        }else{\n            if(((nodes.length * (nodes.length - 1))) === edges.length){\n                alert(\"cannot add another edge\");\n                return;\n            }\n        }\n        \n\n        if (nodes.length < 2) {\n            alert(\"You need at least two nodes to add an edge.\");\n            return;\n        }\n        setIsAddingEdge(true);\n        setText(\"Click another node to add edge\");\n    };\n\n    // Function to handle clicking on an edge\n    const handleEdgeClick = (edge) => {\n        if (isRemovingEdge) {\n            setEdges(edges.filter(e => e !== edge));\n            setIsRemovingEdge(false);\n\n            setAdjList(prevAdjList => {\n                const newAdjList = { ...prevAdjList };\n                newAdjList[edge.from.id] = newAdjList[edge.from.id].filter(id => id !== edge.to.id);\n                newAdjList[edge.to.id] = newAdjList[edge.to.id].filter(id => id !== edge.from.id);\n                return newAdjList;\n            });\n            setText(startingText);\n        }\n    }\n\n    // Function to handle dragging a node\n    const handleDrag = (e, data, node) => {\n        setDragging(true);\n        node.x = data.x;\n        node.y = data.y;\n        setNodes([...nodes]);\n    };\n\n    // Function to handle stopping the drag of a node\n    const handleDragStop = () => {\n        setTimeout(() => {\n            setDragging(false);\n        }, 0);\n    };\n\n    return {addNode, generateGraph, resetGraph, removeNode, handleNodeClick, handleMouseDown, handleSliderChange, startRemovingEdge, handleAddEdge, handleEdgeClick, handleDrag, handleDragStop};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}