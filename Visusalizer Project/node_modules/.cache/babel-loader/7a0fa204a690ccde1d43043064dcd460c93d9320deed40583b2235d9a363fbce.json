{"ast":null,"code":"var _s = $RefreshSig$();\nimport { sleep } from './GraphUtilities';\nimport UnionFind from './UnionFind';\nimport { useGraphStates } from './Graphs';\nexport const useAlgorithms = () => {\n  _s();\n  const {\n    nodes,\n    edges,\n    adjList,\n    setVisitedNodes,\n    setVisitedEdges,\n    setAlgorithmStarted,\n    setText,\n    resetEdges,\n    setCurrentNode,\n    isPausedRef,\n    currentStepRef,\n    isStepModeRef,\n    sliderValueRef,\n    totalSliderCount,\n    componentColors,\n    setComponents,\n    algorithmRunning,\n    isRemovingEdge,\n    setRunningAlgorithm,\n    setIsDFS,\n    setAlgorithmRunning,\n    treeEdgeColor,\n    isDirected,\n    currentEdgeColor,\n    setIsPaused,\n    startNode,\n    setIsBFS\n  } = useGraphStates();\n\n  // Function to start DFS\n  const startDFS = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"DFS\");\n    setIsDFS(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin DFS\");\n  };\n\n  // DFS implementatoin\n  const dfs = async () => {\n    setAlgorithmStarted(true);\n    setText(\"DFS in progress...\");\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let stepIndex = 0;\n    const dfsRecursive = async currentNode => {\n      if (visitedNodeSet.has(currentNode.id)) {\n        return;\n      }\n      visitedNodeSet.add(currentNode.id);\n      setVisitedNodes(prev => {\n        const updatedNodes = [...prev, {\n          id: currentNode.id,\n          color: treeEdgeColor\n        }];\n        return updatedNodes;\n      });\n      for (let neighborId of adjList[currentNode.id]) {\n        setCurrentNode(currentNode);\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n        if (!edge) {\n          continue;\n        }\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        if (!visitedEdgeSet.has(edge)) {\n          stepIndex++;\n          if (isPausedRef.current) {\n            await new Promise(resolve => {\n              const checkStep = () => {\n                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                  resolve();\n                } else {\n                  setTimeout(checkStep, 50);\n                }\n              };\n              checkStep();\n            });\n            if (isStepModeRef.current) {\n              setIsPaused(true);\n              isPausedRef.current = true;\n            }\n          } else {\n            await sleep(totalSliderCount - sliderValueRef.current);\n          }\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        }\n        if (!visitedNodeSet.has(neighborId)) {\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: treeEdgeColor\n          }]);\n          visitedEdgeSet.add(edge);\n          await dfsRecursive(neighborNode);\n        } else {\n          setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n        }\n      }\n    };\n    await dfsRecursive(startNode);\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"DFS Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to start BFS\n  const startBFS = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"BFS\");\n    setIsBFS(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin BFS\");\n  };\n\n  // BFS implementation\n  const bfs = async startNode => {\n    setAlgorithmStarted(true);\n    setText(\"BFS in progress...\");\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let stepIndex = 0;\n    const queue = [startNode];\n    visitedNodeSet.add(startNode.id);\n    setVisitedNodes([{\n      id: startNode.id,\n      color: treeEdgeColor\n    }]);\n    while (queue.length > 0) {\n      const currentNode = queue.shift();\n      setCurrentNode(currentNode);\n      for (let neighborId of adjList[currentNode.id]) {\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n        if (!edge) {\n          continue;\n        }\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        if (!visitedEdgeSet.has(edge)) {\n          stepIndex++;\n          if (isPausedRef.current) {\n            await new Promise(resolve => {\n              const checkStep = () => {\n                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                  resolve();\n                } else {\n                  setTimeout(checkStep, 50);\n                }\n              };\n              checkStep();\n            });\n            if (isStepModeRef.current) {\n              setIsPaused(true);\n              isPausedRef.current = true;\n            }\n          } else {\n            await sleep(totalSliderCount - sliderValueRef.current);\n          }\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        }\n        if (!visitedNodeSet.has(neighborId)) {\n          visitedNodeSet.add(neighborId);\n          queue.push(neighborNode);\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: treeEdgeColor\n          }]);\n          setVisitedNodes(prev => [...prev, {\n            id: neighborId,\n            color: treeEdgeColor\n          }]);\n        } else {\n          setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n        }\n      }\n    }\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"BFS Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to start Prim's algorithm\n  const startPrim = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"Prim\");\n    setIsPrim(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin Prim's Algorithm\");\n  };\n\n  // Function to animate Prim's algorithm\n  const animatePrimsAlgorithm = async startNode => {\n    setAlgorithmStarted(true);\n    setIsDirected(false);\n    setText(\"Prim's Algorithm in progress...\");\n    const visitedNodeSet = new Set();\n    const edgeQueue = [];\n    let stepIndex = 0;\n    const addEdges = node => {\n      visitedNodeSet.add(node.id);\n      setVisitedNodes(prev => [...prev, {\n        id: node.id,\n        color: treeEdgeColor\n      }]);\n      (adjList[node.id] || []).forEach(neighborId => {\n        if (!visitedNodeSet.has(neighborId)) {\n          const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === node.id);\n          if (edge) {\n            edgeQueue.push({\n              ...edge,\n              length: calculateEdgeLength(edge)\n            });\n          }\n        }\n      });\n      edgeQueue.sort((a, b) => a.length - b.length);\n    };\n    const animateStep = async () => {\n      if (visitedNodeSet.size === nodes.length || edgeQueue.length === 0) {\n        setAlgorithmStarted(false);\n        setText(\"Prim's Algorithm Done!\");\n        setTimeout(resetEdges, 1000);\n        return;\n      }\n      const edgesToHighlight = edgeQueue.slice(0, 1);\n      edgesToHighlight.forEach(edge => {\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n      });\n      stepIndex++;\n      if (isPausedRef.current) {\n        await new Promise(resolve => {\n          const checkStep = () => {\n            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n              resolve();\n            } else {\n              setTimeout(checkStep, 50);\n            }\n          };\n          checkStep();\n        });\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      } else {\n        await sleep(totalSliderCount - sliderValueRef.current);\n      }\n      if (isStepModeRef.current) {\n        setIsPaused(true);\n        isPausedRef.current = true;\n      }\n      const edge = edgeQueue.shift();\n      const {\n        from,\n        to\n      } = edge;\n      const fromInMST = visitedNodeSet.has(from.id);\n      const toInMST = visitedNodeSet.has(to.id);\n      if (fromInMST && !toInMST || !fromInMST && toInMST) {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: treeEdgeColor\n        }]);\n        if (fromInMST && !toInMST) {\n          addEdges(to);\n        } else if (!fromInMST && toInMST) {\n          addEdges(from);\n        }\n      } else {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: defaultEdgeColor\n        }]);\n      }\n      animateStep();\n    };\n    addEdges(startNode);\n    animateStep();\n  };\n\n  // Function to animate Kruskall's algorithm\n  const animateKruskalsAlgorithm = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setIsDirected(false);\n    setRunningAlgorithm(\"Kruskall\");\n    setDisablePause(true);\n    setAlgorithmRunning(true);\n    setText(\"Kruskall's Algorithm in progress...\");\n    const sortedEdges = [...edges].sort((a, b) => calculateEdgeLength(a) - calculateEdgeLength(b));\n    let componentIndex = 0;\n    let currentComponentEdges = [];\n    let currentComponentNodes = [];\n    let uf;\n    const visitedNodeSet = new Set();\n    const foundComponents = [];\n    const dfsComponent = (currentNode, component) => {\n      if (visitedNodeSet.has(currentNode.id)) {\n        return;\n      }\n      visitedNodeSet.add(currentNode.id);\n      component.push(currentNode);\n      adjList[currentNode.id].forEach(neighborId => {\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        if (!visitedNodeSet.has(neighborId)) {\n          dfsComponent(neighborNode, component);\n        }\n      });\n    };\n    nodes.forEach(node => {\n      if (!visitedNodeSet.has(node.id)) {\n        const component = [];\n        dfsComponent(node, component);\n        foundComponents.push(component);\n      }\n    });\n    setComponents(foundComponents);\n    const animateComponentMST = component => {\n      uf = new UnionFind(nodeCount);\n      currentComponentEdges = [];\n      currentComponentNodes = component.map(node => node.id);\n      let edgeIndex = 0;\n      const color = componentColors[componentIndex % componentColors.length];\n      const highlightNodesAndEdges = index => {\n        if (index < currentComponentEdges.length) {\n          const {\n            from,\n            to\n          } = currentComponentEdges[index];\n          setVisitedNodes(prev => [...prev, {\n            id: from.id,\n            color\n          }, {\n            id: to.id,\n            color\n          }]);\n          setVisitedEdges(prev => [...prev, currentComponentEdges[index]]);\n          setTimeout(() => highlightNodesAndEdges(index + 1), totalSliderCount - sliderValueRef.current);\n        } else {\n          componentIndex++;\n          if (componentIndex < foundComponents.length) {\n            setTimeout(() => animateComponentMST(foundComponents[componentIndex]), 0);\n          } else {\n            setTimeout(resetEdges, 1000);\n            setText(\"Kruskall's Algorithm Done!\");\n          }\n        }\n      };\n      const animateStep = () => {\n        if (currentComponentEdges.length === component.length - 1 || edgeIndex >= sortedEdges.length) {\n          highlightNodesAndEdges(0);\n          return;\n        }\n        const edge = sortedEdges[edgeIndex];\n        edgeIndex++;\n        if (currentComponentNodes.includes(edge.from.id) && currentComponentNodes.includes(edge.to.id) && uf.find(edge.from.id) !== uf.find(edge.to.id)) {\n          uf.union(edge.from.id, edge.to.id);\n          currentComponentEdges.push({\n            ...edge,\n            color\n          });\n        }\n        animateStep();\n      };\n      animateStep();\n    };\n    if (foundComponents.length > 0) {\n      animateComponentMST(foundComponents[0]);\n    } else {\n      console.log(\"No components found.\");\n      setAlgorithmRunning(false);\n    }\n  };\n\n  // Function to start shortest path algorithm\n  const startShortestPath = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"SP\");\n    setIsShortestPath(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Start Node for Shortest Path\");\n  };\n\n  // Function to find the shortest path between two nodes\n  const findShortestPath = async (startNode, targetNode) => {\n    setAlgorithmStarted(true);\n    setText(\"Shortest Path Algorithm in progress...\");\n    const dist = {};\n    const prev = {};\n    const visitedEdgeSet = new Set();\n    const visitedNodeSet = new Set();\n    const priorityQueue = new Set(nodes.map(node => node.id));\n    let stepIndex = 0;\n    nodes.forEach(node => {\n      dist[node.id] = Infinity;\n      prev[node.id] = null;\n    });\n    dist[startNode.id] = 0;\n    const getMinDistNode = () => {\n      let minNode = null;\n      priorityQueue.forEach(nodeId => {\n        if (minNode === null || dist[nodeId] < dist[minNode]) {\n          minNode = nodeId;\n        }\n      });\n      return minNode;\n    };\n    while (priorityQueue.size > 0) {\n      const currentNodeId = getMinDistNode();\n      const currentNode = nodes.find(node => node.id === currentNodeId);\n      if (dist[currentNodeId] === Infinity) break;\n      priorityQueue.delete(currentNodeId);\n      if (currentNodeId === targetNode.id) {\n        break;\n      }\n      for (let neighborId of adjList[currentNode.id]) {\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n        if (!edge) {\n          continue;\n        }\n        setCurrentNode(currentNode);\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        if (!visitedEdgeSet.has(edge)) {\n          stepIndex++;\n          if (isPausedRef.current) {\n            await new Promise(resolve => {\n              const checkStep = () => {\n                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                  resolve();\n                } else {\n                  setTimeout(checkStep, 50);\n                }\n              };\n              checkStep();\n            });\n            if (isStepModeRef.current) {\n              setIsPaused(true);\n              isPausedRef.current = true;\n            }\n          } else {\n            await sleep(totalSliderCount - sliderValueRef.current);\n          }\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n          visitedEdgeSet.add(edge);\n        }\n        const alt = dist[currentNode.id] + calculateEdgeLength(edge);\n        if (alt < dist[neighborId]) {\n          dist[neighborId] = alt;\n          prev[neighborId] = currentNode.id;\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: treeEdgeColor\n          }]);\n          visitedEdgeSet.add(edge);\n        } else {\n          setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color === currentEdgeColor)));\n        }\n      }\n      visitedNodeSet.add(currentNode.id);\n      setVisitedNodes(prev => {\n        const updatedNodes = [...prev, {\n          id: currentNode.id,\n          color: treeEdgeColor\n        }];\n        return updatedNodes;\n      });\n    }\n    setStartNode(null);\n    setEndNode(null);\n    setAlgorithmStarted(false);\n    setCurrentNode(null);\n    setText(\"Shortest Path Done!\");\n    const path = [];\n    let currentNodeId = targetNode.id;\n    while (currentNodeId !== null) {\n      path.unshift(currentNodeId);\n      currentNodeId = prev[currentNodeId];\n    }\n    if (path.length === 1) {\n      setText(\"No path Found!\");\n      setTimeout(resetEdges, 1000);\n      return;\n    }\n    setVisitedEdges(prev => {\n      return prev.map(e => {\n        if (path.includes(e.from.id) && path.includes(e.to.id)) {\n          return {\n            ...e,\n            color: treeEdgeColor\n          };\n        } else {\n          return {\n            ...e,\n            color: defaultEdgeColor\n          };\n        }\n      });\n    });\n    setVisitedNodes(prev => {\n      return nodes.map(node => {\n        if (path.includes(node.id)) {\n          return {\n            id: node.id,\n            color: treeEdgeColor\n          };\n        } else {\n          return {\n            id: node.id,\n            color: \"black\"\n          };\n        }\n      });\n    });\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to start TSP\n  const startTSP = async () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"TSP\");\n    setIsTSP(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin TSP\");\n  };\n\n  // Function to animate TSP\n  const tsp = async node => {\n    setAlgorithmStarted(true);\n    setText(\"TSP in progress...\");\n    const startNode = node;\n    const unvisited = new Set(nodes.map(node => node.id));\n    const visited = [];\n    const stack = [];\n    let currentNode = startNode;\n    let stepIndex = 0;\n    unvisited.delete(currentNode.id);\n    visited.push(currentNode);\n    setVisitedNodes([{\n      id: currentNode.id,\n      color: treeEdgeColor\n    }]);\n    while (unvisited.size > 0) {\n      let nearestNode = null;\n      let shortestDistance = Infinity;\n      let currentEdge = null;\n      for (let neighborId of unvisited) {\n        setCurrentNode(currentNode);\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        // eslint-disable-next-line\n        const edge = edges.find(e => isDirected && e && e.from && e.to && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && e && e.from && e.to && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n        if (!edge) {\n          continue;\n        }\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n        const distance = calculateEdgeLength({\n          from: currentNode,\n          to: neighborNode\n        });\n        setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)));\n        if (distance < shortestDistance) {\n          shortestDistance = distance;\n          nearestNode = neighborNode;\n          currentEdge = edge;\n        }\n      }\n      if (nearestNode && currentEdge) {\n        stack.push({\n          currentNode,\n          nearestNode,\n          shortestDistance\n        });\n        setVisitedEdges(prev => [...prev, {\n          ...currentEdge,\n          color: treeEdgeColor\n        }]);\n        setVisitedNodes(prev => [...prev, {\n          id: nearestNode.id,\n          color: treeEdgeColor\n        }]);\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n        currentNode = nearestNode;\n        unvisited.delete(currentNode.id);\n        visited.push(currentNode);\n      } else {\n        const previousState = stack.pop();\n        if (previousState) {\n          currentNode = previousState.currentNode;\n        } else {\n          break;\n        }\n      }\n    }\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"TSP Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to color graph\n  const graphColoring = async () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"Color\");\n    setDisablePause(true);\n    setAlgorithmRunning(true);\n    setText(\"Graph Coloring in progress...\");\n    const availableColors = componentColors;\n    const colors = {};\n    const colorGraph = node => {\n      const neighborColors = adjList[node.id].map(neighborId => colors[neighborId]);\n      for (let color of availableColors) {\n        if (!neighborColors.includes(color)) {\n          colors[node.id] = color;\n          break;\n        }\n      }\n    };\n    for (let node of nodes) {\n      colorGraph(node);\n      setVisitedNodes(prev => [...prev, {\n        id: node.id,\n        color: colors[node.id]\n      }]);\n      await new Promise(resolve => setTimeout(resolve, totalSliderCount - sliderValueRef.current));\n    }\n    setText(\"Graph Coloring Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to find connected components in a graph\n  const findConnectedComponents = async () => {\n    setRunningAlgorithm(\"Connected\");\n    setAlgorithmStarted(true);\n    setText(\"Connected Components in progress...\");\n    setAlgorithmRunning(true);\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let componentIndex = 0;\n    let stepIndex = 0;\n    const dfsRecursive = async (currentNode, componentColor) => {\n      if (visitedNodeSet.has(currentNode.id)) {\n        return;\n      }\n      visitedNodeSet.add(currentNode.id);\n      setVisitedNodes(prev => {\n        const updatedNodes = [...prev, {\n          id: currentNode.id,\n          color: componentColor\n        }];\n        return updatedNodes;\n      });\n      for (let neighborId of adjList[currentNode.id]) {\n        setCurrentNode(currentNode);\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        const edge = edges.find(e => e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id);\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        if (!visitedEdgeSet.has(edge)) {\n          stepIndex++;\n          if (isPausedRef.current) {\n            await new Promise(resolve => {\n              const checkStep = () => {\n                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                  resolve();\n                } else {\n                  setTimeout(checkStep, 50);\n                }\n              };\n              checkStep();\n            });\n            if (isStepModeRef.current) {\n              setIsPaused(true);\n              isPausedRef.current = true;\n            }\n          } else {\n            await sleep(totalSliderCount - sliderValueRef.current);\n          }\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        }\n        if (!visitedNodeSet.has(neighborId)) {\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: componentColor\n          }]);\n          visitedEdgeSet.add(edge);\n          await dfsRecursive(neighborNode, componentColor);\n        } else {\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: componentColor\n          }]);\n        }\n      }\n    };\n    for (let node of nodes) {\n      if (!visitedNodeSet.has(node.id)) {\n        const componentColor = componentColors[componentIndex % componentColors.length];\n        componentIndex++;\n        await dfsRecursive(node, componentColor);\n      }\n    }\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"Connected Components Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to find strong components\n  const findStrongComponents = async () => {\n    setRunningAlgorithm(\"Connected\");\n    setAlgorithmStarted(true);\n    setText(\"Strong Components in progress...\");\n    setAlgorithmRunning(true);\n    const stack = [];\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    const reverseAdjList = {};\n    let stepIndex = 0;\n    const dfs1 = async node => {\n      if (visitedNodeSet.has(node.id)) {\n        return;\n      }\n      visitedNodeSet.add(node.id);\n      for (let neighborId of adjList[node.id]) {\n        if (!visitedNodeSet.has(neighborId)) {\n          const neighborNode = nodes.find(n => n.id === neighborId);\n          await dfs1(neighborNode);\n        }\n      }\n      stack.push(node);\n    };\n    const reverseGraph = () => {\n      nodes.forEach(node => {\n        reverseAdjList[node.id] = [];\n      });\n      edges.forEach(edge => {\n        reverseAdjList[edge.to.id].push(edge.from.id);\n      });\n    };\n    const dfs2 = async (node, componentColor) => {\n      if (visitedNodeSet.has(node.id)) {\n        return;\n      }\n      visitedNodeSet.add(node.id);\n      setVisitedNodes(prev => {\n        const updatedNodes = [...prev, {\n          id: node.id,\n          color: componentColor\n        }];\n        return updatedNodes;\n      });\n      for (let neighborId of reverseAdjList[node.id]) {\n        setCurrentNode(node);\n        const neighborNode = nodes.find(n => n.id === neighborId);\n        const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId);\n        if (!edge) {\n          continue;\n        }\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        if (!visitedEdgeSet.has(edge)) {\n          stepIndex++;\n          if (isPausedRef.current) {\n            await new Promise(resolve => {\n              const checkStep = () => {\n                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                  resolve();\n                } else {\n                  setTimeout(checkStep, 50);\n                }\n              };\n              checkStep();\n            });\n            if (isStepModeRef.current) {\n              setIsPaused(true);\n              isPausedRef.current = true;\n            }\n          } else {\n            await sleep(totalSliderCount - sliderValueRef.current);\n          }\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        }\n        if (!visitedNodeSet.has(neighborId)) {\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: componentColor\n          }]);\n          visitedEdgeSet.add(edge);\n          await dfs2(neighborNode, componentColor);\n        } else {\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: componentColor\n          }]);\n        }\n      }\n    };\n    reverseGraph();\n    for (let node of nodes) {\n      if (!visitedNodeSet.has(node.id)) {\n        await dfs1(node);\n      }\n    }\n    visitedNodeSet.clear();\n    visitedEdgeSet.clear();\n    let componentIndex = 0;\n    while (stack.length > 0) {\n      const node = stack.pop();\n      if (!visitedNodeSet.has(node.id)) {\n        const componentColor = componentColors[componentIndex % componentColors.length];\n        componentIndex++;\n        await dfs2(node, componentColor);\n      }\n    }\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"Strong Components Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n  return {\n    startDFS,\n    dfs,\n    startBFS,\n    bfs,\n    startPrim,\n    animatePrimsAlgorithm,\n    animateKruskalsAlgorithm,\n    startShortestPath,\n    findShortestPath,\n    startTSP,\n    tsp,\n    graphColoring,\n    findConnectedComponents,\n    findStrongComponents\n  };\n};\n_s(useAlgorithms, \"dhGUJsZ7UIAvC1ADCU+tfUC6eKc=\", false, function () {\n  return [useGraphStates];\n});","map":{"version":3,"names":["sleep","UnionFind","useGraphStates","useAlgorithms","_s","nodes","edges","adjList","setVisitedNodes","setVisitedEdges","setAlgorithmStarted","setText","resetEdges","setCurrentNode","isPausedRef","currentStepRef","isStepModeRef","sliderValueRef","totalSliderCount","componentColors","setComponents","algorithmRunning","isRemovingEdge","setRunningAlgorithm","setIsDFS","setAlgorithmRunning","treeEdgeColor","isDirected","currentEdgeColor","setIsPaused","startNode","setIsBFS","startDFS","dfs","visitedNodeSet","Set","visitedEdgeSet","stepIndex","dfsRecursive","currentNode","has","id","add","prev","updatedNodes","color","neighborId","neighborNode","find","node","edge","e","from","to","current","Promise","resolve","checkStep","setTimeout","filter","startBFS","bfs","queue","length","shift","push","startPrim","setIsPrim","animatePrimsAlgorithm","setIsDirected","edgeQueue","addEdges","forEach","calculateEdgeLength","sort","a","b","animateStep","size","edgesToHighlight","slice","fromInMST","toInMST","defaultEdgeColor","animateKruskalsAlgorithm","setDisablePause","sortedEdges","componentIndex","currentComponentEdges","currentComponentNodes","uf","foundComponents","dfsComponent","component","animateComponentMST","nodeCount","map","edgeIndex","highlightNodesAndEdges","index","includes","union","console","log","startShortestPath","setIsShortestPath","findShortestPath","targetNode","dist","priorityQueue","Infinity","getMinDistNode","minNode","nodeId","currentNodeId","delete","alt","setStartNode","setEndNode","path","unshift","startTSP","setIsTSP","tsp","unvisited","visited","stack","nearestNode","shortestDistance","currentEdge","distance","previousState","pop","graphColoring","availableColors","colors","colorGraph","neighborColors","findConnectedComponents","componentColor","findStrongComponents","reverseAdjList","dfs1","n","reverseGraph","dfs2","clear"],"sources":["/Users/tani/Desktop/visualizer/Visusalizer Project/src/Components/Algorithms.js"],"sourcesContent":["import {sleep} from './GraphUtilities';\nimport UnionFind from './UnionFind';\nimport { useGraphStates } from './Graphs';\n\nexport const useAlgorithms = () => {\n    const {\n        nodes, edges, adjList, setVisitedNodes, setVisitedEdges, setAlgorithmStarted, setText, resetEdges,\n        setCurrentNode, isPausedRef, currentStepRef, isStepModeRef, sliderValueRef, totalSliderCount, \n        componentColors, setComponents, algorithmRunning, isRemovingEdge, setRunningAlgorithm, setIsDFS, setAlgorithmRunning,\n        treeEdgeColor, isDirected, currentEdgeColor, setIsPaused, startNode, setIsBFS\n    } = useGraphStates();\n\n    // Function to start DFS\n    const startDFS = () => {\n        \n        if(algorithmRunning|| isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"DFS\");\n        setIsDFS(true);\n        setAlgorithmRunning(true);\n        setText(\"Select Node to begin DFS\");\n    }\n\n    // DFS implementatoin\n    const dfs = async () => {\n        setAlgorithmStarted(true);\n        setText(\"DFS in progress...\");\n\n        const visitedNodeSet = new Set();\n        const visitedEdgeSet = new Set();\n        let stepIndex = 0;\n\n        const dfsRecursive = async (currentNode) => {\n            if (visitedNodeSet.has(currentNode.id)) {\n                return;\n            }\n\n            visitedNodeSet.add(currentNode.id);\n            setVisitedNodes(prev => { \n                const updatedNodes = [...prev, { id: currentNode.id, color: treeEdgeColor }];\n                return updatedNodes;\n            });\n\n            for (let neighborId of adjList[currentNode.id]) {\n                setCurrentNode(currentNode);     \n                const neighborNode = nodes.find(node => node.id === neighborId); \n                const edge = edges.find(e =>                                     \n                    (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === currentNode.id)))\n                );\n\n                if(!edge){\n                    continue;\n                }\n\n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n            \n                if (!visitedEdgeSet.has(edge)) {\n                    stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                }\n\n                if (!visitedNodeSet.has(neighborId)) { \n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: treeEdgeColor }\n                    ]);\n                    visitedEdgeSet.add(edge);\n\n                    await dfsRecursive(neighborNode);\n                } else {\n                    setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n                }\n            }\n\n        };\n\n        await dfsRecursive(startNode);\n        setCurrentNode(null);\n        setAlgorithmStarted(false);\n        setText(\"DFS Done!\");\n        setTimeout(resetEdges, 1000); \n    };\n\n    // Function to start BFS\n    const startBFS = () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"BFS\");\n        setIsBFS(true);\n        setAlgorithmRunning(true);\n        setText(\"Select Node to begin BFS\");\n    }\n\n    // BFS implementation\n    const bfs = async (startNode) => {\n        setAlgorithmStarted(true);\n        setText(\"BFS in progress...\");\n        const visitedNodeSet = new Set();\n        const visitedEdgeSet = new Set();\n        let stepIndex = 0;\n\n\n        const queue = [startNode];\n        visitedNodeSet.add(startNode.id);\n        setVisitedNodes([{ id: startNode.id, color: treeEdgeColor }]);\n\n        while (queue.length > 0) {\n            const currentNode = queue.shift();\n            setCurrentNode(currentNode);\n            \n            for (let neighborId of adjList[currentNode.id]) {\n                const neighborNode = nodes.find(node => node.id === neighborId);\n                const edge = edges.find(e =>                                     \n                    (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === currentNode.id)))\n                );\n\n                if(!edge){\n                    continue;\n                }\n\n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n                if(!visitedEdgeSet.has(edge)){\n                    stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                }\n\n                if (!visitedNodeSet.has(neighborId)) {\n                    visitedNodeSet.add(neighborId);\n                    queue.push(neighborNode);\n\n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: treeEdgeColor }\n                    ]);\n                    setVisitedNodes(prev => [...prev, { id: neighborId, color: treeEdgeColor }]);\n\n                } else{\n                    setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n                }\n                \n            }\n        }\n\n        setCurrentNode(null);\n        setAlgorithmStarted(false);\n        setText(\"BFS Done!\");\n        setTimeout(resetEdges, 1000); \n    };\n\n    // Function to start Prim's algorithm\n    const startPrim = () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"Prim\");\n        setIsPrim(true);\n        setAlgorithmRunning(true);\n        setText(\"Select Node to begin Prim's Algorithm\");\n    }\n\n    // Function to animate Prim's algorithm\n    const animatePrimsAlgorithm = async (startNode) => {\n        setAlgorithmStarted(true);\n        setIsDirected(false);\n        setText(\"Prim's Algorithm in progress...\");\n        const visitedNodeSet = new Set();\n        const edgeQueue = [];\n        let stepIndex = 0;\n\n        const addEdges = (node) => {\n            visitedNodeSet.add(node.id);\n            setVisitedNodes(prev => [...prev, { id: node.id, color: treeEdgeColor }]);\n            (adjList[node.id] || []).forEach(neighborId => {\n                if (!visitedNodeSet.has(neighborId)) {\n                    const edge = edges.find(e => \n                        (e.from.id === node.id && e.to.id === neighborId) ||\n                        (e.from.id === neighborId && e.to.id === node.id)\n                    );\n                    if (edge) {\n                        edgeQueue.push({ ...edge, length: calculateEdgeLength(edge) });\n                    }\n                }\n            });\n            edgeQueue.sort((a, b) => a.length - b.length); \n        };\n\n        const animateStep = async () => {\n            if (visitedNodeSet.size === nodes.length || edgeQueue.length === 0) {\n                setAlgorithmStarted(false);\n                setText(\"Prim's Algorithm Done!\");\n                setTimeout(resetEdges, 1000);\n                return;\n            }\n\n            const edgesToHighlight = edgeQueue.slice(0, 1); \n            edgesToHighlight.forEach(edge => {\n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n            });\n\n            stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n\n            const edge = edgeQueue.shift();\n            const { from, to } = edge;\n            const fromInMST = visitedNodeSet.has(from.id);\n            const toInMST = visitedNodeSet.has(to.id);\n\n            if ((fromInMST && !toInMST) || (!fromInMST && toInMST)) {\n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: treeEdgeColor }\n                ]);\n\n                if (fromInMST && !toInMST) {\n                    addEdges(to);\n                } else if (!fromInMST && toInMST) {\n                    addEdges(from);\n                }\n            } else {\n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: defaultEdgeColor }\n                ]);\n            }\n\n            animateStep();\n        };\n\n        addEdges(startNode);\n        animateStep();\n    };\n\n    // Function to animate Kruskall's algorithm\n    const animateKruskalsAlgorithm = () => {\n        if (algorithmRunning || isRemovingEdge) {\n            return;\n        }\n        setIsDirected(false);\n        setRunningAlgorithm(\"Kruskall\");\n        setDisablePause(true);\n        setAlgorithmRunning(true);\n        setText(\"Kruskall's Algorithm in progress...\");\n\n        const sortedEdges = [...edges].sort((a, b) => calculateEdgeLength(a) - calculateEdgeLength(b));\n        let componentIndex = 0;\n        let currentComponentEdges = [];\n        let currentComponentNodes = [];\n        let uf;\n\n        const visitedNodeSet = new Set();\n        const foundComponents = [];\n\n        const dfsComponent = (currentNode, component) => {\n            if (visitedNodeSet.has(currentNode.id)) {\n                return;\n            }\n            visitedNodeSet.add(currentNode.id);\n            component.push(currentNode);\n            adjList[currentNode.id].forEach(neighborId => {\n                const neighborNode = nodes.find(node => node.id === neighborId);\n                if (!visitedNodeSet.has(neighborId)) {\n                    dfsComponent(neighborNode, component);\n                }\n            });\n        };\n\n        nodes.forEach(node => {\n            if (!visitedNodeSet.has(node.id)) {\n                const component = [];\n                dfsComponent(node, component);\n                foundComponents.push(component);\n            }\n        });\n\n        setComponents(foundComponents);\n\n        const animateComponentMST = (component) => {\n            uf = new UnionFind(nodeCount); \n            currentComponentEdges = [];\n            currentComponentNodes = component.map(node => node.id);\n            let edgeIndex = 0;\n            const color = componentColors[componentIndex % componentColors.length];\n\n            const highlightNodesAndEdges = (index) => {\n                if (index < currentComponentEdges.length) {\n                    const { from, to } = currentComponentEdges[index];\n                    setVisitedNodes(prev => [...prev, { id: from.id, color }, { id: to.id, color }]);\n                    setVisitedEdges(prev => [...prev, currentComponentEdges[index]]);\n                    setTimeout(() => highlightNodesAndEdges(index + 1), totalSliderCount - sliderValueRef.current); \n                } else {\n                    componentIndex++;\n                    if (componentIndex < foundComponents.length) {\n                        setTimeout(() => animateComponentMST(foundComponents[componentIndex]), 0); \n                    } else {\n                        setTimeout(resetEdges, 1000);\n                        setText(\"Kruskall's Algorithm Done!\");\n                    }\n                }\n            };\n\n            const animateStep = () => {\n                if (currentComponentEdges.length === component.length - 1 || edgeIndex >= sortedEdges.length) {\n                    highlightNodesAndEdges(0);\n                    return;\n                }\n\n                const edge = sortedEdges[edgeIndex];\n                edgeIndex++;\n\n                if (currentComponentNodes.includes(edge.from.id) && currentComponentNodes.includes(edge.to.id) &&\n                    uf.find(edge.from.id) !== uf.find(edge.to.id)) {\n                    uf.union(edge.from.id, edge.to.id);\n                    currentComponentEdges.push({ ...edge, color });\n                }\n\n                animateStep();\n            };\n\n            animateStep();\n        };\n\n        if (foundComponents.length > 0) {\n            animateComponentMST(foundComponents[0]);\n        } else {\n            console.log(\"No components found.\");\n            setAlgorithmRunning(false);\n        }\n    };\n\n    // Function to start shortest path algorithm\n    const startShortestPath = () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"SP\");\n\n        setIsShortestPath(true);\n        setAlgorithmRunning(true);\n        setText(\"Select Start Node for Shortest Path\");\n    }\n\n    // Function to find the shortest path between two nodes\n    const findShortestPath = async (startNode, targetNode) => {\n        setAlgorithmStarted(true);\n        setText(\"Shortest Path Algorithm in progress...\");\n        const dist = {};\n        const prev = {};\n        const visitedEdgeSet = new Set();\n        const visitedNodeSet = new Set();\n        const priorityQueue = new Set(nodes.map(node => node.id)); \n        let stepIndex = 0;\n\n        nodes.forEach(node => {\n            dist[node.id] = Infinity;\n            prev[node.id] = null;\n        });\n        dist[startNode.id] = 0;\n\n        const getMinDistNode = () => {\n            let minNode = null;\n            priorityQueue.forEach(nodeId => {\n                if (minNode === null || dist[nodeId] < dist[minNode]) {\n                    minNode = nodeId;\n                }\n            });\n            return minNode;\n        };\n\n        while (priorityQueue.size > 0) {\n            const currentNodeId = getMinDistNode();\n            const currentNode = nodes.find(node => node.id === currentNodeId);\n\n            if (dist[currentNodeId] === Infinity) break;\n\n            priorityQueue.delete(currentNodeId);\n\n            if (currentNodeId === targetNode.id) {\n                break;\n            }\n\n            for (let neighborId of adjList[currentNode.id]) {\n                const neighborNode = nodes.find(node => node.id === neighborId);\n                const edge = edges.find(e => \n                    (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === currentNode.id)))\n                );\n\n                if(!edge){\n                    continue;\n                }\n\n                setCurrentNode(currentNode);\n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n                if (!visitedEdgeSet.has(edge)) {\n                    stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                    visitedEdgeSet.add(edge);\n                }\n\n                const alt = dist[currentNode.id] + calculateEdgeLength(edge);\n\n                if (alt < dist[neighborId]) {\n                    dist[neighborId] = alt;\n                    prev[neighborId] = currentNode.id;\n\n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: treeEdgeColor }\n                    ]);\n\n                    visitedEdgeSet.add(edge);\n                } else {\n                    setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color === currentEdgeColor)));\n                }\n            }\n\n            visitedNodeSet.add(currentNode.id);\n            setVisitedNodes(prev => {\n                const updatedNodes = [...prev, { id: currentNode.id, color: treeEdgeColor }];\n                return updatedNodes;\n            });\n        }\n\n        setStartNode(null);\n        setEndNode(null);\n        setAlgorithmStarted(false);\n        setCurrentNode(null);\n        setText(\"Shortest Path Done!\");\n\n        const path = [];\n\n        let currentNodeId = targetNode.id;\n        while (currentNodeId !== null) {\n            path.unshift(currentNodeId);\n            currentNodeId = prev[currentNodeId];\n        }\n\n        if(path.length === 1){\n            setText(\"No path Found!\");\n            setTimeout(resetEdges, 1000);\n            return;\n        }\n\n        setVisitedEdges(prev => {\n            return prev.map(e => {\n                if (path.includes(e.from.id) && path.includes(e.to.id)) {\n                    return { ...e, color: treeEdgeColor };\n                } else {\n                    return { ...e, color: defaultEdgeColor };\n                }\n            });\n        });\n\n        setVisitedNodes(prev => {\n            return nodes.map(node => {\n                if (path.includes(node.id)) {\n                    return { id: node.id, color: treeEdgeColor };\n                } else {\n                    return { id: node.id, color: \"black\" };\n                }\n            });\n        });\n\n        setTimeout(resetEdges, 1000);\n    };\n\n    // Function to start TSP\n    const startTSP = async () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"TSP\");\n        setIsTSP(true);\n        setAlgorithmRunning(true);\n        setText(\"Select Node to begin TSP\");\n    }\n\n    // Function to animate TSP\n    const tsp = async (node) => {\n        setAlgorithmStarted(true);\n        setText(\"TSP in progress...\");\n        const startNode = node;\n        const unvisited = new Set(nodes.map(node => node.id));\n        const visited = [];\n        const stack = [];\n        let currentNode = startNode;\n        let stepIndex = 0;\n\n        unvisited.delete(currentNode.id);\n        visited.push(currentNode);\n        setVisitedNodes([{ id: currentNode.id, color: treeEdgeColor }]);\n\n        while (unvisited.size > 0) {\n            let nearestNode = null;\n            let shortestDistance = Infinity;\n            let currentEdge = null;\n\n            for (let neighborId of unvisited) {\n                setCurrentNode(currentNode);\n                const neighborNode = nodes.find(node => node.id === neighborId);\n                // eslint-disable-next-line\n                const edge = edges.find(e => \n                    (isDirected && e && e.from && e.to && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (!isDirected && e && e.from && e.to && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === currentNode.id)))\n                );\n\n                if (!edge) {\n                    continue;\n                }\n                \n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n                stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n                const distance = calculateEdgeLength({ from: currentNode, to: neighborNode });\n                setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)));\n                if (distance < shortestDistance) {\n                    shortestDistance = distance;\n                    nearestNode = neighborNode;\n                    currentEdge = edge;\n                }\n                \n            }\n\n            if (nearestNode && currentEdge) {\n                stack.push({ currentNode, nearestNode, shortestDistance });\n\n                setVisitedEdges(prev => [...prev, { ...currentEdge, color: treeEdgeColor }]);\n                setVisitedNodes(prev => [...prev, { id: nearestNode.id, color: treeEdgeColor }]);\n\n                stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n\n                currentNode = nearestNode;\n                unvisited.delete(currentNode.id);\n                visited.push(currentNode);\n            } else {\n                const previousState = stack.pop();\n                if (previousState) {\n                    currentNode = previousState.currentNode;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        setCurrentNode(null);\n        setAlgorithmStarted(false);\n        setText(\"TSP Done!\");\n        setTimeout(resetEdges, 1000);\n    };\n\n    // Function to color graph\n    const graphColoring = async () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"Color\");\n        setDisablePause(true);\n        setAlgorithmRunning(true);\n        setText(\"Graph Coloring in progress...\");\n\n        const availableColors = componentColors;\n        const colors = {};\n\n        const colorGraph = (node) => {\n            const neighborColors = adjList[node.id].map(neighborId => colors[neighborId]);\n            for(let color of availableColors){\n                if(!neighborColors.includes(color)){\n                    colors[node.id] = color;\n                    break;\n                }\n            }\n        }\n\n        for(let node of nodes){\n            colorGraph(node);\n            setVisitedNodes(prev => [...prev, {id: node.id, color: colors[node.id]}]);\n            await new Promise(resolve => setTimeout(resolve, totalSliderCount - sliderValueRef.current));\n        }\n\n        setText(\"Graph Coloring Done!\");\n        setTimeout(resetEdges, 1000);\n    }\n\n    // Function to find connected components in a graph\n    const findConnectedComponents = async () => {\n        setRunningAlgorithm(\"Connected\");\n        setAlgorithmStarted(true);\n        setText(\"Connected Components in progress...\");\n        setAlgorithmRunning(true);\n        const visitedNodeSet = new Set();\n        const visitedEdgeSet = new Set();\n        let componentIndex = 0;\n        let stepIndex = 0;\n\n        const dfsRecursive = async (currentNode, componentColor) => {\n            if (visitedNodeSet.has(currentNode.id)) {\n                return;\n            }\n\n            visitedNodeSet.add(currentNode.id);\n            setVisitedNodes(prev => { \n                const updatedNodes = [...prev, { id: currentNode.id, color: componentColor }];\n                return updatedNodes;\n            });\n\n            for (let neighborId of adjList[currentNode.id]) {\n                setCurrentNode(currentNode);     \n                const neighborNode = nodes.find(node => node.id === neighborId); \n                const edge = edges.find(e =>                                     \n                    (e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === currentNode.id)\n                );\n\n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n                if (!visitedEdgeSet.has(edge)) {\n                    stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                }\n\n                if (!visitedNodeSet.has(neighborId)) { \n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: componentColor }\n                    ]);\n                    visitedEdgeSet.add(edge);\n\n                    await dfsRecursive(neighborNode, componentColor);\n                } else {\n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: componentColor }\n                    ]);\n                }\n            }\n        };\n\n        for (let node of nodes) {\n            if (!visitedNodeSet.has(node.id)) {\n                const componentColor = componentColors[componentIndex % componentColors.length];\n                componentIndex++;\n                await dfsRecursive(node, componentColor);\n            }\n        }\n\n        setCurrentNode(null);\n        setAlgorithmStarted(false);\n        setText(\"Connected Components Done!\");\n        setTimeout(resetEdges, 1000); \n    };\n\n    // Function to find strong components\n    const findStrongComponents = async () => {\n        setRunningAlgorithm(\"Connected\");\n        setAlgorithmStarted(true);\n        setText(\"Strong Components in progress...\");\n        setAlgorithmRunning(true);\n\n        const stack = [];\n        const visitedNodeSet = new Set();\n        const visitedEdgeSet = new Set();\n        const reverseAdjList = {};\n        let stepIndex = 0;\n\n        const dfs1 = async (node) => {\n            if (visitedNodeSet.has(node.id)) {\n                return;\n            }\n\n            visitedNodeSet.add(node.id);\n            \n            for (let neighborId of adjList[node.id]) {\n                if (!visitedNodeSet.has(neighborId)) {\n                    const neighborNode = nodes.find(n => n.id === neighborId);\n                    await dfs1(neighborNode);\n                }\n            }\n            \n            stack.push(node);\n        };\n\n        const reverseGraph = () => {\n            nodes.forEach(node => {\n                reverseAdjList[node.id] = [];\n            });\n            edges.forEach(edge => {\n                reverseAdjList[edge.to.id].push(edge.from.id);\n            });\n        };\n\n        const dfs2 = async (node, componentColor) => {\n            if (visitedNodeSet.has(node.id)) {\n                return;\n            }\n            \n            visitedNodeSet.add(node.id);\n            setVisitedNodes(prev => { \n                const updatedNodes = [...prev, { id: node.id, color: componentColor }];\n                return updatedNodes;\n            });\n        \n            for (let neighborId of reverseAdjList[node.id]) {\n                setCurrentNode(node);\n                const neighborNode = nodes.find(n => n.id === neighborId);\n                const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId);\n                \n                if (!edge) {\n                    continue;\n                }\n        \n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n        \n                if (!visitedEdgeSet.has(edge)) {\n                    stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if (isStepModeRef.current) {\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n        \n                    if (isStepModeRef.current) {\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                }\n                \n                if (!visitedNodeSet.has(neighborId)) { \n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: componentColor }\n                    ]);\n                    visitedEdgeSet.add(edge);\n\n                    await dfs2(neighborNode, componentColor);\n                } else {\n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: componentColor }\n                    ]);\n                }\n            }\n        };\n\n        reverseGraph();\n\n        for (let node of nodes) {\n            if (!visitedNodeSet.has(node.id)) {\n                await dfs1(node);\n            }\n        }\n\n        visitedNodeSet.clear();\n        visitedEdgeSet.clear();\n\n        let componentIndex = 0;\n        while (stack.length > 0) {\n            const node = stack.pop();\n            if (!visitedNodeSet.has(node.id)) {\n                const componentColor = componentColors[componentIndex % componentColors.length];\n                componentIndex++;\n                await dfs2(node, componentColor);\n            }\n        }\n\n        setCurrentNode(null);\n        setAlgorithmStarted(false);\n        setText(\"Strong Components Done!\");\n        setTimeout(resetEdges, 1000);\n    };\n\n    return {startDFS, dfs, startBFS, bfs, startPrim, animatePrimsAlgorithm, animateKruskalsAlgorithm, startShortestPath, findShortestPath, startTSP, tsp, graphColoring, findConnectedComponents, findStrongComponents};\n\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}