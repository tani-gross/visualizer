{"ast":null,"code":"import { sleep } from './GraphUtilities';\nimport UnionFind from './UnionFind';\nimport { nodes, edges, adjList, setVisitedNodes, setVisitedEdges, setAlgorithmStarted, setText, resetEdges, setCurrentNode, isPausedRef, currentStepRef, isStepModeRef, sliderValueRef, totalSliderCount, componentColors, setComponents } from './Graphs';\n\n// Function to start DFS\nexport const startDFS = () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setRunningAlgorithm(\"DFS\");\n  setIsDFS(true);\n  setAlgorithmRunning(true);\n  setText(\"Select Node to begin DFS\");\n};\n\n// DFS implementatoin\nexport const dfs = async startNode => {\n  setAlgorithmStarted(true);\n  setText(\"DFS in progress...\");\n  const visitedNodeSet = new Set();\n  const visitedEdgeSet = new Set();\n  let stepIndex = 0;\n  const dfsRecursive = async currentNode => {\n    if (visitedNodeSet.has(currentNode.id)) {\n      return;\n    }\n    visitedNodeSet.add(currentNode.id);\n    setVisitedNodes(prev => {\n      const updatedNodes = [...prev, {\n        id: currentNode.id,\n        color: treeEdgeColor\n      }];\n      return updatedNodes;\n    });\n    for (let neighborId of adjList[currentNode.id]) {\n      setCurrentNode(currentNode);\n      const neighborNode = nodes.find(node => node.id === neighborId);\n      const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n      if (!edge) {\n        continue;\n      }\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n      if (!visitedEdgeSet.has(edge)) {\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      }\n      if (!visitedNodeSet.has(neighborId)) {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: treeEdgeColor\n        }]);\n        visitedEdgeSet.add(edge);\n        await dfsRecursive(neighborNode);\n      } else {\n        setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n      }\n    }\n  };\n  await dfsRecursive(startNode);\n  setCurrentNode(null);\n  setAlgorithmStarted(false);\n  setText(\"DFS Done!\");\n  setTimeout(resetEdges, 1000);\n};\n\n// Function to start BFS\nexport const startBFS = () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setRunningAlgorithm(\"BFS\");\n  setIsBFS(true);\n  setAlgorithmRunning(true);\n  setText(\"Select Node to begin BFS\");\n};\n\n// BFS implementation\nexport const bfs = async startNode => {\n  setAlgorithmStarted(true);\n  setText(\"BFS in progress...\");\n  const visitedNodeSet = new Set();\n  const visitedEdgeSet = new Set();\n  let stepIndex = 0;\n  const queue = [startNode];\n  visitedNodeSet.add(startNode.id);\n  setVisitedNodes([{\n    id: startNode.id,\n    color: treeEdgeColor\n  }]);\n  while (queue.length > 0) {\n    const currentNode = queue.shift();\n    setCurrentNode(currentNode);\n    for (let neighborId of adjList[currentNode.id]) {\n      const neighborNode = nodes.find(node => node.id === neighborId);\n      const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n      if (!edge) {\n        continue;\n      }\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n      if (!visitedEdgeSet.has(edge)) {\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      }\n      if (!visitedNodeSet.has(neighborId)) {\n        visitedNodeSet.add(neighborId);\n        queue.push(neighborNode);\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: treeEdgeColor\n        }]);\n        setVisitedNodes(prev => [...prev, {\n          id: neighborId,\n          color: treeEdgeColor\n        }]);\n      } else {\n        setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n      }\n    }\n  }\n  setCurrentNode(null);\n  setAlgorithmStarted(false);\n  setText(\"BFS Done!\");\n  setTimeout(resetEdges, 1000);\n};\n\n// Function to start Prim's algorithm\nexport const startPrim = () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setRunningAlgorithm(\"Prim\");\n  setIsPrim(true);\n  setAlgorithmRunning(true);\n  setText(\"Select Node to begin Prim's Algorithm\");\n};\n\n// Function to animate Prim's algorithm\nexport const animatePrimsAlgorithm = async startNode => {\n  setAlgorithmStarted(true);\n  setIsDirected(false);\n  setText(\"Prim's Algorithm in progress...\");\n  const visitedNodeSet = new Set();\n  const edgeQueue = [];\n  let stepIndex = 0;\n  const addEdges = node => {\n    visitedNodeSet.add(node.id);\n    setVisitedNodes(prev => [...prev, {\n      id: node.id,\n      color: treeEdgeColor\n    }]);\n    (adjList[node.id] || []).forEach(neighborId => {\n      if (!visitedNodeSet.has(neighborId)) {\n        const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === node.id);\n        if (edge) {\n          edgeQueue.push({\n            ...edge,\n            length: calculateEdgeLength(edge)\n          });\n        }\n      }\n    });\n    edgeQueue.sort((a, b) => a.length - b.length);\n  };\n  const animateStep = async () => {\n    if (visitedNodeSet.size === nodes.length || edgeQueue.length === 0) {\n      setAlgorithmStarted(false);\n      setText(\"Prim's Algorithm Done!\");\n      setTimeout(resetEdges, 1000);\n      return;\n    }\n    const edgesToHighlight = edgeQueue.slice(0, 1);\n    edgesToHighlight.forEach(edge => {\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n    });\n    stepIndex++;\n    if (isPausedRef.current) {\n      await new Promise(resolve => {\n        const checkStep = () => {\n          if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n            resolve();\n          } else {\n            setTimeout(checkStep, 50);\n          }\n        };\n        checkStep();\n      });\n      if (isStepModeRef.current) {\n        setIsPaused(true);\n        isPausedRef.current = true;\n      }\n    } else {\n      await sleep(totalSliderCount - sliderValueRef.current);\n    }\n    if (isStepModeRef.current) {\n      setIsPaused(true);\n      isPausedRef.current = true;\n    }\n    const edge = edgeQueue.shift();\n    const {\n      from,\n      to\n    } = edge;\n    const fromInMST = visitedNodeSet.has(from.id);\n    const toInMST = visitedNodeSet.has(to.id);\n    if (fromInMST && !toInMST || !fromInMST && toInMST) {\n      setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n        ...edge,\n        color: treeEdgeColor\n      }]);\n      if (fromInMST && !toInMST) {\n        addEdges(to);\n      } else if (!fromInMST && toInMST) {\n        addEdges(from);\n      }\n    } else {\n      setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n        ...edge,\n        color: defaultEdgeColor\n      }]);\n    }\n    animateStep();\n  };\n  addEdges(startNode);\n  animateStep();\n};\n\n// Function to animate Kruskall's algorithm\nexport const animateKruskalsAlgorithm = () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setIsDirected(false);\n  setRunningAlgorithm(\"Kruskall\");\n  setDisablePause(true);\n  setAlgorithmRunning(true);\n  setText(\"Kruskall's Algorithm in progress...\");\n  const sortedEdges = [...edges].sort((a, b) => calculateEdgeLength(a) - calculateEdgeLength(b));\n  let componentIndex = 0;\n  let currentComponentEdges = [];\n  let currentComponentNodes = [];\n  let uf;\n  const visitedNodeSet = new Set();\n  const foundComponents = [];\n  const dfsComponent = (currentNode, component) => {\n    if (visitedNodeSet.has(currentNode.id)) {\n      return;\n    }\n    visitedNodeSet.add(currentNode.id);\n    component.push(currentNode);\n    adjList[currentNode.id].forEach(neighborId => {\n      const neighborNode = nodes.find(node => node.id === neighborId);\n      if (!visitedNodeSet.has(neighborId)) {\n        dfsComponent(neighborNode, component);\n      }\n    });\n  };\n  nodes.forEach(node => {\n    if (!visitedNodeSet.has(node.id)) {\n      const component = [];\n      dfsComponent(node, component);\n      foundComponents.push(component);\n    }\n  });\n  setComponents(foundComponents);\n  const animateComponentMST = component => {\n    uf = new UnionFind(nodeCount);\n    currentComponentEdges = [];\n    currentComponentNodes = component.map(node => node.id);\n    let edgeIndex = 0;\n    const color = componentColors[componentIndex % componentColors.length];\n    const highlightNodesAndEdges = index => {\n      if (index < currentComponentEdges.length) {\n        const {\n          from,\n          to\n        } = currentComponentEdges[index];\n        setVisitedNodes(prev => [...prev, {\n          id: from.id,\n          color\n        }, {\n          id: to.id,\n          color\n        }]);\n        setVisitedEdges(prev => [...prev, currentComponentEdges[index]]);\n        setTimeout(() => highlightNodesAndEdges(index + 1), totalSliderCount - sliderValueRef.current);\n      } else {\n        componentIndex++;\n        if (componentIndex < foundComponents.length) {\n          setTimeout(() => animateComponentMST(foundComponents[componentIndex]), 0);\n        } else {\n          setTimeout(resetEdges, 1000);\n          setText(\"Kruskall's Algorithm Done!\");\n        }\n      }\n    };\n    const animateStep = () => {\n      if (currentComponentEdges.length === component.length - 1 || edgeIndex >= sortedEdges.length) {\n        highlightNodesAndEdges(0);\n        return;\n      }\n      const edge = sortedEdges[edgeIndex];\n      edgeIndex++;\n      if (currentComponentNodes.includes(edge.from.id) && currentComponentNodes.includes(edge.to.id) && uf.find(edge.from.id) !== uf.find(edge.to.id)) {\n        uf.union(edge.from.id, edge.to.id);\n        currentComponentEdges.push({\n          ...edge,\n          color\n        });\n      }\n      animateStep();\n    };\n    animateStep();\n  };\n  if (foundComponents.length > 0) {\n    animateComponentMST(foundComponents[0]);\n  } else {\n    console.log(\"No components found.\");\n    setAlgorithmRunning(false);\n  }\n};\n\n// Function to start shortest path algorithm\nexport const startShortestPath = () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setRunningAlgorithm(\"SP\");\n  setIsShortestPath(true);\n  setAlgorithmRunning(true);\n  setText(\"Select Start Node for Shortest Path\");\n};\n\n// Function to find the shortest path between two nodes\nexport const findShortestPath = async (startNode, targetNode) => {\n  setAlgorithmStarted(true);\n  setText(\"Shortest Path Algorithm in progress...\");\n  const dist = {};\n  const prev = {};\n  const visitedEdgeSet = new Set();\n  const visitedNodeSet = new Set();\n  const priorityQueue = new Set(nodes.map(node => node.id));\n  let stepIndex = 0;\n  nodes.forEach(node => {\n    dist[node.id] = Infinity;\n    prev[node.id] = null;\n  });\n  dist[startNode.id] = 0;\n  const getMinDistNode = () => {\n    let minNode = null;\n    priorityQueue.forEach(nodeId => {\n      if (minNode === null || dist[nodeId] < dist[minNode]) {\n        minNode = nodeId;\n      }\n    });\n    return minNode;\n  };\n  while (priorityQueue.size > 0) {\n    const currentNodeId = getMinDistNode();\n    const currentNode = nodes.find(node => node.id === currentNodeId);\n    if (dist[currentNodeId] === Infinity) break;\n    priorityQueue.delete(currentNodeId);\n    if (currentNodeId === targetNode.id) {\n      break;\n    }\n    for (let neighborId of adjList[currentNode.id]) {\n      const neighborNode = nodes.find(node => node.id === neighborId);\n      const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n      if (!edge) {\n        continue;\n      }\n      setCurrentNode(currentNode);\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n      if (!visitedEdgeSet.has(edge)) {\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n        visitedEdgeSet.add(edge);\n      }\n      const alt = dist[currentNode.id] + calculateEdgeLength(edge);\n      if (alt < dist[neighborId]) {\n        dist[neighborId] = alt;\n        prev[neighborId] = currentNode.id;\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: treeEdgeColor\n        }]);\n        visitedEdgeSet.add(edge);\n      } else {\n        setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color === currentEdgeColor)));\n      }\n    }\n    visitedNodeSet.add(currentNode.id);\n    setVisitedNodes(prev => {\n      const updatedNodes = [...prev, {\n        id: currentNode.id,\n        color: treeEdgeColor\n      }];\n      return updatedNodes;\n    });\n  }\n  setStartNode(null);\n  setEndNode(null);\n  setAlgorithmStarted(false);\n  setCurrentNode(null);\n  setText(\"Shortest Path Done!\");\n  const path = [];\n  let currentNodeId = targetNode.id;\n  while (currentNodeId !== null) {\n    path.unshift(currentNodeId);\n    currentNodeId = prev[currentNodeId];\n  }\n  if (path.length === 1) {\n    setText(\"No path Found!\");\n    setTimeout(resetEdges, 1000);\n    return;\n  }\n  setVisitedEdges(prev => {\n    return prev.map(e => {\n      if (path.includes(e.from.id) && path.includes(e.to.id)) {\n        return {\n          ...e,\n          color: treeEdgeColor\n        };\n      } else {\n        return {\n          ...e,\n          color: defaultEdgeColor\n        };\n      }\n    });\n  });\n  setVisitedNodes(prev => {\n    return nodes.map(node => {\n      if (path.includes(node.id)) {\n        return {\n          id: node.id,\n          color: treeEdgeColor\n        };\n      } else {\n        return {\n          id: node.id,\n          color: \"black\"\n        };\n      }\n    });\n  });\n  setTimeout(resetEdges, 1000);\n};\n\n// Function to start TSP\nexport const startTSP = async () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setRunningAlgorithm(\"TSP\");\n  setIsTSP(true);\n  setAlgorithmRunning(true);\n  setText(\"Select Node to begin TSP\");\n};\n\n// Function to animate TSP\nexport const tsp = async node => {\n  setAlgorithmStarted(true);\n  setText(\"TSP in progress...\");\n  const startNode = node;\n  const unvisited = new Set(nodes.map(node => node.id));\n  const visited = [];\n  const stack = [];\n  let currentNode = startNode;\n  let stepIndex = 0;\n  unvisited.delete(currentNode.id);\n  visited.push(currentNode);\n  setVisitedNodes([{\n    id: currentNode.id,\n    color: treeEdgeColor\n  }]);\n  while (unvisited.size > 0) {\n    let nearestNode = null;\n    let shortestDistance = Infinity;\n    let currentEdge = null;\n    for (let neighborId of unvisited) {\n      setCurrentNode(currentNode);\n      const neighborNode = nodes.find(node => node.id === neighborId);\n      // eslint-disable-next-line\n      const edge = edges.find(e => isDirected && e && e.from && e.to && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && e && e.from && e.to && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n      if (!edge) {\n        continue;\n      }\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n      stepIndex++;\n      if (isPausedRef.current) {\n        await new Promise(resolve => {\n          const checkStep = () => {\n            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n              resolve();\n            } else {\n              setTimeout(checkStep, 50);\n            }\n          };\n          checkStep();\n        });\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      } else {\n        await sleep(totalSliderCount - sliderValueRef.current);\n      }\n      if (isStepModeRef.current) {\n        setIsPaused(true);\n        isPausedRef.current = true;\n      }\n      const distance = calculateEdgeLength({\n        from: currentNode,\n        to: neighborNode\n      });\n      setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)));\n      if (distance < shortestDistance) {\n        shortestDistance = distance;\n        nearestNode = neighborNode;\n        currentEdge = edge;\n      }\n    }\n    if (nearestNode && currentEdge) {\n      stack.push({\n        currentNode,\n        nearestNode,\n        shortestDistance\n      });\n      setVisitedEdges(prev => [...prev, {\n        ...currentEdge,\n        color: treeEdgeColor\n      }]);\n      setVisitedNodes(prev => [...prev, {\n        id: nearestNode.id,\n        color: treeEdgeColor\n      }]);\n      stepIndex++;\n      if (isPausedRef.current) {\n        await new Promise(resolve => {\n          const checkStep = () => {\n            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n              resolve();\n            } else {\n              setTimeout(checkStep, 50);\n            }\n          };\n          checkStep();\n        });\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      } else {\n        await sleep(totalSliderCount - sliderValueRef.current);\n      }\n      if (isStepModeRef.current) {\n        setIsPaused(true);\n        isPausedRef.current = true;\n      }\n      currentNode = nearestNode;\n      unvisited.delete(currentNode.id);\n      visited.push(currentNode);\n    } else {\n      const previousState = stack.pop();\n      if (previousState) {\n        currentNode = previousState.currentNode;\n      } else {\n        break;\n      }\n    }\n  }\n  setCurrentNode(null);\n  setAlgorithmStarted(false);\n  setText(\"TSP Done!\");\n  setTimeout(resetEdges, 1000);\n};\n\n// Function to color graph\nexport const graphColoring = async () => {\n  if (algorithmRunning || isRemovingEdge) {\n    return;\n  }\n  setRunningAlgorithm(\"Color\");\n  setDisablePause(true);\n  setAlgorithmRunning(true);\n  setText(\"Graph Coloring in progress...\");\n  const availableColors = componentColors;\n  const colors = {};\n  const colorGraph = node => {\n    const neighborColors = adjList[node.id].map(neighborId => colors[neighborId]);\n    for (let color of availableColors) {\n      if (!neighborColors.includes(color)) {\n        colors[node.id] = color;\n        break;\n      }\n    }\n  };\n  for (let node of nodes) {\n    colorGraph(node);\n    setVisitedNodes(prev => [...prev, {\n      id: node.id,\n      color: colors[node.id]\n    }]);\n    await new Promise(resolve => setTimeout(resolve, totalSliderCount - sliderValueRef.current));\n  }\n  setText(\"Graph Coloring Done!\");\n  setTimeout(resetEdges, 1000);\n};\n\n// Function to find connected components in a graph\nexport const findConnectedComponents = async () => {\n  setRunningAlgorithm(\"Connected\");\n  setAlgorithmStarted(true);\n  setText(\"Connected Components in progress...\");\n  setAlgorithmRunning(true);\n  const visitedNodeSet = new Set();\n  const visitedEdgeSet = new Set();\n  let componentIndex = 0;\n  let stepIndex = 0;\n  const dfsRecursive = async (currentNode, componentColor) => {\n    if (visitedNodeSet.has(currentNode.id)) {\n      return;\n    }\n    visitedNodeSet.add(currentNode.id);\n    setVisitedNodes(prev => {\n      const updatedNodes = [...prev, {\n        id: currentNode.id,\n        color: componentColor\n      }];\n      return updatedNodes;\n    });\n    for (let neighborId of adjList[currentNode.id]) {\n      setCurrentNode(currentNode);\n      const neighborNode = nodes.find(node => node.id === neighborId);\n      const edge = edges.find(e => e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id);\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n      if (!visitedEdgeSet.has(edge)) {\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      }\n      if (!visitedNodeSet.has(neighborId)) {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: componentColor\n        }]);\n        visitedEdgeSet.add(edge);\n        await dfsRecursive(neighborNode, componentColor);\n      } else {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: componentColor\n        }]);\n      }\n    }\n  };\n  for (let node of nodes) {\n    if (!visitedNodeSet.has(node.id)) {\n      const componentColor = componentColors[componentIndex % componentColors.length];\n      componentIndex++;\n      await dfsRecursive(node, componentColor);\n    }\n  }\n  setCurrentNode(null);\n  setAlgorithmStarted(false);\n  setText(\"Connected Components Done!\");\n  setTimeout(resetEdges, 1000);\n};\n\n// Function to find strong components\nexport const findStrongComponents = async () => {\n  setRunningAlgorithm(\"Connected\");\n  setAlgorithmStarted(true);\n  setText(\"Strong Components in progress...\");\n  setAlgorithmRunning(true);\n  const stack = [];\n  const visitedNodeSet = new Set();\n  const visitedEdgeSet = new Set();\n  const reverseAdjList = {};\n  let stepIndex = 0;\n  const dfs1 = async node => {\n    if (visitedNodeSet.has(node.id)) {\n      return;\n    }\n    visitedNodeSet.add(node.id);\n    for (let neighborId of adjList[node.id]) {\n      if (!visitedNodeSet.has(neighborId)) {\n        const neighborNode = nodes.find(n => n.id === neighborId);\n        await dfs1(neighborNode);\n      }\n    }\n    stack.push(node);\n  };\n  const reverseGraph = () => {\n    nodes.forEach(node => {\n      reverseAdjList[node.id] = [];\n    });\n    edges.forEach(edge => {\n      reverseAdjList[edge.to.id].push(edge.from.id);\n    });\n  };\n  const dfs2 = async (node, componentColor) => {\n    if (visitedNodeSet.has(node.id)) {\n      return;\n    }\n    visitedNodeSet.add(node.id);\n    setVisitedNodes(prev => {\n      const updatedNodes = [...prev, {\n        id: node.id,\n        color: componentColor\n      }];\n      return updatedNodes;\n    });\n    for (let neighborId of reverseAdjList[node.id]) {\n      setCurrentNode(node);\n      const neighborNode = nodes.find(n => n.id === neighborId);\n      const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId);\n      if (!edge) {\n        continue;\n      }\n      setVisitedEdges(prev => [...prev, {\n        ...edge,\n        color: currentEdgeColor\n      }]);\n      if (!visitedEdgeSet.has(edge)) {\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      }\n      if (!visitedNodeSet.has(neighborId)) {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: componentColor\n        }]);\n        visitedEdgeSet.add(edge);\n        await dfs2(neighborNode, componentColor);\n      } else {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: componentColor\n        }]);\n      }\n    }\n  };\n  reverseGraph();\n  for (let node of nodes) {\n    if (!visitedNodeSet.has(node.id)) {\n      await dfs1(node);\n    }\n  }\n  visitedNodeSet.clear();\n  visitedEdgeSet.clear();\n  let componentIndex = 0;\n  while (stack.length > 0) {\n    const node = stack.pop();\n    if (!visitedNodeSet.has(node.id)) {\n      const componentColor = componentColors[componentIndex % componentColors.length];\n      componentIndex++;\n      await dfs2(node, componentColor);\n    }\n  }\n  setCurrentNode(null);\n  setAlgorithmStarted(false);\n  setText(\"Strong Components Done!\");\n  setTimeout(resetEdges, 1000);\n};","map":{"version":3,"names":["sleep","UnionFind","nodes","edges","adjList","setVisitedNodes","setVisitedEdges","setAlgorithmStarted","setText","resetEdges","setCurrentNode","isPausedRef","currentStepRef","isStepModeRef","sliderValueRef","totalSliderCount","componentColors","setComponents","startDFS","algorithmRunning","isRemovingEdge","setRunningAlgorithm","setIsDFS","setAlgorithmRunning","dfs","startNode","visitedNodeSet","Set","visitedEdgeSet","stepIndex","dfsRecursive","currentNode","has","id","add","prev","updatedNodes","color","treeEdgeColor","neighborId","neighborNode","find","node","edge","e","isDirected","from","to","currentEdgeColor","current","Promise","resolve","checkStep","setTimeout","setIsPaused","filter","startBFS","setIsBFS","bfs","queue","length","shift","push","startPrim","setIsPrim","animatePrimsAlgorithm","setIsDirected","edgeQueue","addEdges","forEach","calculateEdgeLength","sort","a","b","animateStep","size","edgesToHighlight","slice","fromInMST","toInMST","defaultEdgeColor","animateKruskalsAlgorithm","setDisablePause","sortedEdges","componentIndex","currentComponentEdges","currentComponentNodes","uf","foundComponents","dfsComponent","component","animateComponentMST","nodeCount","map","edgeIndex","highlightNodesAndEdges","index","includes","union","console","log","startShortestPath","setIsShortestPath","findShortestPath","targetNode","dist","priorityQueue","Infinity","getMinDistNode","minNode","nodeId","currentNodeId","delete","alt","setStartNode","setEndNode","path","unshift","startTSP","setIsTSP","tsp","unvisited","visited","stack","nearestNode","shortestDistance","currentEdge","distance","previousState","pop","graphColoring","availableColors","colors","colorGraph","neighborColors","findConnectedComponents","componentColor","findStrongComponents","reverseAdjList","dfs1","n","reverseGraph","dfs2","clear"],"sources":["/Users/tani/Desktop/visualizer/Visusalizer Project/src/Components/Algorithms.js"],"sourcesContent":["import {sleep} from './GraphUtilities';\nimport UnionFind from './UnionFind';\nimport { nodes, edges, adjList, setVisitedNodes, setVisitedEdges, setAlgorithmStarted, setText, resetEdges, setCurrentNode, isPausedRef, currentStepRef, isStepModeRef, sliderValueRef, totalSliderCount, componentColors, setComponents } from './Graphs';\n\n\n// Function to start DFS\nexport const startDFS = () => {\n    if(algorithmRunning|| isRemovingEdge){\n        return;\n    }\n    setRunningAlgorithm(\"DFS\");\n    setIsDFS(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin DFS\");\n}\n\n// DFS implementatoin\nexport const dfs = async (startNode) => {\n    setAlgorithmStarted(true);\n    setText(\"DFS in progress...\");\n\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let stepIndex = 0;\n\n    const dfsRecursive = async (currentNode) => {\n        if (visitedNodeSet.has(currentNode.id)) {\n            return;\n        }\n\n        visitedNodeSet.add(currentNode.id);\n        setVisitedNodes(prev => { \n            const updatedNodes = [...prev, { id: currentNode.id, color: treeEdgeColor }];\n            return updatedNodes;\n        });\n\n        for (let neighborId of adjList[currentNode.id]) {\n            setCurrentNode(currentNode);     \n            const neighborNode = nodes.find(node => node.id === neighborId); \n            const edge = edges.find(e =>                                     \n                (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (e.from.id === neighborId && e.to.id === currentNode.id)))\n            );\n\n            if(!edge){\n                continue;\n            }\n\n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n           \n            if (!visitedEdgeSet.has(edge)) {\n                stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n            }\n\n            if (!visitedNodeSet.has(neighborId)) { \n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: treeEdgeColor }\n                ]);\n                visitedEdgeSet.add(edge);\n\n                await dfsRecursive(neighborNode);\n            } else {\n                setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n            }\n        }\n\n    };\n\n    await dfsRecursive(startNode);\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"DFS Done!\");\n    setTimeout(resetEdges, 1000); \n};\n\n// Function to start BFS\nexport const startBFS = () => {\n    if(algorithmRunning || isRemovingEdge){\n        return;\n    }\n    setRunningAlgorithm(\"BFS\");\n    setIsBFS(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin BFS\");\n}\n\n// BFS implementation\nexport const bfs = async (startNode) => {\n    setAlgorithmStarted(true);\n    setText(\"BFS in progress...\");\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let stepIndex = 0;\n\n\n    const queue = [startNode];\n    visitedNodeSet.add(startNode.id);\n    setVisitedNodes([{ id: startNode.id, color: treeEdgeColor }]);\n\n    while (queue.length > 0) {\n        const currentNode = queue.shift();\n        setCurrentNode(currentNode);\n        \n        for (let neighborId of adjList[currentNode.id]) {\n            const neighborNode = nodes.find(node => node.id === neighborId);\n            const edge = edges.find(e =>                                     \n                (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (e.from.id === neighborId && e.to.id === currentNode.id)))\n            );\n\n            if(!edge){\n                continue;\n            }\n\n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n            if(!visitedEdgeSet.has(edge)){\n                stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n            }\n\n            if (!visitedNodeSet.has(neighborId)) {\n                visitedNodeSet.add(neighborId);\n                queue.push(neighborNode);\n\n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: treeEdgeColor }\n                ]);\n                setVisitedNodes(prev => [...prev, { id: neighborId, color: treeEdgeColor }]);\n\n            } else{\n                setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n            }\n            \n        }\n    }\n\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"BFS Done!\");\n    setTimeout(resetEdges, 1000); \n};\n\n// Function to start Prim's algorithm\nexport const startPrim = () => {\n    if(algorithmRunning || isRemovingEdge){\n        return;\n    }\n    setRunningAlgorithm(\"Prim\");\n    setIsPrim(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin Prim's Algorithm\");\n}\n\n// Function to animate Prim's algorithm\nexport const animatePrimsAlgorithm = async (startNode) => {\n    setAlgorithmStarted(true);\n    setIsDirected(false);\n    setText(\"Prim's Algorithm in progress...\");\n    const visitedNodeSet = new Set();\n    const edgeQueue = [];\n    let stepIndex = 0;\n\n    const addEdges = (node) => {\n        visitedNodeSet.add(node.id);\n        setVisitedNodes(prev => [...prev, { id: node.id, color: treeEdgeColor }]);\n        (adjList[node.id] || []).forEach(neighborId => {\n            if (!visitedNodeSet.has(neighborId)) {\n                const edge = edges.find(e => \n                    (e.from.id === node.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === node.id)\n                );\n                if (edge) {\n                    edgeQueue.push({ ...edge, length: calculateEdgeLength(edge) });\n                }\n            }\n        });\n        edgeQueue.sort((a, b) => a.length - b.length); \n    };\n\n    const animateStep = async () => {\n        if (visitedNodeSet.size === nodes.length || edgeQueue.length === 0) {\n            setAlgorithmStarted(false);\n            setText(\"Prim's Algorithm Done!\");\n            setTimeout(resetEdges, 1000);\n            return;\n        }\n\n        const edgesToHighlight = edgeQueue.slice(0, 1); \n        edgesToHighlight.forEach(edge => {\n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n        });\n\n        stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n\n        const edge = edgeQueue.shift();\n        const { from, to } = edge;\n        const fromInMST = visitedNodeSet.has(from.id);\n        const toInMST = visitedNodeSet.has(to.id);\n\n        if ((fromInMST && !toInMST) || (!fromInMST && toInMST)) {\n            setVisitedEdges(prev => [\n                ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                { ...edge, color: treeEdgeColor }\n            ]);\n\n            if (fromInMST && !toInMST) {\n                addEdges(to);\n            } else if (!fromInMST && toInMST) {\n                addEdges(from);\n            }\n        } else {\n            setVisitedEdges(prev => [\n                ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                { ...edge, color: defaultEdgeColor }\n            ]);\n        }\n\n        animateStep();\n    };\n\n    addEdges(startNode);\n    animateStep();\n};\n\n// Function to animate Kruskall's algorithm\nexport const animateKruskalsAlgorithm = () => {\n    if (algorithmRunning || isRemovingEdge) {\n        return;\n    }\n    setIsDirected(false);\n    setRunningAlgorithm(\"Kruskall\");\n    setDisablePause(true);\n    setAlgorithmRunning(true);\n    setText(\"Kruskall's Algorithm in progress...\");\n\n    const sortedEdges = [...edges].sort((a, b) => calculateEdgeLength(a) - calculateEdgeLength(b));\n    let componentIndex = 0;\n    let currentComponentEdges = [];\n    let currentComponentNodes = [];\n    let uf;\n\n    const visitedNodeSet = new Set();\n    const foundComponents = [];\n\n    const dfsComponent = (currentNode, component) => {\n        if (visitedNodeSet.has(currentNode.id)) {\n            return;\n        }\n        visitedNodeSet.add(currentNode.id);\n        component.push(currentNode);\n        adjList[currentNode.id].forEach(neighborId => {\n            const neighborNode = nodes.find(node => node.id === neighborId);\n            if (!visitedNodeSet.has(neighborId)) {\n                dfsComponent(neighborNode, component);\n            }\n        });\n    };\n\n    nodes.forEach(node => {\n        if (!visitedNodeSet.has(node.id)) {\n            const component = [];\n            dfsComponent(node, component);\n            foundComponents.push(component);\n        }\n    });\n\n    setComponents(foundComponents);\n\n    const animateComponentMST = (component) => {\n        uf = new UnionFind(nodeCount); \n        currentComponentEdges = [];\n        currentComponentNodes = component.map(node => node.id);\n        let edgeIndex = 0;\n        const color = componentColors[componentIndex % componentColors.length];\n\n        const highlightNodesAndEdges = (index) => {\n            if (index < currentComponentEdges.length) {\n                const { from, to } = currentComponentEdges[index];\n                setVisitedNodes(prev => [...prev, { id: from.id, color }, { id: to.id, color }]);\n                setVisitedEdges(prev => [...prev, currentComponentEdges[index]]);\n                setTimeout(() => highlightNodesAndEdges(index + 1), totalSliderCount - sliderValueRef.current); \n            } else {\n                componentIndex++;\n                if (componentIndex < foundComponents.length) {\n                    setTimeout(() => animateComponentMST(foundComponents[componentIndex]), 0); \n                } else {\n                    setTimeout(resetEdges, 1000);\n                    setText(\"Kruskall's Algorithm Done!\");\n                }\n            }\n        };\n\n        const animateStep = () => {\n            if (currentComponentEdges.length === component.length - 1 || edgeIndex >= sortedEdges.length) {\n                highlightNodesAndEdges(0);\n                return;\n            }\n\n            const edge = sortedEdges[edgeIndex];\n            edgeIndex++;\n\n            if (currentComponentNodes.includes(edge.from.id) && currentComponentNodes.includes(edge.to.id) &&\n                uf.find(edge.from.id) !== uf.find(edge.to.id)) {\n                uf.union(edge.from.id, edge.to.id);\n                currentComponentEdges.push({ ...edge, color });\n            }\n\n            animateStep();\n        };\n\n        animateStep();\n    };\n\n    if (foundComponents.length > 0) {\n        animateComponentMST(foundComponents[0]);\n    } else {\n        console.log(\"No components found.\");\n        setAlgorithmRunning(false);\n    }\n};\n\n// Function to start shortest path algorithm\nexport const startShortestPath = () => {\n    if(algorithmRunning || isRemovingEdge){\n        return;\n    }\n    setRunningAlgorithm(\"SP\");\n\n    setIsShortestPath(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Start Node for Shortest Path\");\n}\n\n// Function to find the shortest path between two nodes\nexport const findShortestPath = async (startNode, targetNode) => {\n    setAlgorithmStarted(true);\n    setText(\"Shortest Path Algorithm in progress...\");\n    const dist = {};\n    const prev = {};\n    const visitedEdgeSet = new Set();\n    const visitedNodeSet = new Set();\n    const priorityQueue = new Set(nodes.map(node => node.id)); \n    let stepIndex = 0;\n\n    nodes.forEach(node => {\n        dist[node.id] = Infinity;\n        prev[node.id] = null;\n    });\n    dist[startNode.id] = 0;\n\n    const getMinDistNode = () => {\n        let minNode = null;\n        priorityQueue.forEach(nodeId => {\n            if (minNode === null || dist[nodeId] < dist[minNode]) {\n                minNode = nodeId;\n            }\n        });\n        return minNode;\n    };\n\n    while (priorityQueue.size > 0) {\n        const currentNodeId = getMinDistNode();\n        const currentNode = nodes.find(node => node.id === currentNodeId);\n\n        if (dist[currentNodeId] === Infinity) break;\n\n        priorityQueue.delete(currentNodeId);\n\n        if (currentNodeId === targetNode.id) {\n            break;\n        }\n\n        for (let neighborId of adjList[currentNode.id]) {\n            const neighborNode = nodes.find(node => node.id === neighborId);\n            const edge = edges.find(e => \n                (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (e.from.id === neighborId && e.to.id === currentNode.id)))\n            );\n\n            if(!edge){\n                continue;\n            }\n\n            setCurrentNode(currentNode);\n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n            if (!visitedEdgeSet.has(edge)) {\n                stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n                visitedEdgeSet.add(edge);\n            }\n\n            const alt = dist[currentNode.id] + calculateEdgeLength(edge);\n\n            if (alt < dist[neighborId]) {\n                dist[neighborId] = alt;\n                prev[neighborId] = currentNode.id;\n\n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: treeEdgeColor }\n                ]);\n\n                visitedEdgeSet.add(edge);\n            } else {\n                setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color === currentEdgeColor)));\n            }\n        }\n\n        visitedNodeSet.add(currentNode.id);\n        setVisitedNodes(prev => {\n            const updatedNodes = [...prev, { id: currentNode.id, color: treeEdgeColor }];\n            return updatedNodes;\n        });\n    }\n\n    setStartNode(null);\n    setEndNode(null);\n    setAlgorithmStarted(false);\n    setCurrentNode(null);\n    setText(\"Shortest Path Done!\");\n\n    const path = [];\n\n    let currentNodeId = targetNode.id;\n    while (currentNodeId !== null) {\n        path.unshift(currentNodeId);\n        currentNodeId = prev[currentNodeId];\n    }\n\n    if(path.length === 1){\n        setText(\"No path Found!\");\n        setTimeout(resetEdges, 1000);\n        return;\n    }\n\n    setVisitedEdges(prev => {\n        return prev.map(e => {\n            if (path.includes(e.from.id) && path.includes(e.to.id)) {\n                return { ...e, color: treeEdgeColor };\n            } else {\n                return { ...e, color: defaultEdgeColor };\n            }\n        });\n    });\n\n    setVisitedNodes(prev => {\n        return nodes.map(node => {\n            if (path.includes(node.id)) {\n                return { id: node.id, color: treeEdgeColor };\n            } else {\n                return { id: node.id, color: \"black\" };\n            }\n        });\n    });\n\n    setTimeout(resetEdges, 1000);\n};\n\n// Function to start TSP\nexport const startTSP = async () => {\n    if(algorithmRunning || isRemovingEdge){\n        return;\n    }\n    setRunningAlgorithm(\"TSP\");\n    setIsTSP(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin TSP\");\n}\n\n// Function to animate TSP\nexport const tsp = async (node) => {\n    setAlgorithmStarted(true);\n    setText(\"TSP in progress...\");\n    const startNode = node;\n    const unvisited = new Set(nodes.map(node => node.id));\n    const visited = [];\n    const stack = [];\n    let currentNode = startNode;\n    let stepIndex = 0;\n\n    unvisited.delete(currentNode.id);\n    visited.push(currentNode);\n    setVisitedNodes([{ id: currentNode.id, color: treeEdgeColor }]);\n\n    while (unvisited.size > 0) {\n        let nearestNode = null;\n        let shortestDistance = Infinity;\n        let currentEdge = null;\n\n        for (let neighborId of unvisited) {\n            setCurrentNode(currentNode);\n            const neighborNode = nodes.find(node => node.id === neighborId);\n            // eslint-disable-next-line\n            const edge = edges.find(e => \n                (isDirected && e && e.from && e.to && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (!isDirected && e && e.from && e.to && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (e.from.id === neighborId && e.to.id === currentNode.id)))\n            );\n\n            if (!edge) {\n                continue;\n            }\n            \n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n            stepIndex++;\n            if (isPausedRef.current) {\n                await new Promise(resolve => {\n                    const checkStep = () => {\n                        if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                            resolve();\n                        } else {\n                            setTimeout(checkStep, 50);\n                        }\n                    };\n                    checkStep();\n                });\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n            } else {\n                await sleep(totalSliderCount - sliderValueRef.current);\n            }\n\n            if(isStepModeRef.current){\n                setIsPaused(true);\n                isPausedRef.current = true;\n            }\n            const distance = calculateEdgeLength({ from: currentNode, to: neighborNode });\n            setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)));\n            if (distance < shortestDistance) {\n                shortestDistance = distance;\n                nearestNode = neighborNode;\n                currentEdge = edge;\n            }\n            \n        }\n\n        if (nearestNode && currentEdge) {\n            stack.push({ currentNode, nearestNode, shortestDistance });\n\n            setVisitedEdges(prev => [...prev, { ...currentEdge, color: treeEdgeColor }]);\n            setVisitedNodes(prev => [...prev, { id: nearestNode.id, color: treeEdgeColor }]);\n\n            stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n\n            currentNode = nearestNode;\n            unvisited.delete(currentNode.id);\n            visited.push(currentNode);\n        } else {\n            const previousState = stack.pop();\n            if (previousState) {\n                currentNode = previousState.currentNode;\n            } else {\n                break;\n            }\n        }\n    }\n\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"TSP Done!\");\n    setTimeout(resetEdges, 1000);\n};\n\n// Function to color graph\nexport const graphColoring = async () => {\n    if(algorithmRunning || isRemovingEdge){\n        return;\n    }\n    setRunningAlgorithm(\"Color\");\n    setDisablePause(true);\n    setAlgorithmRunning(true);\n    setText(\"Graph Coloring in progress...\");\n\n    const availableColors = componentColors;\n    const colors = {};\n\n    const colorGraph = (node) => {\n        const neighborColors = adjList[node.id].map(neighborId => colors[neighborId]);\n        for(let color of availableColors){\n            if(!neighborColors.includes(color)){\n                colors[node.id] = color;\n                break;\n            }\n        }\n    }\n\n    for(let node of nodes){\n        colorGraph(node);\n        setVisitedNodes(prev => [...prev, {id: node.id, color: colors[node.id]}]);\n        await new Promise(resolve => setTimeout(resolve, totalSliderCount - sliderValueRef.current));\n    }\n\n    setText(\"Graph Coloring Done!\");\n    setTimeout(resetEdges, 1000);\n}\n\n// Function to find connected components in a graph\nexport const findConnectedComponents = async () => {\n    setRunningAlgorithm(\"Connected\");\n    setAlgorithmStarted(true);\n    setText(\"Connected Components in progress...\");\n    setAlgorithmRunning(true);\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let componentIndex = 0;\n    let stepIndex = 0;\n\n    const dfsRecursive = async (currentNode, componentColor) => {\n        if (visitedNodeSet.has(currentNode.id)) {\n            return;\n        }\n\n        visitedNodeSet.add(currentNode.id);\n        setVisitedNodes(prev => { \n            const updatedNodes = [...prev, { id: currentNode.id, color: componentColor }];\n            return updatedNodes;\n        });\n\n        for (let neighborId of adjList[currentNode.id]) {\n            setCurrentNode(currentNode);     \n            const neighborNode = nodes.find(node => node.id === neighborId); \n            const edge = edges.find(e =>                                     \n                (e.from.id === currentNode.id && e.to.id === neighborId) ||\n                (e.from.id === neighborId && e.to.id === currentNode.id)\n            );\n\n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n            if (!visitedEdgeSet.has(edge)) {\n                stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n            }\n\n            if (!visitedNodeSet.has(neighborId)) { \n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: componentColor }\n                ]);\n                visitedEdgeSet.add(edge);\n\n                await dfsRecursive(neighborNode, componentColor);\n            } else {\n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: componentColor }\n                ]);\n            }\n        }\n    };\n\n    for (let node of nodes) {\n        if (!visitedNodeSet.has(node.id)) {\n            const componentColor = componentColors[componentIndex % componentColors.length];\n            componentIndex++;\n            await dfsRecursive(node, componentColor);\n        }\n    }\n\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"Connected Components Done!\");\n    setTimeout(resetEdges, 1000); \n};\n\n// Function to find strong components\nexport const findStrongComponents = async () => {\n    setRunningAlgorithm(\"Connected\");\n    setAlgorithmStarted(true);\n    setText(\"Strong Components in progress...\");\n    setAlgorithmRunning(true);\n\n    const stack = [];\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    const reverseAdjList = {};\n    let stepIndex = 0;\n\n    const dfs1 = async (node) => {\n        if (visitedNodeSet.has(node.id)) {\n            return;\n        }\n\n        visitedNodeSet.add(node.id);\n        \n        for (let neighborId of adjList[node.id]) {\n            if (!visitedNodeSet.has(neighborId)) {\n                const neighborNode = nodes.find(n => n.id === neighborId);\n                await dfs1(neighborNode);\n            }\n        }\n        \n        stack.push(node);\n    };\n\n    const reverseGraph = () => {\n        nodes.forEach(node => {\n            reverseAdjList[node.id] = [];\n        });\n        edges.forEach(edge => {\n            reverseAdjList[edge.to.id].push(edge.from.id);\n        });\n    };\n\n    const dfs2 = async (node, componentColor) => {\n        if (visitedNodeSet.has(node.id)) {\n            return;\n        }\n        \n        visitedNodeSet.add(node.id);\n        setVisitedNodes(prev => { \n            const updatedNodes = [...prev, { id: node.id, color: componentColor }];\n            return updatedNodes;\n        });\n    \n        for (let neighborId of reverseAdjList[node.id]) {\n            setCurrentNode(node);\n            const neighborNode = nodes.find(n => n.id === neighborId);\n            const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId);\n            \n            if (!edge) {\n                continue;\n            }\n    \n            setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n    \n            if (!visitedEdgeSet.has(edge)) {\n                stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if (isStepModeRef.current) {\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n    \n                if (isStepModeRef.current) {\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n            }\n            \n            if (!visitedNodeSet.has(neighborId)) { \n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: componentColor }\n                ]);\n                visitedEdgeSet.add(edge);\n\n                await dfs2(neighborNode, componentColor);\n            } else {\n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: componentColor }\n                ]);\n            }\n        }\n    };\n\n    reverseGraph();\n\n    for (let node of nodes) {\n        if (!visitedNodeSet.has(node.id)) {\n            await dfs1(node);\n        }\n    }\n\n    visitedNodeSet.clear();\n    visitedEdgeSet.clear();\n\n    let componentIndex = 0;\n    while (stack.length > 0) {\n        const node = stack.pop();\n        if (!visitedNodeSet.has(node.id)) {\n            const componentColor = componentColors[componentIndex % componentColors.length];\n            componentIndex++;\n            await dfs2(node, componentColor);\n        }\n    }\n\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"Strong Components Done!\");\n    setTimeout(resetEdges, 1000);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}