{"ast":null,"code":"var _s = $RefreshSig$();\nimport { sleep } from './GraphUtilities';\nimport UnionFind from './UnionFind';\nimport { useGraphStates } from './Graphs';\nexport const useAlgorithms = () => {\n  _s();\n  const {\n    nodes,\n    edges,\n    adjList,\n    setVisitedNodes,\n    setVisitedEdges,\n    setAlgorithmStarted,\n    setText,\n    resetEdges,\n    setCurrentNode,\n    isPausedRef,\n    currentStepRef,\n    isStepModeRef,\n    sliderValueRef,\n    totalSliderCount,\n    componentColors,\n    setComponents\n  } = useGraphStates();\n\n  // Function to start DFS\n  const startDFS = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"DFS\");\n    setIsDFS(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin DFS\");\n  };\n\n  // DFS implementatoin\n  const dfs = async () => {\n    setAlgorithmStarted(true);\n    setText(\"DFS in progress...\");\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let stepIndex = 0;\n    const dfsRecursive = async currentNode => {\n      if (visitedNodeSet.has(currentNode.id)) {\n        return;\n      }\n      visitedNodeSet.add(currentNode.id);\n      setVisitedNodes(prev => {\n        const updatedNodes = [...prev, {\n          id: currentNode.id,\n          color: treeEdgeColor\n        }];\n        return updatedNodes;\n      });\n      for (let neighborId of adjList[currentNode.id]) {\n        setCurrentNode(currentNode);\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n        if (!edge) {\n          continue;\n        }\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        if (!visitedEdgeSet.has(edge)) {\n          stepIndex++;\n          if (isPausedRef.current) {\n            await new Promise(resolve => {\n              const checkStep = () => {\n                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                  resolve();\n                } else {\n                  setTimeout(checkStep, 50);\n                }\n              };\n              checkStep();\n            });\n            if (isStepModeRef.current) {\n              setIsPaused(true);\n              isPausedRef.current = true;\n            }\n          } else {\n            await sleep(totalSliderCount - sliderValueRef.current);\n          }\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        }\n        if (!visitedNodeSet.has(neighborId)) {\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: treeEdgeColor\n          }]);\n          visitedEdgeSet.add(edge);\n          await dfsRecursive(neighborNode);\n        } else {\n          setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n        }\n      }\n    };\n    await dfsRecursive(startNode);\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"DFS Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to start BFS\n  const startBFS = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"BFS\");\n    setIsBFS(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin BFS\");\n  };\n\n  // BFS implementation\n  const bfs = async startNode => {\n    setAlgorithmStarted(true);\n    setText(\"BFS in progress...\");\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let stepIndex = 0;\n    const queue = [startNode];\n    visitedNodeSet.add(startNode.id);\n    setVisitedNodes([{\n      id: startNode.id,\n      color: treeEdgeColor\n    }]);\n    while (queue.length > 0) {\n      const currentNode = queue.shift();\n      setCurrentNode(currentNode);\n      for (let neighborId of adjList[currentNode.id]) {\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n        if (!edge) {\n          continue;\n        }\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        if (!visitedEdgeSet.has(edge)) {\n          stepIndex++;\n          if (isPausedRef.current) {\n            await new Promise(resolve => {\n              const checkStep = () => {\n                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                  resolve();\n                } else {\n                  setTimeout(checkStep, 50);\n                }\n              };\n              checkStep();\n            });\n            if (isStepModeRef.current) {\n              setIsPaused(true);\n              isPausedRef.current = true;\n            }\n          } else {\n            await sleep(totalSliderCount - sliderValueRef.current);\n          }\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        }\n        if (!visitedNodeSet.has(neighborId)) {\n          visitedNodeSet.add(neighborId);\n          queue.push(neighborNode);\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: treeEdgeColor\n          }]);\n          setVisitedNodes(prev => [...prev, {\n            id: neighborId,\n            color: treeEdgeColor\n          }]);\n        } else {\n          setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n        }\n      }\n    }\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"BFS Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to start Prim's algorithm\n  const startPrim = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"Prim\");\n    setIsPrim(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin Prim's Algorithm\");\n  };\n\n  // Function to animate Prim's algorithm\n  const animatePrimsAlgorithm = async startNode => {\n    setAlgorithmStarted(true);\n    setIsDirected(false);\n    setText(\"Prim's Algorithm in progress...\");\n    const visitedNodeSet = new Set();\n    const edgeQueue = [];\n    let stepIndex = 0;\n    const addEdges = node => {\n      visitedNodeSet.add(node.id);\n      setVisitedNodes(prev => [...prev, {\n        id: node.id,\n        color: treeEdgeColor\n      }]);\n      (adjList[node.id] || []).forEach(neighborId => {\n        if (!visitedNodeSet.has(neighborId)) {\n          const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === node.id);\n          if (edge) {\n            edgeQueue.push({\n              ...edge,\n              length: calculateEdgeLength(edge)\n            });\n          }\n        }\n      });\n      edgeQueue.sort((a, b) => a.length - b.length);\n    };\n    const animateStep = async () => {\n      if (visitedNodeSet.size === nodes.length || edgeQueue.length === 0) {\n        setAlgorithmStarted(false);\n        setText(\"Prim's Algorithm Done!\");\n        setTimeout(resetEdges, 1000);\n        return;\n      }\n      const edgesToHighlight = edgeQueue.slice(0, 1);\n      edgesToHighlight.forEach(edge => {\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n      });\n      stepIndex++;\n      if (isPausedRef.current) {\n        await new Promise(resolve => {\n          const checkStep = () => {\n            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n              resolve();\n            } else {\n              setTimeout(checkStep, 50);\n            }\n          };\n          checkStep();\n        });\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n      } else {\n        await sleep(totalSliderCount - sliderValueRef.current);\n      }\n      if (isStepModeRef.current) {\n        setIsPaused(true);\n        isPausedRef.current = true;\n      }\n      const edge = edgeQueue.shift();\n      const {\n        from,\n        to\n      } = edge;\n      const fromInMST = visitedNodeSet.has(from.id);\n      const toInMST = visitedNodeSet.has(to.id);\n      if (fromInMST && !toInMST || !fromInMST && toInMST) {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: treeEdgeColor\n        }]);\n        if (fromInMST && !toInMST) {\n          addEdges(to);\n        } else if (!fromInMST && toInMST) {\n          addEdges(from);\n        }\n      } else {\n        setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n          ...edge,\n          color: defaultEdgeColor\n        }]);\n      }\n      animateStep();\n    };\n    addEdges(startNode);\n    animateStep();\n  };\n\n  // Function to animate Kruskall's algorithm\n  const animateKruskalsAlgorithm = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setIsDirected(false);\n    setRunningAlgorithm(\"Kruskall\");\n    setDisablePause(true);\n    setAlgorithmRunning(true);\n    setText(\"Kruskall's Algorithm in progress...\");\n    const sortedEdges = [...edges].sort((a, b) => calculateEdgeLength(a) - calculateEdgeLength(b));\n    let componentIndex = 0;\n    let currentComponentEdges = [];\n    let currentComponentNodes = [];\n    let uf;\n    const visitedNodeSet = new Set();\n    const foundComponents = [];\n    const dfsComponent = (currentNode, component) => {\n      if (visitedNodeSet.has(currentNode.id)) {\n        return;\n      }\n      visitedNodeSet.add(currentNode.id);\n      component.push(currentNode);\n      adjList[currentNode.id].forEach(neighborId => {\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        if (!visitedNodeSet.has(neighborId)) {\n          dfsComponent(neighborNode, component);\n        }\n      });\n    };\n    nodes.forEach(node => {\n      if (!visitedNodeSet.has(node.id)) {\n        const component = [];\n        dfsComponent(node, component);\n        foundComponents.push(component);\n      }\n    });\n    setComponents(foundComponents);\n    const animateComponentMST = component => {\n      uf = new UnionFind(nodeCount);\n      currentComponentEdges = [];\n      currentComponentNodes = component.map(node => node.id);\n      let edgeIndex = 0;\n      const color = componentColors[componentIndex % componentColors.length];\n      const highlightNodesAndEdges = index => {\n        if (index < currentComponentEdges.length) {\n          const {\n            from,\n            to\n          } = currentComponentEdges[index];\n          setVisitedNodes(prev => [...prev, {\n            id: from.id,\n            color\n          }, {\n            id: to.id,\n            color\n          }]);\n          setVisitedEdges(prev => [...prev, currentComponentEdges[index]]);\n          setTimeout(() => highlightNodesAndEdges(index + 1), totalSliderCount - sliderValueRef.current);\n        } else {\n          componentIndex++;\n          if (componentIndex < foundComponents.length) {\n            setTimeout(() => animateComponentMST(foundComponents[componentIndex]), 0);\n          } else {\n            setTimeout(resetEdges, 1000);\n            setText(\"Kruskall's Algorithm Done!\");\n          }\n        }\n      };\n      const animateStep = () => {\n        if (currentComponentEdges.length === component.length - 1 || edgeIndex >= sortedEdges.length) {\n          highlightNodesAndEdges(0);\n          return;\n        }\n        const edge = sortedEdges[edgeIndex];\n        edgeIndex++;\n        if (currentComponentNodes.includes(edge.from.id) && currentComponentNodes.includes(edge.to.id) && uf.find(edge.from.id) !== uf.find(edge.to.id)) {\n          uf.union(edge.from.id, edge.to.id);\n          currentComponentEdges.push({\n            ...edge,\n            color\n          });\n        }\n        animateStep();\n      };\n      animateStep();\n    };\n    if (foundComponents.length > 0) {\n      animateComponentMST(foundComponents[0]);\n    } else {\n      console.log(\"No components found.\");\n      setAlgorithmRunning(false);\n    }\n  };\n\n  // Function to start shortest path algorithm\n  const startShortestPath = () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"SP\");\n    setIsShortestPath(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Start Node for Shortest Path\");\n  };\n\n  // Function to find the shortest path between two nodes\n  const findShortestPath = async (startNode, targetNode) => {\n    setAlgorithmStarted(true);\n    setText(\"Shortest Path Algorithm in progress...\");\n    const dist = {};\n    const prev = {};\n    const visitedEdgeSet = new Set();\n    const visitedNodeSet = new Set();\n    const priorityQueue = new Set(nodes.map(node => node.id));\n    let stepIndex = 0;\n    nodes.forEach(node => {\n      dist[node.id] = Infinity;\n      prev[node.id] = null;\n    });\n    dist[startNode.id] = 0;\n    const getMinDistNode = () => {\n      let minNode = null;\n      priorityQueue.forEach(nodeId => {\n        if (minNode === null || dist[nodeId] < dist[minNode]) {\n          minNode = nodeId;\n        }\n      });\n      return minNode;\n    };\n    while (priorityQueue.size > 0) {\n      const currentNodeId = getMinDistNode();\n      const currentNode = nodes.find(node => node.id === currentNodeId);\n      if (dist[currentNodeId] === Infinity) break;\n      priorityQueue.delete(currentNodeId);\n      if (currentNodeId === targetNode.id) {\n        break;\n      }\n      for (let neighborId of adjList[currentNode.id]) {\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        const edge = edges.find(e => isDirected && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n        if (!edge) {\n          continue;\n        }\n        setCurrentNode(currentNode);\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        if (!visitedEdgeSet.has(edge)) {\n          stepIndex++;\n          if (isPausedRef.current) {\n            await new Promise(resolve => {\n              const checkStep = () => {\n                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                  resolve();\n                } else {\n                  setTimeout(checkStep, 50);\n                }\n              };\n              checkStep();\n            });\n            if (isStepModeRef.current) {\n              setIsPaused(true);\n              isPausedRef.current = true;\n            }\n          } else {\n            await sleep(totalSliderCount - sliderValueRef.current);\n          }\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n          visitedEdgeSet.add(edge);\n        }\n        const alt = dist[currentNode.id] + calculateEdgeLength(edge);\n        if (alt < dist[neighborId]) {\n          dist[neighborId] = alt;\n          prev[neighborId] = currentNode.id;\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: treeEdgeColor\n          }]);\n          visitedEdgeSet.add(edge);\n        } else {\n          setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color === currentEdgeColor)));\n        }\n      }\n      visitedNodeSet.add(currentNode.id);\n      setVisitedNodes(prev => {\n        const updatedNodes = [...prev, {\n          id: currentNode.id,\n          color: treeEdgeColor\n        }];\n        return updatedNodes;\n      });\n    }\n    setStartNode(null);\n    setEndNode(null);\n    setAlgorithmStarted(false);\n    setCurrentNode(null);\n    setText(\"Shortest Path Done!\");\n    const path = [];\n    let currentNodeId = targetNode.id;\n    while (currentNodeId !== null) {\n      path.unshift(currentNodeId);\n      currentNodeId = prev[currentNodeId];\n    }\n    if (path.length === 1) {\n      setText(\"No path Found!\");\n      setTimeout(resetEdges, 1000);\n      return;\n    }\n    setVisitedEdges(prev => {\n      return prev.map(e => {\n        if (path.includes(e.from.id) && path.includes(e.to.id)) {\n          return {\n            ...e,\n            color: treeEdgeColor\n          };\n        } else {\n          return {\n            ...e,\n            color: defaultEdgeColor\n          };\n        }\n      });\n    });\n    setVisitedNodes(prev => {\n      return nodes.map(node => {\n        if (path.includes(node.id)) {\n          return {\n            id: node.id,\n            color: treeEdgeColor\n          };\n        } else {\n          return {\n            id: node.id,\n            color: \"black\"\n          };\n        }\n      });\n    });\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to start TSP\n  const startTSP = async () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"TSP\");\n    setIsTSP(true);\n    setAlgorithmRunning(true);\n    setText(\"Select Node to begin TSP\");\n  };\n\n  // Function to animate TSP\n  const tsp = async node => {\n    setAlgorithmStarted(true);\n    setText(\"TSP in progress...\");\n    const startNode = node;\n    const unvisited = new Set(nodes.map(node => node.id));\n    const visited = [];\n    const stack = [];\n    let currentNode = startNode;\n    let stepIndex = 0;\n    unvisited.delete(currentNode.id);\n    visited.push(currentNode);\n    setVisitedNodes([{\n      id: currentNode.id,\n      color: treeEdgeColor\n    }]);\n    while (unvisited.size > 0) {\n      let nearestNode = null;\n      let shortestDistance = Infinity;\n      let currentEdge = null;\n      for (let neighborId of unvisited) {\n        setCurrentNode(currentNode);\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        // eslint-disable-next-line\n        const edge = edges.find(e => isDirected && e && e.from && e.to && e.from.id === currentNode.id && e.to.id === neighborId || !isDirected && e && e.from && e.to && (e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id));\n        if (!edge) {\n          continue;\n        }\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n        const distance = calculateEdgeLength({\n          from: currentNode,\n          to: neighborNode\n        });\n        setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)));\n        if (distance < shortestDistance) {\n          shortestDistance = distance;\n          nearestNode = neighborNode;\n          currentEdge = edge;\n        }\n      }\n      if (nearestNode && currentEdge) {\n        stack.push({\n          currentNode,\n          nearestNode,\n          shortestDistance\n        });\n        setVisitedEdges(prev => [...prev, {\n          ...currentEdge,\n          color: treeEdgeColor\n        }]);\n        setVisitedNodes(prev => [...prev, {\n          id: nearestNode.id,\n          color: treeEdgeColor\n        }]);\n        stepIndex++;\n        if (isPausedRef.current) {\n          await new Promise(resolve => {\n            const checkStep = () => {\n              if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                resolve();\n              } else {\n                setTimeout(checkStep, 50);\n              }\n            };\n            checkStep();\n          });\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        } else {\n          await sleep(totalSliderCount - sliderValueRef.current);\n        }\n        if (isStepModeRef.current) {\n          setIsPaused(true);\n          isPausedRef.current = true;\n        }\n        currentNode = nearestNode;\n        unvisited.delete(currentNode.id);\n        visited.push(currentNode);\n      } else {\n        const previousState = stack.pop();\n        if (previousState) {\n          currentNode = previousState.currentNode;\n        } else {\n          break;\n        }\n      }\n    }\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"TSP Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to color graph\n  const graphColoring = async () => {\n    if (algorithmRunning || isRemovingEdge) {\n      return;\n    }\n    setRunningAlgorithm(\"Color\");\n    setDisablePause(true);\n    setAlgorithmRunning(true);\n    setText(\"Graph Coloring in progress...\");\n    const availableColors = componentColors;\n    const colors = {};\n    const colorGraph = node => {\n      const neighborColors = adjList[node.id].map(neighborId => colors[neighborId]);\n      for (let color of availableColors) {\n        if (!neighborColors.includes(color)) {\n          colors[node.id] = color;\n          break;\n        }\n      }\n    };\n    for (let node of nodes) {\n      colorGraph(node);\n      setVisitedNodes(prev => [...prev, {\n        id: node.id,\n        color: colors[node.id]\n      }]);\n      await new Promise(resolve => setTimeout(resolve, totalSliderCount - sliderValueRef.current));\n    }\n    setText(\"Graph Coloring Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to find connected components in a graph\n  const findConnectedComponents = async () => {\n    setRunningAlgorithm(\"Connected\");\n    setAlgorithmStarted(true);\n    setText(\"Connected Components in progress...\");\n    setAlgorithmRunning(true);\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    let componentIndex = 0;\n    let stepIndex = 0;\n    const dfsRecursive = async (currentNode, componentColor) => {\n      if (visitedNodeSet.has(currentNode.id)) {\n        return;\n      }\n      visitedNodeSet.add(currentNode.id);\n      setVisitedNodes(prev => {\n        const updatedNodes = [...prev, {\n          id: currentNode.id,\n          color: componentColor\n        }];\n        return updatedNodes;\n      });\n      for (let neighborId of adjList[currentNode.id]) {\n        setCurrentNode(currentNode);\n        const neighborNode = nodes.find(node => node.id === neighborId);\n        const edge = edges.find(e => e.from.id === currentNode.id && e.to.id === neighborId || e.from.id === neighborId && e.to.id === currentNode.id);\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        if (!visitedEdgeSet.has(edge)) {\n          stepIndex++;\n          if (isPausedRef.current) {\n            await new Promise(resolve => {\n              const checkStep = () => {\n                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                  resolve();\n                } else {\n                  setTimeout(checkStep, 50);\n                }\n              };\n              checkStep();\n            });\n            if (isStepModeRef.current) {\n              setIsPaused(true);\n              isPausedRef.current = true;\n            }\n          } else {\n            await sleep(totalSliderCount - sliderValueRef.current);\n          }\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        }\n        if (!visitedNodeSet.has(neighborId)) {\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: componentColor\n          }]);\n          visitedEdgeSet.add(edge);\n          await dfsRecursive(neighborNode, componentColor);\n        } else {\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: componentColor\n          }]);\n        }\n      }\n    };\n    for (let node of nodes) {\n      if (!visitedNodeSet.has(node.id)) {\n        const componentColor = componentColors[componentIndex % componentColors.length];\n        componentIndex++;\n        await dfsRecursive(node, componentColor);\n      }\n    }\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"Connected Components Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n\n  // Function to find strong components\n  const findStrongComponents = async () => {\n    setRunningAlgorithm(\"Connected\");\n    setAlgorithmStarted(true);\n    setText(\"Strong Components in progress...\");\n    setAlgorithmRunning(true);\n    const stack = [];\n    const visitedNodeSet = new Set();\n    const visitedEdgeSet = new Set();\n    const reverseAdjList = {};\n    let stepIndex = 0;\n    const dfs1 = async node => {\n      if (visitedNodeSet.has(node.id)) {\n        return;\n      }\n      visitedNodeSet.add(node.id);\n      for (let neighborId of adjList[node.id]) {\n        if (!visitedNodeSet.has(neighborId)) {\n          const neighborNode = nodes.find(n => n.id === neighborId);\n          await dfs1(neighborNode);\n        }\n      }\n      stack.push(node);\n    };\n    const reverseGraph = () => {\n      nodes.forEach(node => {\n        reverseAdjList[node.id] = [];\n      });\n      edges.forEach(edge => {\n        reverseAdjList[edge.to.id].push(edge.from.id);\n      });\n    };\n    const dfs2 = async (node, componentColor) => {\n      if (visitedNodeSet.has(node.id)) {\n        return;\n      }\n      visitedNodeSet.add(node.id);\n      setVisitedNodes(prev => {\n        const updatedNodes = [...prev, {\n          id: node.id,\n          color: componentColor\n        }];\n        return updatedNodes;\n      });\n      for (let neighborId of reverseAdjList[node.id]) {\n        setCurrentNode(node);\n        const neighborNode = nodes.find(n => n.id === neighborId);\n        const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId);\n        if (!edge) {\n          continue;\n        }\n        setVisitedEdges(prev => [...prev, {\n          ...edge,\n          color: currentEdgeColor\n        }]);\n        if (!visitedEdgeSet.has(edge)) {\n          stepIndex++;\n          if (isPausedRef.current) {\n            await new Promise(resolve => {\n              const checkStep = () => {\n                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                  resolve();\n                } else {\n                  setTimeout(checkStep, 50);\n                }\n              };\n              checkStep();\n            });\n            if (isStepModeRef.current) {\n              setIsPaused(true);\n              isPausedRef.current = true;\n            }\n          } else {\n            await sleep(totalSliderCount - sliderValueRef.current);\n          }\n          if (isStepModeRef.current) {\n            setIsPaused(true);\n            isPausedRef.current = true;\n          }\n        }\n        if (!visitedNodeSet.has(neighborId)) {\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: componentColor\n          }]);\n          visitedEdgeSet.add(edge);\n          await dfs2(neighborNode, componentColor);\n        } else {\n          setVisitedEdges(prev => [...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)), {\n            ...edge,\n            color: componentColor\n          }]);\n        }\n      }\n    };\n    reverseGraph();\n    for (let node of nodes) {\n      if (!visitedNodeSet.has(node.id)) {\n        await dfs1(node);\n      }\n    }\n    visitedNodeSet.clear();\n    visitedEdgeSet.clear();\n    let componentIndex = 0;\n    while (stack.length > 0) {\n      const node = stack.pop();\n      if (!visitedNodeSet.has(node.id)) {\n        const componentColor = componentColors[componentIndex % componentColors.length];\n        componentIndex++;\n        await dfs2(node, componentColor);\n      }\n    }\n    setCurrentNode(null);\n    setAlgorithmStarted(false);\n    setText(\"Strong Components Done!\");\n    setTimeout(resetEdges, 1000);\n  };\n};\n_s(useAlgorithms, \"Dsk9Po2Zvd79mWLJ6e/7rUm7BgE=\", false, function () {\n  return [useGraphStates];\n});","map":{"version":3,"names":["sleep","UnionFind","useGraphStates","useAlgorithms","_s","nodes","edges","adjList","setVisitedNodes","setVisitedEdges","setAlgorithmStarted","setText","resetEdges","setCurrentNode","isPausedRef","currentStepRef","isStepModeRef","sliderValueRef","totalSliderCount","componentColors","setComponents","startDFS","algorithmRunning","isRemovingEdge","setRunningAlgorithm","setIsDFS","setAlgorithmRunning","dfs","visitedNodeSet","Set","visitedEdgeSet","stepIndex","dfsRecursive","currentNode","has","id","add","prev","updatedNodes","color","treeEdgeColor","neighborId","neighborNode","find","node","edge","e","isDirected","from","to","currentEdgeColor","current","Promise","resolve","checkStep","setTimeout","setIsPaused","filter","startNode","startBFS","setIsBFS","bfs","queue","length","shift","push","startPrim","setIsPrim","animatePrimsAlgorithm","setIsDirected","edgeQueue","addEdges","forEach","calculateEdgeLength","sort","a","b","animateStep","size","edgesToHighlight","slice","fromInMST","toInMST","defaultEdgeColor","animateKruskalsAlgorithm","setDisablePause","sortedEdges","componentIndex","currentComponentEdges","currentComponentNodes","uf","foundComponents","dfsComponent","component","animateComponentMST","nodeCount","map","edgeIndex","highlightNodesAndEdges","index","includes","union","console","log","startShortestPath","setIsShortestPath","findShortestPath","targetNode","dist","priorityQueue","Infinity","getMinDistNode","minNode","nodeId","currentNodeId","delete","alt","setStartNode","setEndNode","path","unshift","startTSP","setIsTSP","tsp","unvisited","visited","stack","nearestNode","shortestDistance","currentEdge","distance","previousState","pop","graphColoring","availableColors","colors","colorGraph","neighborColors","findConnectedComponents","componentColor","findStrongComponents","reverseAdjList","dfs1","n","reverseGraph","dfs2","clear"],"sources":["/Users/tani/Desktop/visualizer/Visusalizer Project/src/Components/Algorithms.js"],"sourcesContent":["import {sleep} from './GraphUtilities';\nimport UnionFind from './UnionFind';\nimport { useGraphStates } from './Graphs';\n\nexport const useAlgorithms = () => {\n    const {\n        nodes, edges, adjList, setVisitedNodes, setVisitedEdges, setAlgorithmStarted, setText, resetEdges,\n        setCurrentNode, isPausedRef, currentStepRef, isStepModeRef, sliderValueRef, totalSliderCount, \n        componentColors, setComponents\n    } = useGraphStates();\n\n\n    // Function to start DFS\n    const startDFS = () => {\n        \n        if(algorithmRunning|| isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"DFS\");\n        setIsDFS(true);\n        setAlgorithmRunning(true);\n        setText(\"Select Node to begin DFS\");\n    }\n\n    // DFS implementatoin\n    const dfs = async () => {\n        setAlgorithmStarted(true);\n        setText(\"DFS in progress...\");\n\n        const visitedNodeSet = new Set();\n        const visitedEdgeSet = new Set();\n        let stepIndex = 0;\n\n        const dfsRecursive = async (currentNode) => {\n            if (visitedNodeSet.has(currentNode.id)) {\n                return;\n            }\n\n            visitedNodeSet.add(currentNode.id);\n            setVisitedNodes(prev => { \n                const updatedNodes = [...prev, { id: currentNode.id, color: treeEdgeColor }];\n                return updatedNodes;\n            });\n\n            for (let neighborId of adjList[currentNode.id]) {\n                setCurrentNode(currentNode);     \n                const neighborNode = nodes.find(node => node.id === neighborId); \n                const edge = edges.find(e =>                                     \n                    (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === currentNode.id)))\n                );\n\n                if(!edge){\n                    continue;\n                }\n\n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n            \n                if (!visitedEdgeSet.has(edge)) {\n                    stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                }\n\n                if (!visitedNodeSet.has(neighborId)) { \n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: treeEdgeColor }\n                    ]);\n                    visitedEdgeSet.add(edge);\n\n                    await dfsRecursive(neighborNode);\n                } else {\n                    setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n                }\n            }\n\n        };\n\n        await dfsRecursive(startNode);\n        setCurrentNode(null);\n        setAlgorithmStarted(false);\n        setText(\"DFS Done!\");\n        setTimeout(resetEdges, 1000); \n    };\n\n    // Function to start BFS\n    const startBFS = () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"BFS\");\n        setIsBFS(true);\n        setAlgorithmRunning(true);\n        setText(\"Select Node to begin BFS\");\n    }\n\n    // BFS implementation\n    const bfs = async (startNode) => {\n        setAlgorithmStarted(true);\n        setText(\"BFS in progress...\");\n        const visitedNodeSet = new Set();\n        const visitedEdgeSet = new Set();\n        let stepIndex = 0;\n\n\n        const queue = [startNode];\n        visitedNodeSet.add(startNode.id);\n        setVisitedNodes([{ id: startNode.id, color: treeEdgeColor }]);\n\n        while (queue.length > 0) {\n            const currentNode = queue.shift();\n            setCurrentNode(currentNode);\n            \n            for (let neighborId of adjList[currentNode.id]) {\n                const neighborNode = nodes.find(node => node.id === neighborId);\n                const edge = edges.find(e =>                                     \n                    (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === currentNode.id)))\n                );\n\n                if(!edge){\n                    continue;\n                }\n\n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n                if(!visitedEdgeSet.has(edge)){\n                    stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                }\n\n                if (!visitedNodeSet.has(neighborId)) {\n                    visitedNodeSet.add(neighborId);\n                    queue.push(neighborNode);\n\n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: treeEdgeColor }\n                    ]);\n                    setVisitedNodes(prev => [...prev, { id: neighborId, color: treeEdgeColor }]);\n\n                } else{\n                    setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color !== treeEdgeColor)));\n                }\n                \n            }\n        }\n\n        setCurrentNode(null);\n        setAlgorithmStarted(false);\n        setText(\"BFS Done!\");\n        setTimeout(resetEdges, 1000); \n    };\n\n    // Function to start Prim's algorithm\n    const startPrim = () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"Prim\");\n        setIsPrim(true);\n        setAlgorithmRunning(true);\n        setText(\"Select Node to begin Prim's Algorithm\");\n    }\n\n    // Function to animate Prim's algorithm\n    const animatePrimsAlgorithm = async (startNode) => {\n        setAlgorithmStarted(true);\n        setIsDirected(false);\n        setText(\"Prim's Algorithm in progress...\");\n        const visitedNodeSet = new Set();\n        const edgeQueue = [];\n        let stepIndex = 0;\n\n        const addEdges = (node) => {\n            visitedNodeSet.add(node.id);\n            setVisitedNodes(prev => [...prev, { id: node.id, color: treeEdgeColor }]);\n            (adjList[node.id] || []).forEach(neighborId => {\n                if (!visitedNodeSet.has(neighborId)) {\n                    const edge = edges.find(e => \n                        (e.from.id === node.id && e.to.id === neighborId) ||\n                        (e.from.id === neighborId && e.to.id === node.id)\n                    );\n                    if (edge) {\n                        edgeQueue.push({ ...edge, length: calculateEdgeLength(edge) });\n                    }\n                }\n            });\n            edgeQueue.sort((a, b) => a.length - b.length); \n        };\n\n        const animateStep = async () => {\n            if (visitedNodeSet.size === nodes.length || edgeQueue.length === 0) {\n                setAlgorithmStarted(false);\n                setText(\"Prim's Algorithm Done!\");\n                setTimeout(resetEdges, 1000);\n                return;\n            }\n\n            const edgesToHighlight = edgeQueue.slice(0, 1); \n            edgesToHighlight.forEach(edge => {\n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n            });\n\n            stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n\n            const edge = edgeQueue.shift();\n            const { from, to } = edge;\n            const fromInMST = visitedNodeSet.has(from.id);\n            const toInMST = visitedNodeSet.has(to.id);\n\n            if ((fromInMST && !toInMST) || (!fromInMST && toInMST)) {\n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: treeEdgeColor }\n                ]);\n\n                if (fromInMST && !toInMST) {\n                    addEdges(to);\n                } else if (!fromInMST && toInMST) {\n                    addEdges(from);\n                }\n            } else {\n                setVisitedEdges(prev => [\n                    ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                    { ...edge, color: defaultEdgeColor }\n                ]);\n            }\n\n            animateStep();\n        };\n\n        addEdges(startNode);\n        animateStep();\n    };\n\n    // Function to animate Kruskall's algorithm\n    const animateKruskalsAlgorithm = () => {\n        if (algorithmRunning || isRemovingEdge) {\n            return;\n        }\n        setIsDirected(false);\n        setRunningAlgorithm(\"Kruskall\");\n        setDisablePause(true);\n        setAlgorithmRunning(true);\n        setText(\"Kruskall's Algorithm in progress...\");\n\n        const sortedEdges = [...edges].sort((a, b) => calculateEdgeLength(a) - calculateEdgeLength(b));\n        let componentIndex = 0;\n        let currentComponentEdges = [];\n        let currentComponentNodes = [];\n        let uf;\n\n        const visitedNodeSet = new Set();\n        const foundComponents = [];\n\n        const dfsComponent = (currentNode, component) => {\n            if (visitedNodeSet.has(currentNode.id)) {\n                return;\n            }\n            visitedNodeSet.add(currentNode.id);\n            component.push(currentNode);\n            adjList[currentNode.id].forEach(neighborId => {\n                const neighborNode = nodes.find(node => node.id === neighborId);\n                if (!visitedNodeSet.has(neighborId)) {\n                    dfsComponent(neighborNode, component);\n                }\n            });\n        };\n\n        nodes.forEach(node => {\n            if (!visitedNodeSet.has(node.id)) {\n                const component = [];\n                dfsComponent(node, component);\n                foundComponents.push(component);\n            }\n        });\n\n        setComponents(foundComponents);\n\n        const animateComponentMST = (component) => {\n            uf = new UnionFind(nodeCount); \n            currentComponentEdges = [];\n            currentComponentNodes = component.map(node => node.id);\n            let edgeIndex = 0;\n            const color = componentColors[componentIndex % componentColors.length];\n\n            const highlightNodesAndEdges = (index) => {\n                if (index < currentComponentEdges.length) {\n                    const { from, to } = currentComponentEdges[index];\n                    setVisitedNodes(prev => [...prev, { id: from.id, color }, { id: to.id, color }]);\n                    setVisitedEdges(prev => [...prev, currentComponentEdges[index]]);\n                    setTimeout(() => highlightNodesAndEdges(index + 1), totalSliderCount - sliderValueRef.current); \n                } else {\n                    componentIndex++;\n                    if (componentIndex < foundComponents.length) {\n                        setTimeout(() => animateComponentMST(foundComponents[componentIndex]), 0); \n                    } else {\n                        setTimeout(resetEdges, 1000);\n                        setText(\"Kruskall's Algorithm Done!\");\n                    }\n                }\n            };\n\n            const animateStep = () => {\n                if (currentComponentEdges.length === component.length - 1 || edgeIndex >= sortedEdges.length) {\n                    highlightNodesAndEdges(0);\n                    return;\n                }\n\n                const edge = sortedEdges[edgeIndex];\n                edgeIndex++;\n\n                if (currentComponentNodes.includes(edge.from.id) && currentComponentNodes.includes(edge.to.id) &&\n                    uf.find(edge.from.id) !== uf.find(edge.to.id)) {\n                    uf.union(edge.from.id, edge.to.id);\n                    currentComponentEdges.push({ ...edge, color });\n                }\n\n                animateStep();\n            };\n\n            animateStep();\n        };\n\n        if (foundComponents.length > 0) {\n            animateComponentMST(foundComponents[0]);\n        } else {\n            console.log(\"No components found.\");\n            setAlgorithmRunning(false);\n        }\n    };\n\n    // Function to start shortest path algorithm\n    const startShortestPath = () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"SP\");\n\n        setIsShortestPath(true);\n        setAlgorithmRunning(true);\n        setText(\"Select Start Node for Shortest Path\");\n    }\n\n    // Function to find the shortest path between two nodes\n    const findShortestPath = async (startNode, targetNode) => {\n        setAlgorithmStarted(true);\n        setText(\"Shortest Path Algorithm in progress...\");\n        const dist = {};\n        const prev = {};\n        const visitedEdgeSet = new Set();\n        const visitedNodeSet = new Set();\n        const priorityQueue = new Set(nodes.map(node => node.id)); \n        let stepIndex = 0;\n\n        nodes.forEach(node => {\n            dist[node.id] = Infinity;\n            prev[node.id] = null;\n        });\n        dist[startNode.id] = 0;\n\n        const getMinDistNode = () => {\n            let minNode = null;\n            priorityQueue.forEach(nodeId => {\n                if (minNode === null || dist[nodeId] < dist[minNode]) {\n                    minNode = nodeId;\n                }\n            });\n            return minNode;\n        };\n\n        while (priorityQueue.size > 0) {\n            const currentNodeId = getMinDistNode();\n            const currentNode = nodes.find(node => node.id === currentNodeId);\n\n            if (dist[currentNodeId] === Infinity) break;\n\n            priorityQueue.delete(currentNodeId);\n\n            if (currentNodeId === targetNode.id) {\n                break;\n            }\n\n            for (let neighborId of adjList[currentNode.id]) {\n                const neighborNode = nodes.find(node => node.id === neighborId);\n                const edge = edges.find(e => \n                    (isDirected && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (!isDirected && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === currentNode.id)))\n                );\n\n                if(!edge){\n                    continue;\n                }\n\n                setCurrentNode(currentNode);\n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n                if (!visitedEdgeSet.has(edge)) {\n                    stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                    visitedEdgeSet.add(edge);\n                }\n\n                const alt = dist[currentNode.id] + calculateEdgeLength(edge);\n\n                if (alt < dist[neighborId]) {\n                    dist[neighborId] = alt;\n                    prev[neighborId] = currentNode.id;\n\n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: treeEdgeColor }\n                    ]);\n\n                    visitedEdgeSet.add(edge);\n                } else {\n                    setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id && e.color === currentEdgeColor)));\n                }\n            }\n\n            visitedNodeSet.add(currentNode.id);\n            setVisitedNodes(prev => {\n                const updatedNodes = [...prev, { id: currentNode.id, color: treeEdgeColor }];\n                return updatedNodes;\n            });\n        }\n\n        setStartNode(null);\n        setEndNode(null);\n        setAlgorithmStarted(false);\n        setCurrentNode(null);\n        setText(\"Shortest Path Done!\");\n\n        const path = [];\n\n        let currentNodeId = targetNode.id;\n        while (currentNodeId !== null) {\n            path.unshift(currentNodeId);\n            currentNodeId = prev[currentNodeId];\n        }\n\n        if(path.length === 1){\n            setText(\"No path Found!\");\n            setTimeout(resetEdges, 1000);\n            return;\n        }\n\n        setVisitedEdges(prev => {\n            return prev.map(e => {\n                if (path.includes(e.from.id) && path.includes(e.to.id)) {\n                    return { ...e, color: treeEdgeColor };\n                } else {\n                    return { ...e, color: defaultEdgeColor };\n                }\n            });\n        });\n\n        setVisitedNodes(prev => {\n            return nodes.map(node => {\n                if (path.includes(node.id)) {\n                    return { id: node.id, color: treeEdgeColor };\n                } else {\n                    return { id: node.id, color: \"black\" };\n                }\n            });\n        });\n\n        setTimeout(resetEdges, 1000);\n    };\n\n    // Function to start TSP\n    const startTSP = async () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"TSP\");\n        setIsTSP(true);\n        setAlgorithmRunning(true);\n        setText(\"Select Node to begin TSP\");\n    }\n\n    // Function to animate TSP\n    const tsp = async (node) => {\n        setAlgorithmStarted(true);\n        setText(\"TSP in progress...\");\n        const startNode = node;\n        const unvisited = new Set(nodes.map(node => node.id));\n        const visited = [];\n        const stack = [];\n        let currentNode = startNode;\n        let stepIndex = 0;\n\n        unvisited.delete(currentNode.id);\n        visited.push(currentNode);\n        setVisitedNodes([{ id: currentNode.id, color: treeEdgeColor }]);\n\n        while (unvisited.size > 0) {\n            let nearestNode = null;\n            let shortestDistance = Infinity;\n            let currentEdge = null;\n\n            for (let neighborId of unvisited) {\n                setCurrentNode(currentNode);\n                const neighborNode = nodes.find(node => node.id === neighborId);\n                // eslint-disable-next-line\n                const edge = edges.find(e => \n                    (isDirected && e && e.from && e.to && e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (!isDirected && e && e.from && e.to && ((e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === currentNode.id)))\n                );\n\n                if (!edge) {\n                    continue;\n                }\n                \n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n                stepIndex++;\n                if (isPausedRef.current) {\n                    await new Promise(resolve => {\n                        const checkStep = () => {\n                            if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                resolve();\n                            } else {\n                                setTimeout(checkStep, 50);\n                            }\n                        };\n                        checkStep();\n                    });\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                } else {\n                    await sleep(totalSliderCount - sliderValueRef.current);\n                }\n\n                if(isStepModeRef.current){\n                    setIsPaused(true);\n                    isPausedRef.current = true;\n                }\n                const distance = calculateEdgeLength({ from: currentNode, to: neighborNode });\n                setVisitedEdges(prev => prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)));\n                if (distance < shortestDistance) {\n                    shortestDistance = distance;\n                    nearestNode = neighborNode;\n                    currentEdge = edge;\n                }\n                \n            }\n\n            if (nearestNode && currentEdge) {\n                stack.push({ currentNode, nearestNode, shortestDistance });\n\n                setVisitedEdges(prev => [...prev, { ...currentEdge, color: treeEdgeColor }]);\n                setVisitedNodes(prev => [...prev, { id: nearestNode.id, color: treeEdgeColor }]);\n\n                stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n\n                currentNode = nearestNode;\n                unvisited.delete(currentNode.id);\n                visited.push(currentNode);\n            } else {\n                const previousState = stack.pop();\n                if (previousState) {\n                    currentNode = previousState.currentNode;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        setCurrentNode(null);\n        setAlgorithmStarted(false);\n        setText(\"TSP Done!\");\n        setTimeout(resetEdges, 1000);\n    };\n\n    // Function to color graph\n    const graphColoring = async () => {\n        if(algorithmRunning || isRemovingEdge){\n            return;\n        }\n        setRunningAlgorithm(\"Color\");\n        setDisablePause(true);\n        setAlgorithmRunning(true);\n        setText(\"Graph Coloring in progress...\");\n\n        const availableColors = componentColors;\n        const colors = {};\n\n        const colorGraph = (node) => {\n            const neighborColors = adjList[node.id].map(neighborId => colors[neighborId]);\n            for(let color of availableColors){\n                if(!neighborColors.includes(color)){\n                    colors[node.id] = color;\n                    break;\n                }\n            }\n        }\n\n        for(let node of nodes){\n            colorGraph(node);\n            setVisitedNodes(prev => [...prev, {id: node.id, color: colors[node.id]}]);\n            await new Promise(resolve => setTimeout(resolve, totalSliderCount - sliderValueRef.current));\n        }\n\n        setText(\"Graph Coloring Done!\");\n        setTimeout(resetEdges, 1000);\n    }\n\n    // Function to find connected components in a graph\n    const findConnectedComponents = async () => {\n        setRunningAlgorithm(\"Connected\");\n        setAlgorithmStarted(true);\n        setText(\"Connected Components in progress...\");\n        setAlgorithmRunning(true);\n        const visitedNodeSet = new Set();\n        const visitedEdgeSet = new Set();\n        let componentIndex = 0;\n        let stepIndex = 0;\n\n        const dfsRecursive = async (currentNode, componentColor) => {\n            if (visitedNodeSet.has(currentNode.id)) {\n                return;\n            }\n\n            visitedNodeSet.add(currentNode.id);\n            setVisitedNodes(prev => { \n                const updatedNodes = [...prev, { id: currentNode.id, color: componentColor }];\n                return updatedNodes;\n            });\n\n            for (let neighborId of adjList[currentNode.id]) {\n                setCurrentNode(currentNode);     \n                const neighborNode = nodes.find(node => node.id === neighborId); \n                const edge = edges.find(e =>                                     \n                    (e.from.id === currentNode.id && e.to.id === neighborId) ||\n                    (e.from.id === neighborId && e.to.id === currentNode.id)\n                );\n\n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n\n                if (!visitedEdgeSet.has(edge)) {\n                    stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if(isStepModeRef.current){\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n\n                    if(isStepModeRef.current){\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                }\n\n                if (!visitedNodeSet.has(neighborId)) { \n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: componentColor }\n                    ]);\n                    visitedEdgeSet.add(edge);\n\n                    await dfsRecursive(neighborNode, componentColor);\n                } else {\n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: componentColor }\n                    ]);\n                }\n            }\n        };\n\n        for (let node of nodes) {\n            if (!visitedNodeSet.has(node.id)) {\n                const componentColor = componentColors[componentIndex % componentColors.length];\n                componentIndex++;\n                await dfsRecursive(node, componentColor);\n            }\n        }\n\n        setCurrentNode(null);\n        setAlgorithmStarted(false);\n        setText(\"Connected Components Done!\");\n        setTimeout(resetEdges, 1000); \n    };\n\n    // Function to find strong components\n    const findStrongComponents = async () => {\n        setRunningAlgorithm(\"Connected\");\n        setAlgorithmStarted(true);\n        setText(\"Strong Components in progress...\");\n        setAlgorithmRunning(true);\n\n        const stack = [];\n        const visitedNodeSet = new Set();\n        const visitedEdgeSet = new Set();\n        const reverseAdjList = {};\n        let stepIndex = 0;\n\n        const dfs1 = async (node) => {\n            if (visitedNodeSet.has(node.id)) {\n                return;\n            }\n\n            visitedNodeSet.add(node.id);\n            \n            for (let neighborId of adjList[node.id]) {\n                if (!visitedNodeSet.has(neighborId)) {\n                    const neighborNode = nodes.find(n => n.id === neighborId);\n                    await dfs1(neighborNode);\n                }\n            }\n            \n            stack.push(node);\n        };\n\n        const reverseGraph = () => {\n            nodes.forEach(node => {\n                reverseAdjList[node.id] = [];\n            });\n            edges.forEach(edge => {\n                reverseAdjList[edge.to.id].push(edge.from.id);\n            });\n        };\n\n        const dfs2 = async (node, componentColor) => {\n            if (visitedNodeSet.has(node.id)) {\n                return;\n            }\n            \n            visitedNodeSet.add(node.id);\n            setVisitedNodes(prev => { \n                const updatedNodes = [...prev, { id: node.id, color: componentColor }];\n                return updatedNodes;\n            });\n        \n            for (let neighborId of reverseAdjList[node.id]) {\n                setCurrentNode(node);\n                const neighborNode = nodes.find(n => n.id === neighborId);\n                const edge = edges.find(e => e.from.id === node.id && e.to.id === neighborId);\n                \n                if (!edge) {\n                    continue;\n                }\n        \n                setVisitedEdges(prev => [...prev, { ...edge, color: currentEdgeColor }]);\n        \n                if (!visitedEdgeSet.has(edge)) {\n                    stepIndex++;\n                    if (isPausedRef.current) {\n                        await new Promise(resolve => {\n                            const checkStep = () => {\n                                if (!isPausedRef.current || currentStepRef.current > stepIndex) {\n                                    resolve();\n                                } else {\n                                    setTimeout(checkStep, 50);\n                                }\n                            };\n                            checkStep();\n                        });\n                        if (isStepModeRef.current) {\n                            setIsPaused(true);\n                            isPausedRef.current = true;\n                        }\n                    } else {\n                        await sleep(totalSliderCount - sliderValueRef.current);\n                    }\n        \n                    if (isStepModeRef.current) {\n                        setIsPaused(true);\n                        isPausedRef.current = true;\n                    }\n                }\n                \n                if (!visitedNodeSet.has(neighborId)) { \n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: componentColor }\n                    ]);\n                    visitedEdgeSet.add(edge);\n\n                    await dfs2(neighborNode, componentColor);\n                } else {\n                    setVisitedEdges(prev => [\n                        ...prev.filter(e => !(e.from.id === edge.from.id && e.to.id === edge.to.id)),\n                        { ...edge, color: componentColor }\n                    ]);\n                }\n            }\n        };\n\n        reverseGraph();\n\n        for (let node of nodes) {\n            if (!visitedNodeSet.has(node.id)) {\n                await dfs1(node);\n            }\n        }\n\n        visitedNodeSet.clear();\n        visitedEdgeSet.clear();\n\n        let componentIndex = 0;\n        while (stack.length > 0) {\n            const node = stack.pop();\n            if (!visitedNodeSet.has(node.id)) {\n                const componentColor = componentColors[componentIndex % componentColors.length];\n                componentIndex++;\n                await dfs2(node, componentColor);\n            }\n        }\n\n        setCurrentNode(null);\n        setAlgorithmStarted(false);\n        setText(\"Strong Components Done!\");\n        setTimeout(resetEdges, 1000);\n    };\n\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}